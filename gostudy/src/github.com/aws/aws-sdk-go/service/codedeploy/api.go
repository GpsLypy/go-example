// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package codedeploy

import (
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/private/protocol"
	"github.com/aws/aws-sdk-go/private/protocol/jsonrpc"
)

const opAddTagsToOnPremisesInstances = "AddTagsToOnPremisesInstances"

// AddTagsToOnPremisesInstancesRequest generates a "aws/request.Request" representing the
// client's request for the AddTagsToOnPremisesInstances operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See AddTagsToOnPremisesInstances for more information on using the AddTagsToOnPremisesInstances
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the AddTagsToOnPremisesInstancesRequest method.
//    req, resp := client.AddTagsToOnPremisesInstancesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/AddTagsToOnPremisesInstances
func (c *CodeDeploy) AddTagsToOnPremisesInstancesRequest(input *AddTagsToOnPremisesInstancesInput) (req *request.Request, output *AddTagsToOnPremisesInstancesOutput) {
	op := &request.Operation{
		Name:       opAddTagsToOnPremisesInstances,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &AddTagsToOnPremisesInstancesInput{}
	}

	output = &AddTagsToOnPremisesInstancesOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// AddTagsToOnPremisesInstances API operation for AWS CodeDeploy.
//
// Adds tags to on-premises instances.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation AddTagsToOnPremisesInstances for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInstanceNameRequiredException "InstanceNameRequiredException"
//   An on-premises instance name was not specified.
//
//   * ErrCodeInvalidInstanceNameException "InvalidInstanceNameException"
//   The on-premises instance name was specified in an invalid format.
//
//   * ErrCodeTagRequiredException "TagRequiredException"
//   A tag was not specified.
//
//   * ErrCodeInvalidTagException "InvalidTagException"
//   The tag was specified in an invalid format.
//
//   * ErrCodeTagLimitExceededException "TagLimitExceededException"
//   The maximum allowed number of tags was exceeded.
//
//   * ErrCodeInstanceLimitExceededException "InstanceLimitExceededException"
//   The maximum number of allowed on-premises instances in a single call was
//   exceeded.
//
//   * ErrCodeInstanceNotRegisteredException "InstanceNotRegisteredException"
//   The specified on-premises instance is not registered.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/AddTagsToOnPremisesInstances
func (c *CodeDeploy) AddTagsToOnPremisesInstances(input *AddTagsToOnPremisesInstancesInput) (*AddTagsToOnPremisesInstancesOutput, error) {
	req, out := c.AddTagsToOnPremisesInstancesRequest(input)
	return out, req.Send()
}

// AddTagsToOnPremisesInstancesWithContext is the same as AddTagsToOnPremisesInstances with the addition of
// the ability to pass a context and additional request options.
//
// See AddTagsToOnPremisesInstances for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) AddTagsToOnPremisesInstancesWithContext(ctx aws.Context, input *AddTagsToOnPremisesInstancesInput, opts ...request.Option) (*AddTagsToOnPremisesInstancesOutput, error) {
	req, out := c.AddTagsToOnPremisesInstancesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetApplicationRevisions = "BatchGetApplicationRevisions"

// BatchGetApplicationRevisionsRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetApplicationRevisions operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetApplicationRevisions for more information on using the BatchGetApplicationRevisions
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetApplicationRevisionsRequest method.
//    req, resp := client.BatchGetApplicationRevisionsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetApplicationRevisions
func (c *CodeDeploy) BatchGetApplicationRevisionsRequest(input *BatchGetApplicationRevisionsInput) (req *request.Request, output *BatchGetApplicationRevisionsOutput) {
	op := &request.Operation{
		Name:       opBatchGetApplicationRevisions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetApplicationRevisionsInput{}
	}

	output = &BatchGetApplicationRevisionsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetApplicationRevisions API operation for AWS CodeDeploy.
//
// Gets information about one or more application revisions. The maximum number
// of application revisions that can be returned is 25.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation BatchGetApplicationRevisions for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeRevisionRequiredException "RevisionRequiredException"
//   The revision ID was not specified.
//
//   * ErrCodeInvalidRevisionException "InvalidRevisionException"
//   The revision was specified in an invalid format.
//
//   * ErrCodeBatchLimitExceededException "BatchLimitExceededException"
//   The maximum number of names or IDs allowed for this request (100) was exceeded.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetApplicationRevisions
func (c *CodeDeploy) BatchGetApplicationRevisions(input *BatchGetApplicationRevisionsInput) (*BatchGetApplicationRevisionsOutput, error) {
	req, out := c.BatchGetApplicationRevisionsRequest(input)
	return out, req.Send()
}

// BatchGetApplicationRevisionsWithContext is the same as BatchGetApplicationRevisions with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetApplicationRevisions for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) BatchGetApplicationRevisionsWithContext(ctx aws.Context, input *BatchGetApplicationRevisionsInput, opts ...request.Option) (*BatchGetApplicationRevisionsOutput, error) {
	req, out := c.BatchGetApplicationRevisionsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetApplications = "BatchGetApplications"

// BatchGetApplicationsRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetApplications operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetApplications for more information on using the BatchGetApplications
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetApplicationsRequest method.
//    req, resp := client.BatchGetApplicationsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetApplications
func (c *CodeDeploy) BatchGetApplicationsRequest(input *BatchGetApplicationsInput) (req *request.Request, output *BatchGetApplicationsOutput) {
	op := &request.Operation{
		Name:       opBatchGetApplications,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetApplicationsInput{}
	}

	output = &BatchGetApplicationsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetApplications API operation for AWS CodeDeploy.
//
// Gets information about one or more applications. The maximum number of applications
// that can be returned is 25.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation BatchGetApplications for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeBatchLimitExceededException "BatchLimitExceededException"
//   The maximum number of names or IDs allowed for this request (100) was exceeded.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetApplications
func (c *CodeDeploy) BatchGetApplications(input *BatchGetApplicationsInput) (*BatchGetApplicationsOutput, error) {
	req, out := c.BatchGetApplicationsRequest(input)
	return out, req.Send()
}

// BatchGetApplicationsWithContext is the same as BatchGetApplications with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetApplications for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) BatchGetApplicationsWithContext(ctx aws.Context, input *BatchGetApplicationsInput, opts ...request.Option) (*BatchGetApplicationsOutput, error) {
	req, out := c.BatchGetApplicationsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetDeploymentGroups = "BatchGetDeploymentGroups"

// BatchGetDeploymentGroupsRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetDeploymentGroups operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetDeploymentGroups for more information on using the BatchGetDeploymentGroups
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetDeploymentGroupsRequest method.
//    req, resp := client.BatchGetDeploymentGroupsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetDeploymentGroups
func (c *CodeDeploy) BatchGetDeploymentGroupsRequest(input *BatchGetDeploymentGroupsInput) (req *request.Request, output *BatchGetDeploymentGroupsOutput) {
	op := &request.Operation{
		Name:       opBatchGetDeploymentGroups,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetDeploymentGroupsInput{}
	}

	output = &BatchGetDeploymentGroupsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetDeploymentGroups API operation for AWS CodeDeploy.
//
// Gets information about one or more deployment groups.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation BatchGetDeploymentGroups for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeDeploymentGroupNameRequiredException "DeploymentGroupNameRequiredException"
//   The deployment group name was not specified.
//
//   * ErrCodeInvalidDeploymentGroupNameException "InvalidDeploymentGroupNameException"
//   The deployment group name was specified in an invalid format.
//
//   * ErrCodeBatchLimitExceededException "BatchLimitExceededException"
//   The maximum number of names or IDs allowed for this request (100) was exceeded.
//
//   * ErrCodeDeploymentConfigDoesNotExistException "DeploymentConfigDoesNotExistException"
//   The deployment configuration does not exist with the IAM user or AWS account.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetDeploymentGroups
func (c *CodeDeploy) BatchGetDeploymentGroups(input *BatchGetDeploymentGroupsInput) (*BatchGetDeploymentGroupsOutput, error) {
	req, out := c.BatchGetDeploymentGroupsRequest(input)
	return out, req.Send()
}

// BatchGetDeploymentGroupsWithContext is the same as BatchGetDeploymentGroups with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetDeploymentGroups for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) BatchGetDeploymentGroupsWithContext(ctx aws.Context, input *BatchGetDeploymentGroupsInput, opts ...request.Option) (*BatchGetDeploymentGroupsOutput, error) {
	req, out := c.BatchGetDeploymentGroupsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetDeploymentInstances = "BatchGetDeploymentInstances"

// BatchGetDeploymentInstancesRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetDeploymentInstances operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetDeploymentInstances for more information on using the BatchGetDeploymentInstances
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetDeploymentInstancesRequest method.
//    req, resp := client.BatchGetDeploymentInstancesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetDeploymentInstances
//
// Deprecated: This operation is deprecated, use BatchGetDeploymentTargets instead.
func (c *CodeDeploy) BatchGetDeploymentInstancesRequest(input *BatchGetDeploymentInstancesInput) (req *request.Request, output *BatchGetDeploymentInstancesOutput) {
	if c.Client.Config.Logger != nil {
		c.Client.Config.Logger.Log("This operation, BatchGetDeploymentInstances, has been deprecated")
	}
	op := &request.Operation{
		Name:       opBatchGetDeploymentInstances,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetDeploymentInstancesInput{}
	}

	output = &BatchGetDeploymentInstancesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetDeploymentInstances API operation for AWS CodeDeploy.
//
//
// This method works, but is deprecated. Use BatchGetDeploymentTargets instead.
//
// Returns an array of one or more instances associated with a deployment. This
// method works with EC2/On-premises and AWS Lambda compute platforms. The newer
// BatchGetDeploymentTargets works with all compute platforms. The maximum number
// of instances that can be returned is 25.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation BatchGetDeploymentInstances for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeInstanceIdRequiredException "InstanceIdRequiredException"
//   The instance ID was not specified.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeInvalidInstanceNameException "InvalidInstanceNameException"
//   The on-premises instance name was specified in an invalid format.
//
//   * ErrCodeBatchLimitExceededException "BatchLimitExceededException"
//   The maximum number of names or IDs allowed for this request (100) was exceeded.
//
//   * ErrCodeInvalidComputePlatformException "InvalidComputePlatformException"
//   The computePlatform is invalid. The computePlatform should be Lambda or Server.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetDeploymentInstances
//
// Deprecated: This operation is deprecated, use BatchGetDeploymentTargets instead.
func (c *CodeDeploy) BatchGetDeploymentInstances(input *BatchGetDeploymentInstancesInput) (*BatchGetDeploymentInstancesOutput, error) {
	req, out := c.BatchGetDeploymentInstancesRequest(input)
	return out, req.Send()
}

// BatchGetDeploymentInstancesWithContext is the same as BatchGetDeploymentInstances with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetDeploymentInstances for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
//
// Deprecated: This operation is deprecated, use BatchGetDeploymentTargets instead.
func (c *CodeDeploy) BatchGetDeploymentInstancesWithContext(ctx aws.Context, input *BatchGetDeploymentInstancesInput, opts ...request.Option) (*BatchGetDeploymentInstancesOutput, error) {
	req, out := c.BatchGetDeploymentInstancesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetDeploymentTargets = "BatchGetDeploymentTargets"

// BatchGetDeploymentTargetsRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetDeploymentTargets operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetDeploymentTargets for more information on using the BatchGetDeploymentTargets
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetDeploymentTargetsRequest method.
//    req, resp := client.BatchGetDeploymentTargetsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetDeploymentTargets
func (c *CodeDeploy) BatchGetDeploymentTargetsRequest(input *BatchGetDeploymentTargetsInput) (req *request.Request, output *BatchGetDeploymentTargetsOutput) {
	op := &request.Operation{
		Name:       opBatchGetDeploymentTargets,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetDeploymentTargetsInput{}
	}

	output = &BatchGetDeploymentTargetsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetDeploymentTargets API operation for AWS CodeDeploy.
//
// Returns an array of one or more targets associated with a deployment. This
// method works with all compute types and should be used instead of the deprecated
// BatchGetDeploymentInstances. The maximum number of targets that can be returned
// is 25.
//
// The type of targets returned depends on the deployment's compute platform:
//
//    * EC2/On-premises: Information about EC2 instance targets.
//
//    * AWS Lambda: Information about Lambda functions targets.
//
//    * Amazon ECS: Information about Amazon ECS service targets.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation BatchGetDeploymentTargets for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentNotStartedException "DeploymentNotStartedException"
//   The specified deployment has not started.
//
//   * ErrCodeDeploymentTargetIdRequiredException "DeploymentTargetIdRequiredException"
//   A deployment target ID was not provided.
//
//   * ErrCodeInvalidDeploymentTargetIdException "InvalidDeploymentTargetIdException"
//   The target ID provided was not valid.
//
//   * ErrCodeDeploymentTargetDoesNotExistException "DeploymentTargetDoesNotExistException"
//   The provided target ID does not belong to the attempted deployment.
//
//   * ErrCodeDeploymentTargetListSizeExceededException "DeploymentTargetListSizeExceededException"
//   The maximum number of targets that can be associated with an Amazon ECS or
//   AWS Lambda deployment was exceeded. The target list of both types of deployments
//   must have exactly one item. This exception does not apply to EC2/On-premises
//   deployments.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetDeploymentTargets
func (c *CodeDeploy) BatchGetDeploymentTargets(input *BatchGetDeploymentTargetsInput) (*BatchGetDeploymentTargetsOutput, error) {
	req, out := c.BatchGetDeploymentTargetsRequest(input)
	return out, req.Send()
}

// BatchGetDeploymentTargetsWithContext is the same as BatchGetDeploymentTargets with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetDeploymentTargets for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) BatchGetDeploymentTargetsWithContext(ctx aws.Context, input *BatchGetDeploymentTargetsInput, opts ...request.Option) (*BatchGetDeploymentTargetsOutput, error) {
	req, out := c.BatchGetDeploymentTargetsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetDeployments = "BatchGetDeployments"

// BatchGetDeploymentsRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetDeployments operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetDeployments for more information on using the BatchGetDeployments
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetDeploymentsRequest method.
//    req, resp := client.BatchGetDeploymentsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetDeployments
func (c *CodeDeploy) BatchGetDeploymentsRequest(input *BatchGetDeploymentsInput) (req *request.Request, output *BatchGetDeploymentsOutput) {
	op := &request.Operation{
		Name:       opBatchGetDeployments,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetDeploymentsInput{}
	}

	output = &BatchGetDeploymentsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetDeployments API operation for AWS CodeDeploy.
//
// Gets information about one or more deployments. The maximum number of deployments
// that can be returned is 25.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation BatchGetDeployments for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeBatchLimitExceededException "BatchLimitExceededException"
//   The maximum number of names or IDs allowed for this request (100) was exceeded.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetDeployments
func (c *CodeDeploy) BatchGetDeployments(input *BatchGetDeploymentsInput) (*BatchGetDeploymentsOutput, error) {
	req, out := c.BatchGetDeploymentsRequest(input)
	return out, req.Send()
}

// BatchGetDeploymentsWithContext is the same as BatchGetDeployments with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetDeployments for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) BatchGetDeploymentsWithContext(ctx aws.Context, input *BatchGetDeploymentsInput, opts ...request.Option) (*BatchGetDeploymentsOutput, error) {
	req, out := c.BatchGetDeploymentsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetOnPremisesInstances = "BatchGetOnPremisesInstances"

// BatchGetOnPremisesInstancesRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetOnPremisesInstances operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetOnPremisesInstances for more information on using the BatchGetOnPremisesInstances
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetOnPremisesInstancesRequest method.
//    req, resp := client.BatchGetOnPremisesInstancesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetOnPremisesInstances
func (c *CodeDeploy) BatchGetOnPremisesInstancesRequest(input *BatchGetOnPremisesInstancesInput) (req *request.Request, output *BatchGetOnPremisesInstancesOutput) {
	op := &request.Operation{
		Name:       opBatchGetOnPremisesInstances,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetOnPremisesInstancesInput{}
	}

	output = &BatchGetOnPremisesInstancesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetOnPremisesInstances API operation for AWS CodeDeploy.
//
// Gets information about one or more on-premises instances. The maximum number
// of on-premises instances that can be returned is 25.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation BatchGetOnPremisesInstances for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInstanceNameRequiredException "InstanceNameRequiredException"
//   An on-premises instance name was not specified.
//
//   * ErrCodeInvalidInstanceNameException "InvalidInstanceNameException"
//   The on-premises instance name was specified in an invalid format.
//
//   * ErrCodeBatchLimitExceededException "BatchLimitExceededException"
//   The maximum number of names or IDs allowed for this request (100) was exceeded.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/BatchGetOnPremisesInstances
func (c *CodeDeploy) BatchGetOnPremisesInstances(input *BatchGetOnPremisesInstancesInput) (*BatchGetOnPremisesInstancesOutput, error) {
	req, out := c.BatchGetOnPremisesInstancesRequest(input)
	return out, req.Send()
}

// BatchGetOnPremisesInstancesWithContext is the same as BatchGetOnPremisesInstances with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetOnPremisesInstances for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) BatchGetOnPremisesInstancesWithContext(ctx aws.Context, input *BatchGetOnPremisesInstancesInput, opts ...request.Option) (*BatchGetOnPremisesInstancesOutput, error) {
	req, out := c.BatchGetOnPremisesInstancesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opContinueDeployment = "ContinueDeployment"

// ContinueDeploymentRequest generates a "aws/request.Request" representing the
// client's request for the ContinueDeployment operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ContinueDeployment for more information on using the ContinueDeployment
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ContinueDeploymentRequest method.
//    req, resp := client.ContinueDeploymentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ContinueDeployment
func (c *CodeDeploy) ContinueDeploymentRequest(input *ContinueDeploymentInput) (req *request.Request, output *ContinueDeploymentOutput) {
	op := &request.Operation{
		Name:       opContinueDeployment,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ContinueDeploymentInput{}
	}

	output = &ContinueDeploymentOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// ContinueDeployment API operation for AWS CodeDeploy.
//
// For a blue/green deployment, starts the process of rerouting traffic from
// instances in the original environment to instances in the replacement environment
// without waiting for a specified wait time to elapse. (Traffic rerouting,
// which is achieved by registering instances in the replacement environment
// with the load balancer, can start as soon as all instances have a status
// of Ready.)
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ContinueDeployment for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentAlreadyCompletedException "DeploymentAlreadyCompletedException"
//   The deployment is already complete.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeDeploymentIsNotInReadyStateException "DeploymentIsNotInReadyStateException"
//   The deployment does not have a status of Ready and can't continue yet.
//
//   * ErrCodeUnsupportedActionForDeploymentTypeException "UnsupportedActionForDeploymentTypeException"
//   A call was submitted that is not supported for the specified deployment type.
//
//   * ErrCodeInvalidDeploymentWaitTypeException "InvalidDeploymentWaitTypeException"
//   The wait type is invalid.
//
//   * ErrCodeInvalidDeploymentStatusException "InvalidDeploymentStatusException"
//   The specified deployment status doesn't exist or cannot be determined.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ContinueDeployment
func (c *CodeDeploy) ContinueDeployment(input *ContinueDeploymentInput) (*ContinueDeploymentOutput, error) {
	req, out := c.ContinueDeploymentRequest(input)
	return out, req.Send()
}

// ContinueDeploymentWithContext is the same as ContinueDeployment with the addition of
// the ability to pass a context and additional request options.
//
// See ContinueDeployment for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ContinueDeploymentWithContext(ctx aws.Context, input *ContinueDeploymentInput, opts ...request.Option) (*ContinueDeploymentOutput, error) {
	req, out := c.ContinueDeploymentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateApplication = "CreateApplication"

// CreateApplicationRequest generates a "aws/request.Request" representing the
// client's request for the CreateApplication operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateApplication for more information on using the CreateApplication
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateApplicationRequest method.
//    req, resp := client.CreateApplicationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/CreateApplication
func (c *CodeDeploy) CreateApplicationRequest(input *CreateApplicationInput) (req *request.Request, output *CreateApplicationOutput) {
	op := &request.Operation{
		Name:       opCreateApplication,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateApplicationInput{}
	}

	output = &CreateApplicationOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateApplication API operation for AWS CodeDeploy.
//
// Creates an application.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation CreateApplication for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationAlreadyExistsException "ApplicationAlreadyExistsException"
//   An application with the specified name with the IAM user or AWS account already
//   exists.
//
//   * ErrCodeApplicationLimitExceededException "ApplicationLimitExceededException"
//   More applications were attempted to be created than are allowed.
//
//   * ErrCodeInvalidComputePlatformException "InvalidComputePlatformException"
//   The computePlatform is invalid. The computePlatform should be Lambda or Server.
//
//   * ErrCodeInvalidTagsToAddException "InvalidTagsToAddException"
//   The specified tags are not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/CreateApplication
func (c *CodeDeploy) CreateApplication(input *CreateApplicationInput) (*CreateApplicationOutput, error) {
	req, out := c.CreateApplicationRequest(input)
	return out, req.Send()
}

// CreateApplicationWithContext is the same as CreateApplication with the addition of
// the ability to pass a context and additional request options.
//
// See CreateApplication for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) CreateApplicationWithContext(ctx aws.Context, input *CreateApplicationInput, opts ...request.Option) (*CreateApplicationOutput, error) {
	req, out := c.CreateApplicationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateDeployment = "CreateDeployment"

// CreateDeploymentRequest generates a "aws/request.Request" representing the
// client's request for the CreateDeployment operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateDeployment for more information on using the CreateDeployment
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateDeploymentRequest method.
//    req, resp := client.CreateDeploymentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/CreateDeployment
func (c *CodeDeploy) CreateDeploymentRequest(input *CreateDeploymentInput) (req *request.Request, output *CreateDeploymentOutput) {
	op := &request.Operation{
		Name:       opCreateDeployment,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateDeploymentInput{}
	}

	output = &CreateDeploymentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateDeployment API operation for AWS CodeDeploy.
//
// Deploys an application revision through the specified deployment group.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation CreateDeployment for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeDeploymentGroupNameRequiredException "DeploymentGroupNameRequiredException"
//   The deployment group name was not specified.
//
//   * ErrCodeInvalidDeploymentGroupNameException "InvalidDeploymentGroupNameException"
//   The deployment group name was specified in an invalid format.
//
//   * ErrCodeDeploymentGroupDoesNotExistException "DeploymentGroupDoesNotExistException"
//   The named deployment group with the IAM user or AWS account does not exist.
//
//   * ErrCodeRevisionRequiredException "RevisionRequiredException"
//   The revision ID was not specified.
//
//   * ErrCodeRevisionDoesNotExistException "RevisionDoesNotExistException"
//   The named revision does not exist with the IAM user or AWS account.
//
//   * ErrCodeInvalidRevisionException "InvalidRevisionException"
//   The revision was specified in an invalid format.
//
//   * ErrCodeInvalidDeploymentConfigNameException "InvalidDeploymentConfigNameException"
//   The deployment configuration name was specified in an invalid format.
//
//   * ErrCodeDeploymentConfigDoesNotExistException "DeploymentConfigDoesNotExistException"
//   The deployment configuration does not exist with the IAM user or AWS account.
//
//   * ErrCodeDescriptionTooLongException "DescriptionTooLongException"
//   The description is too long.
//
//   * ErrCodeDeploymentLimitExceededException "DeploymentLimitExceededException"
//   The number of allowed deployments was exceeded.
//
//   * ErrCodeInvalidTargetInstancesException "InvalidTargetInstancesException"
//   The target instance configuration is invalid. Possible causes include:
//
//      * Configuration data for target instances was entered for an in-place
//      deployment.
//
//      * The limit of 10 tags for a tag type was exceeded.
//
//      * The combined length of the tag names exceeded the limit.
//
//      * A specified tag is not currently applied to any instances.
//
//   * ErrCodeInvalidAutoRollbackConfigException "InvalidAutoRollbackConfigException"
//   The automatic rollback configuration was specified in an invalid format.
//   For example, automatic rollback is enabled, but an invalid triggering event
//   type or no event types were listed.
//
//   * ErrCodeInvalidLoadBalancerInfoException "InvalidLoadBalancerInfoException"
//   An invalid load balancer name, or no load balancer name, was specified.
//
//   * ErrCodeInvalidFileExistsBehaviorException "InvalidFileExistsBehaviorException"
//   An invalid fileExistsBehavior option was specified to determine how AWS CodeDeploy
//   handles files or directories that already exist in a deployment target location,
//   but weren't part of the previous successful deployment. Valid values include
//   "DISALLOW," "OVERWRITE," and "RETAIN."
//
//   * ErrCodeInvalidRoleException "InvalidRoleException"
//   The service role ARN was specified in an invalid format. Or, if an Auto Scaling
//   group was specified, the specified service role does not grant the appropriate
//   permissions to Amazon EC2 Auto Scaling.
//
//   * ErrCodeInvalidAutoScalingGroupException "InvalidAutoScalingGroupException"
//   The Auto Scaling group was specified in an invalid format or does not exist.
//
//   * ErrCodeThrottlingException "ThrottlingException"
//   An API function was called too frequently.
//
//   * ErrCodeInvalidUpdateOutdatedInstancesOnlyValueException "InvalidUpdateOutdatedInstancesOnlyValueException"
//   The UpdateOutdatedInstancesOnly value is invalid. For AWS Lambda deployments,
//   false is expected. For EC2/On-premises deployments, true or false is expected.
//
//   * ErrCodeInvalidIgnoreApplicationStopFailuresValueException "InvalidIgnoreApplicationStopFailuresValueException"
//   The IgnoreApplicationStopFailures value is invalid. For AWS Lambda deployments,
//   false is expected. For EC2/On-premises deployments, true or false is expected.
//
//   * ErrCodeInvalidGitHubAccountTokenException "InvalidGitHubAccountTokenException"
//   The GitHub token is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/CreateDeployment
func (c *CodeDeploy) CreateDeployment(input *CreateDeploymentInput) (*CreateDeploymentOutput, error) {
	req, out := c.CreateDeploymentRequest(input)
	return out, req.Send()
}

// CreateDeploymentWithContext is the same as CreateDeployment with the addition of
// the ability to pass a context and additional request options.
//
// See CreateDeployment for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) CreateDeploymentWithContext(ctx aws.Context, input *CreateDeploymentInput, opts ...request.Option) (*CreateDeploymentOutput, error) {
	req, out := c.CreateDeploymentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateDeploymentConfig = "CreateDeploymentConfig"

// CreateDeploymentConfigRequest generates a "aws/request.Request" representing the
// client's request for the CreateDeploymentConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateDeploymentConfig for more information on using the CreateDeploymentConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateDeploymentConfigRequest method.
//    req, resp := client.CreateDeploymentConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/CreateDeploymentConfig
func (c *CodeDeploy) CreateDeploymentConfigRequest(input *CreateDeploymentConfigInput) (req *request.Request, output *CreateDeploymentConfigOutput) {
	op := &request.Operation{
		Name:       opCreateDeploymentConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateDeploymentConfigInput{}
	}

	output = &CreateDeploymentConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateDeploymentConfig API operation for AWS CodeDeploy.
//
// Creates a deployment configuration.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation CreateDeploymentConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidDeploymentConfigNameException "InvalidDeploymentConfigNameException"
//   The deployment configuration name was specified in an invalid format.
//
//   * ErrCodeDeploymentConfigNameRequiredException "DeploymentConfigNameRequiredException"
//   The deployment configuration name was not specified.
//
//   * ErrCodeDeploymentConfigAlreadyExistsException "DeploymentConfigAlreadyExistsException"
//   A deployment configuration with the specified name with the IAM user or AWS
//   account already exists .
//
//   * ErrCodeInvalidMinimumHealthyHostValueException "InvalidMinimumHealthyHostValueException"
//   The minimum healthy instance value was specified in an invalid format.
//
//   * ErrCodeDeploymentConfigLimitExceededException "DeploymentConfigLimitExceededException"
//   The deployment configurations limit was exceeded.
//
//   * ErrCodeInvalidComputePlatformException "InvalidComputePlatformException"
//   The computePlatform is invalid. The computePlatform should be Lambda or Server.
//
//   * ErrCodeInvalidTrafficRoutingConfigurationException "InvalidTrafficRoutingConfigurationException"
//   The configuration that specifies how traffic is routed during a deployment
//   is invalid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/CreateDeploymentConfig
func (c *CodeDeploy) CreateDeploymentConfig(input *CreateDeploymentConfigInput) (*CreateDeploymentConfigOutput, error) {
	req, out := c.CreateDeploymentConfigRequest(input)
	return out, req.Send()
}

// CreateDeploymentConfigWithContext is the same as CreateDeploymentConfig with the addition of
// the ability to pass a context and additional request options.
//
// See CreateDeploymentConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) CreateDeploymentConfigWithContext(ctx aws.Context, input *CreateDeploymentConfigInput, opts ...request.Option) (*CreateDeploymentConfigOutput, error) {
	req, out := c.CreateDeploymentConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateDeploymentGroup = "CreateDeploymentGroup"

// CreateDeploymentGroupRequest generates a "aws/request.Request" representing the
// client's request for the CreateDeploymentGroup operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateDeploymentGroup for more information on using the CreateDeploymentGroup
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateDeploymentGroupRequest method.
//    req, resp := client.CreateDeploymentGroupRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/CreateDeploymentGroup
func (c *CodeDeploy) CreateDeploymentGroupRequest(input *CreateDeploymentGroupInput) (req *request.Request, output *CreateDeploymentGroupOutput) {
	op := &request.Operation{
		Name:       opCreateDeploymentGroup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateDeploymentGroupInput{}
	}

	output = &CreateDeploymentGroupOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateDeploymentGroup API operation for AWS CodeDeploy.
//
// Creates a deployment group to which application revisions are deployed.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation CreateDeploymentGroup for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeDeploymentGroupNameRequiredException "DeploymentGroupNameRequiredException"
//   The deployment group name was not specified.
//
//   * ErrCodeInvalidDeploymentGroupNameException "InvalidDeploymentGroupNameException"
//   The deployment group name was specified in an invalid format.
//
//   * ErrCodeDeploymentGroupAlreadyExistsException "DeploymentGroupAlreadyExistsException"
//   A deployment group with the specified name with the IAM user or AWS account
//   already exists.
//
//   * ErrCodeInvalidEC2TagException "InvalidEC2TagException"
//   The tag was specified in an invalid format.
//
//   * ErrCodeInvalidTagException "InvalidTagException"
//   The tag was specified in an invalid format.
//
//   * ErrCodeInvalidAutoScalingGroupException "InvalidAutoScalingGroupException"
//   The Auto Scaling group was specified in an invalid format or does not exist.
//
//   * ErrCodeInvalidDeploymentConfigNameException "InvalidDeploymentConfigNameException"
//   The deployment configuration name was specified in an invalid format.
//
//   * ErrCodeDeploymentConfigDoesNotExistException "DeploymentConfigDoesNotExistException"
//   The deployment configuration does not exist with the IAM user or AWS account.
//
//   * ErrCodeRoleRequiredException "RoleRequiredException"
//   The role ID was not specified.
//
//   * ErrCodeInvalidRoleException "InvalidRoleException"
//   The service role ARN was specified in an invalid format. Or, if an Auto Scaling
//   group was specified, the specified service role does not grant the appropriate
//   permissions to Amazon EC2 Auto Scaling.
//
//   * ErrCodeDeploymentGroupLimitExceededException "DeploymentGroupLimitExceededException"
//   The deployment groups limit was exceeded.
//
//   * ErrCodeLifecycleHookLimitExceededException "LifecycleHookLimitExceededException"
//   The limit for lifecycle hooks was exceeded.
//
//   * ErrCodeInvalidTriggerConfigException "InvalidTriggerConfigException"
//   The trigger was specified in an invalid format.
//
//   * ErrCodeTriggerTargetsLimitExceededException "TriggerTargetsLimitExceededException"
//   The maximum allowed number of triggers was exceeded.
//
//   * ErrCodeInvalidAlarmConfigException "InvalidAlarmConfigException"
//   The format of the alarm configuration is invalid. Possible causes include:
//
//      * The alarm list is null.
//
//      * The alarm object is null.
//
//      * The alarm name is empty or null or exceeds the limit of 255 characters.
//
//      * Two alarms with the same name have been specified.
//
//      * The alarm configuration is enabled, but the alarm list is empty.
//
//   * ErrCodeAlarmsLimitExceededException "AlarmsLimitExceededException"
//   The maximum number of alarms for a deployment group (10) was exceeded.
//
//   * ErrCodeInvalidAutoRollbackConfigException "InvalidAutoRollbackConfigException"
//   The automatic rollback configuration was specified in an invalid format.
//   For example, automatic rollback is enabled, but an invalid triggering event
//   type or no event types were listed.
//
//   * ErrCodeInvalidLoadBalancerInfoException "InvalidLoadBalancerInfoException"
//   An invalid load balancer name, or no load balancer name, was specified.
//
//   * ErrCodeInvalidDeploymentStyleException "InvalidDeploymentStyleException"
//   An invalid deployment style was specified. Valid deployment types include
//   "IN_PLACE" and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL"
//   and "WITHOUT_TRAFFIC_CONTROL."
//
//   * ErrCodeInvalidBlueGreenDeploymentConfigurationException "InvalidBlueGreenDeploymentConfigurationException"
//   The configuration for the blue/green deployment group was provided in an
//   invalid format. For information about deployment configuration format, see
//   CreateDeploymentConfig.
//
//   * ErrCodeInvalidEC2TagCombinationException "InvalidEC2TagCombinationException"
//   A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but
//   only one of these data types can be used in a single call.
//
//   * ErrCodeInvalidOnPremisesTagCombinationException "InvalidOnPremisesTagCombinationException"
//   A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet,
//   but only one of these data types can be used in a single call.
//
//   * ErrCodeTagSetListLimitExceededException "TagSetListLimitExceededException"
//   The number of tag groups included in the tag set list exceeded the maximum
//   allowed limit of 3.
//
//   * ErrCodeInvalidInputException "InvalidInputException"
//   The input was specified in an invalid format.
//
//   * ErrCodeThrottlingException "ThrottlingException"
//   An API function was called too frequently.
//
//   * ErrCodeInvalidECSServiceException "InvalidECSServiceException"
//   The Amazon ECS service identifier is not valid.
//
//   * ErrCodeInvalidTargetGroupPairException "InvalidTargetGroupPairException"
//   A target group pair associated with this deployment is not valid.
//
//   * ErrCodeECSServiceMappingLimitExceededException "ECSServiceMappingLimitExceededException"
//   The Amazon ECS service is associated with more than one deployment groups.
//   An Amazon ECS service can be associated with only one deployment group.
//
//   * ErrCodeInvalidTagsToAddException "InvalidTagsToAddException"
//   The specified tags are not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/CreateDeploymentGroup
func (c *CodeDeploy) CreateDeploymentGroup(input *CreateDeploymentGroupInput) (*CreateDeploymentGroupOutput, error) {
	req, out := c.CreateDeploymentGroupRequest(input)
	return out, req.Send()
}

// CreateDeploymentGroupWithContext is the same as CreateDeploymentGroup with the addition of
// the ability to pass a context and additional request options.
//
// See CreateDeploymentGroup for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) CreateDeploymentGroupWithContext(ctx aws.Context, input *CreateDeploymentGroupInput, opts ...request.Option) (*CreateDeploymentGroupOutput, error) {
	req, out := c.CreateDeploymentGroupRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteApplication = "DeleteApplication"

// DeleteApplicationRequest generates a "aws/request.Request" representing the
// client's request for the DeleteApplication operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteApplication for more information on using the DeleteApplication
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteApplicationRequest method.
//    req, resp := client.DeleteApplicationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeleteApplication
func (c *CodeDeploy) DeleteApplicationRequest(input *DeleteApplicationInput) (req *request.Request, output *DeleteApplicationOutput) {
	op := &request.Operation{
		Name:       opDeleteApplication,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteApplicationInput{}
	}

	output = &DeleteApplicationOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DeleteApplication API operation for AWS CodeDeploy.
//
// Deletes an application.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation DeleteApplication for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeInvalidRoleException "InvalidRoleException"
//   The service role ARN was specified in an invalid format. Or, if an Auto Scaling
//   group was specified, the specified service role does not grant the appropriate
//   permissions to Amazon EC2 Auto Scaling.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeleteApplication
func (c *CodeDeploy) DeleteApplication(input *DeleteApplicationInput) (*DeleteApplicationOutput, error) {
	req, out := c.DeleteApplicationRequest(input)
	return out, req.Send()
}

// DeleteApplicationWithContext is the same as DeleteApplication with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteApplication for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) DeleteApplicationWithContext(ctx aws.Context, input *DeleteApplicationInput, opts ...request.Option) (*DeleteApplicationOutput, error) {
	req, out := c.DeleteApplicationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteDeploymentConfig = "DeleteDeploymentConfig"

// DeleteDeploymentConfigRequest generates a "aws/request.Request" representing the
// client's request for the DeleteDeploymentConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteDeploymentConfig for more information on using the DeleteDeploymentConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteDeploymentConfigRequest method.
//    req, resp := client.DeleteDeploymentConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeleteDeploymentConfig
func (c *CodeDeploy) DeleteDeploymentConfigRequest(input *DeleteDeploymentConfigInput) (req *request.Request, output *DeleteDeploymentConfigOutput) {
	op := &request.Operation{
		Name:       opDeleteDeploymentConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteDeploymentConfigInput{}
	}

	output = &DeleteDeploymentConfigOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DeleteDeploymentConfig API operation for AWS CodeDeploy.
//
// Deletes a deployment configuration.
//
// A deployment configuration cannot be deleted if it is currently in use. Predefined
// configurations cannot be deleted.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation DeleteDeploymentConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidDeploymentConfigNameException "InvalidDeploymentConfigNameException"
//   The deployment configuration name was specified in an invalid format.
//
//   * ErrCodeDeploymentConfigNameRequiredException "DeploymentConfigNameRequiredException"
//   The deployment configuration name was not specified.
//
//   * ErrCodeDeploymentConfigInUseException "DeploymentConfigInUseException"
//   The deployment configuration is still in use.
//
//   * ErrCodeInvalidOperationException "InvalidOperationException"
//   An invalid operation was detected.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeleteDeploymentConfig
func (c *CodeDeploy) DeleteDeploymentConfig(input *DeleteDeploymentConfigInput) (*DeleteDeploymentConfigOutput, error) {
	req, out := c.DeleteDeploymentConfigRequest(input)
	return out, req.Send()
}

// DeleteDeploymentConfigWithContext is the same as DeleteDeploymentConfig with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteDeploymentConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) DeleteDeploymentConfigWithContext(ctx aws.Context, input *DeleteDeploymentConfigInput, opts ...request.Option) (*DeleteDeploymentConfigOutput, error) {
	req, out := c.DeleteDeploymentConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteDeploymentGroup = "DeleteDeploymentGroup"

// DeleteDeploymentGroupRequest generates a "aws/request.Request" representing the
// client's request for the DeleteDeploymentGroup operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteDeploymentGroup for more information on using the DeleteDeploymentGroup
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteDeploymentGroupRequest method.
//    req, resp := client.DeleteDeploymentGroupRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeleteDeploymentGroup
func (c *CodeDeploy) DeleteDeploymentGroupRequest(input *DeleteDeploymentGroupInput) (req *request.Request, output *DeleteDeploymentGroupOutput) {
	op := &request.Operation{
		Name:       opDeleteDeploymentGroup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteDeploymentGroupInput{}
	}

	output = &DeleteDeploymentGroupOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteDeploymentGroup API operation for AWS CodeDeploy.
//
// Deletes a deployment group.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation DeleteDeploymentGroup for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeDeploymentGroupNameRequiredException "DeploymentGroupNameRequiredException"
//   The deployment group name was not specified.
//
//   * ErrCodeInvalidDeploymentGroupNameException "InvalidDeploymentGroupNameException"
//   The deployment group name was specified in an invalid format.
//
//   * ErrCodeInvalidRoleException "InvalidRoleException"
//   The service role ARN was specified in an invalid format. Or, if an Auto Scaling
//   group was specified, the specified service role does not grant the appropriate
//   permissions to Amazon EC2 Auto Scaling.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeleteDeploymentGroup
func (c *CodeDeploy) DeleteDeploymentGroup(input *DeleteDeploymentGroupInput) (*DeleteDeploymentGroupOutput, error) {
	req, out := c.DeleteDeploymentGroupRequest(input)
	return out, req.Send()
}

// DeleteDeploymentGroupWithContext is the same as DeleteDeploymentGroup with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteDeploymentGroup for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) DeleteDeploymentGroupWithContext(ctx aws.Context, input *DeleteDeploymentGroupInput, opts ...request.Option) (*DeleteDeploymentGroupOutput, error) {
	req, out := c.DeleteDeploymentGroupRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteGitHubAccountToken = "DeleteGitHubAccountToken"

// DeleteGitHubAccountTokenRequest generates a "aws/request.Request" representing the
// client's request for the DeleteGitHubAccountToken operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteGitHubAccountToken for more information on using the DeleteGitHubAccountToken
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteGitHubAccountTokenRequest method.
//    req, resp := client.DeleteGitHubAccountTokenRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeleteGitHubAccountToken
func (c *CodeDeploy) DeleteGitHubAccountTokenRequest(input *DeleteGitHubAccountTokenInput) (req *request.Request, output *DeleteGitHubAccountTokenOutput) {
	op := &request.Operation{
		Name:       opDeleteGitHubAccountToken,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteGitHubAccountTokenInput{}
	}

	output = &DeleteGitHubAccountTokenOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteGitHubAccountToken API operation for AWS CodeDeploy.
//
// Deletes a GitHub account connection.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation DeleteGitHubAccountToken for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeGitHubAccountTokenNameRequiredException "GitHubAccountTokenNameRequiredException"
//   The call is missing a required GitHub account connection name.
//
//   * ErrCodeGitHubAccountTokenDoesNotExistException "GitHubAccountTokenDoesNotExistException"
//   No GitHub account connection exists with the named specified in the call.
//
//   * ErrCodeInvalidGitHubAccountTokenNameException "InvalidGitHubAccountTokenNameException"
//   The format of the specified GitHub account connection name is invalid.
//
//   * ErrCodeResourceValidationException "ResourceValidationException"
//   The specified resource could not be validated.
//
//   * ErrCodeOperationNotSupportedException "OperationNotSupportedException"
//   The API used does not support the deployment.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeleteGitHubAccountToken
func (c *CodeDeploy) DeleteGitHubAccountToken(input *DeleteGitHubAccountTokenInput) (*DeleteGitHubAccountTokenOutput, error) {
	req, out := c.DeleteGitHubAccountTokenRequest(input)
	return out, req.Send()
}

// DeleteGitHubAccountTokenWithContext is the same as DeleteGitHubAccountToken with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteGitHubAccountToken for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) DeleteGitHubAccountTokenWithContext(ctx aws.Context, input *DeleteGitHubAccountTokenInput, opts ...request.Option) (*DeleteGitHubAccountTokenOutput, error) {
	req, out := c.DeleteGitHubAccountTokenRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeregisterOnPremisesInstance = "DeregisterOnPremisesInstance"

// DeregisterOnPremisesInstanceRequest generates a "aws/request.Request" representing the
// client's request for the DeregisterOnPremisesInstance operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeregisterOnPremisesInstance for more information on using the DeregisterOnPremisesInstance
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeregisterOnPremisesInstanceRequest method.
//    req, resp := client.DeregisterOnPremisesInstanceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeregisterOnPremisesInstance
func (c *CodeDeploy) DeregisterOnPremisesInstanceRequest(input *DeregisterOnPremisesInstanceInput) (req *request.Request, output *DeregisterOnPremisesInstanceOutput) {
	op := &request.Operation{
		Name:       opDeregisterOnPremisesInstance,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeregisterOnPremisesInstanceInput{}
	}

	output = &DeregisterOnPremisesInstanceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DeregisterOnPremisesInstance API operation for AWS CodeDeploy.
//
// Deregisters an on-premises instance.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation DeregisterOnPremisesInstance for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInstanceNameRequiredException "InstanceNameRequiredException"
//   An on-premises instance name was not specified.
//
//   * ErrCodeInvalidInstanceNameException "InvalidInstanceNameException"
//   The on-premises instance name was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/DeregisterOnPremisesInstance
func (c *CodeDeploy) DeregisterOnPremisesInstance(input *DeregisterOnPremisesInstanceInput) (*DeregisterOnPremisesInstanceOutput, error) {
	req, out := c.DeregisterOnPremisesInstanceRequest(input)
	return out, req.Send()
}

// DeregisterOnPremisesInstanceWithContext is the same as DeregisterOnPremisesInstance with the addition of
// the ability to pass a context and additional request options.
//
// See DeregisterOnPremisesInstance for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) DeregisterOnPremisesInstanceWithContext(ctx aws.Context, input *DeregisterOnPremisesInstanceInput, opts ...request.Option) (*DeregisterOnPremisesInstanceOutput, error) {
	req, out := c.DeregisterOnPremisesInstanceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetApplication = "GetApplication"

// GetApplicationRequest generates a "aws/request.Request" representing the
// client's request for the GetApplication operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetApplication for more information on using the GetApplication
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetApplicationRequest method.
//    req, resp := client.GetApplicationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetApplication
func (c *CodeDeploy) GetApplicationRequest(input *GetApplicationInput) (req *request.Request, output *GetApplicationOutput) {
	op := &request.Operation{
		Name:       opGetApplication,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetApplicationInput{}
	}

	output = &GetApplicationOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetApplication API operation for AWS CodeDeploy.
//
// Gets information about an application.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation GetApplication for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetApplication
func (c *CodeDeploy) GetApplication(input *GetApplicationInput) (*GetApplicationOutput, error) {
	req, out := c.GetApplicationRequest(input)
	return out, req.Send()
}

// GetApplicationWithContext is the same as GetApplication with the addition of
// the ability to pass a context and additional request options.
//
// See GetApplication for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) GetApplicationWithContext(ctx aws.Context, input *GetApplicationInput, opts ...request.Option) (*GetApplicationOutput, error) {
	req, out := c.GetApplicationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetApplicationRevision = "GetApplicationRevision"

// GetApplicationRevisionRequest generates a "aws/request.Request" representing the
// client's request for the GetApplicationRevision operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetApplicationRevision for more information on using the GetApplicationRevision
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetApplicationRevisionRequest method.
//    req, resp := client.GetApplicationRevisionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetApplicationRevision
func (c *CodeDeploy) GetApplicationRevisionRequest(input *GetApplicationRevisionInput) (req *request.Request, output *GetApplicationRevisionOutput) {
	op := &request.Operation{
		Name:       opGetApplicationRevision,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetApplicationRevisionInput{}
	}

	output = &GetApplicationRevisionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetApplicationRevision API operation for AWS CodeDeploy.
//
// Gets information about an application revision.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation GetApplicationRevision for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeRevisionDoesNotExistException "RevisionDoesNotExistException"
//   The named revision does not exist with the IAM user or AWS account.
//
//   * ErrCodeRevisionRequiredException "RevisionRequiredException"
//   The revision ID was not specified.
//
//   * ErrCodeInvalidRevisionException "InvalidRevisionException"
//   The revision was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetApplicationRevision
func (c *CodeDeploy) GetApplicationRevision(input *GetApplicationRevisionInput) (*GetApplicationRevisionOutput, error) {
	req, out := c.GetApplicationRevisionRequest(input)
	return out, req.Send()
}

// GetApplicationRevisionWithContext is the same as GetApplicationRevision with the addition of
// the ability to pass a context and additional request options.
//
// See GetApplicationRevision for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) GetApplicationRevisionWithContext(ctx aws.Context, input *GetApplicationRevisionInput, opts ...request.Option) (*GetApplicationRevisionOutput, error) {
	req, out := c.GetApplicationRevisionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetDeployment = "GetDeployment"

// GetDeploymentRequest generates a "aws/request.Request" representing the
// client's request for the GetDeployment operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetDeployment for more information on using the GetDeployment
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetDeploymentRequest method.
//    req, resp := client.GetDeploymentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeployment
func (c *CodeDeploy) GetDeploymentRequest(input *GetDeploymentInput) (req *request.Request, output *GetDeploymentOutput) {
	op := &request.Operation{
		Name:       opGetDeployment,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetDeploymentInput{}
	}

	output = &GetDeploymentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetDeployment API operation for AWS CodeDeploy.
//
// Gets information about a deployment.
//
// The content property of the appSpecContent object in the returned revision
// is always null. Use GetApplicationRevision and the sha256 property of the
// returned appSpecContent object to get the content of the deployment’s AppSpec
// file.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation GetDeployment for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeployment
func (c *CodeDeploy) GetDeployment(input *GetDeploymentInput) (*GetDeploymentOutput, error) {
	req, out := c.GetDeploymentRequest(input)
	return out, req.Send()
}

// GetDeploymentWithContext is the same as GetDeployment with the addition of
// the ability to pass a context and additional request options.
//
// See GetDeployment for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) GetDeploymentWithContext(ctx aws.Context, input *GetDeploymentInput, opts ...request.Option) (*GetDeploymentOutput, error) {
	req, out := c.GetDeploymentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetDeploymentConfig = "GetDeploymentConfig"

// GetDeploymentConfigRequest generates a "aws/request.Request" representing the
// client's request for the GetDeploymentConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetDeploymentConfig for more information on using the GetDeploymentConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetDeploymentConfigRequest method.
//    req, resp := client.GetDeploymentConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeploymentConfig
func (c *CodeDeploy) GetDeploymentConfigRequest(input *GetDeploymentConfigInput) (req *request.Request, output *GetDeploymentConfigOutput) {
	op := &request.Operation{
		Name:       opGetDeploymentConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetDeploymentConfigInput{}
	}

	output = &GetDeploymentConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetDeploymentConfig API operation for AWS CodeDeploy.
//
// Gets information about a deployment configuration.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation GetDeploymentConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidDeploymentConfigNameException "InvalidDeploymentConfigNameException"
//   The deployment configuration name was specified in an invalid format.
//
//   * ErrCodeDeploymentConfigNameRequiredException "DeploymentConfigNameRequiredException"
//   The deployment configuration name was not specified.
//
//   * ErrCodeDeploymentConfigDoesNotExistException "DeploymentConfigDoesNotExistException"
//   The deployment configuration does not exist with the IAM user or AWS account.
//
//   * ErrCodeInvalidComputePlatformException "InvalidComputePlatformException"
//   The computePlatform is invalid. The computePlatform should be Lambda or Server.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeploymentConfig
func (c *CodeDeploy) GetDeploymentConfig(input *GetDeploymentConfigInput) (*GetDeploymentConfigOutput, error) {
	req, out := c.GetDeploymentConfigRequest(input)
	return out, req.Send()
}

// GetDeploymentConfigWithContext is the same as GetDeploymentConfig with the addition of
// the ability to pass a context and additional request options.
//
// See GetDeploymentConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) GetDeploymentConfigWithContext(ctx aws.Context, input *GetDeploymentConfigInput, opts ...request.Option) (*GetDeploymentConfigOutput, error) {
	req, out := c.GetDeploymentConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetDeploymentGroup = "GetDeploymentGroup"

// GetDeploymentGroupRequest generates a "aws/request.Request" representing the
// client's request for the GetDeploymentGroup operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetDeploymentGroup for more information on using the GetDeploymentGroup
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetDeploymentGroupRequest method.
//    req, resp := client.GetDeploymentGroupRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeploymentGroup
func (c *CodeDeploy) GetDeploymentGroupRequest(input *GetDeploymentGroupInput) (req *request.Request, output *GetDeploymentGroupOutput) {
	op := &request.Operation{
		Name:       opGetDeploymentGroup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetDeploymentGroupInput{}
	}

	output = &GetDeploymentGroupOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetDeploymentGroup API operation for AWS CodeDeploy.
//
// Gets information about a deployment group.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation GetDeploymentGroup for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeDeploymentGroupNameRequiredException "DeploymentGroupNameRequiredException"
//   The deployment group name was not specified.
//
//   * ErrCodeInvalidDeploymentGroupNameException "InvalidDeploymentGroupNameException"
//   The deployment group name was specified in an invalid format.
//
//   * ErrCodeDeploymentGroupDoesNotExistException "DeploymentGroupDoesNotExistException"
//   The named deployment group with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentConfigDoesNotExistException "DeploymentConfigDoesNotExistException"
//   The deployment configuration does not exist with the IAM user or AWS account.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeploymentGroup
func (c *CodeDeploy) GetDeploymentGroup(input *GetDeploymentGroupInput) (*GetDeploymentGroupOutput, error) {
	req, out := c.GetDeploymentGroupRequest(input)
	return out, req.Send()
}

// GetDeploymentGroupWithContext is the same as GetDeploymentGroup with the addition of
// the ability to pass a context and additional request options.
//
// See GetDeploymentGroup for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) GetDeploymentGroupWithContext(ctx aws.Context, input *GetDeploymentGroupInput, opts ...request.Option) (*GetDeploymentGroupOutput, error) {
	req, out := c.GetDeploymentGroupRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetDeploymentInstance = "GetDeploymentInstance"

// GetDeploymentInstanceRequest generates a "aws/request.Request" representing the
// client's request for the GetDeploymentInstance operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetDeploymentInstance for more information on using the GetDeploymentInstance
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetDeploymentInstanceRequest method.
//    req, resp := client.GetDeploymentInstanceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeploymentInstance
//
// Deprecated: This operation is deprecated, use GetDeploymentTarget instead.
func (c *CodeDeploy) GetDeploymentInstanceRequest(input *GetDeploymentInstanceInput) (req *request.Request, output *GetDeploymentInstanceOutput) {
	if c.Client.Config.Logger != nil {
		c.Client.Config.Logger.Log("This operation, GetDeploymentInstance, has been deprecated")
	}
	op := &request.Operation{
		Name:       opGetDeploymentInstance,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetDeploymentInstanceInput{}
	}

	output = &GetDeploymentInstanceOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetDeploymentInstance API operation for AWS CodeDeploy.
//
// Gets information about an instance as part of a deployment.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation GetDeploymentInstance for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeInstanceIdRequiredException "InstanceIdRequiredException"
//   The instance ID was not specified.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeInstanceDoesNotExistException "InstanceDoesNotExistException"
//   The specified instance does not exist in the deployment group.
//
//   * ErrCodeInvalidInstanceNameException "InvalidInstanceNameException"
//   The on-premises instance name was specified in an invalid format.
//
//   * ErrCodeInvalidComputePlatformException "InvalidComputePlatformException"
//   The computePlatform is invalid. The computePlatform should be Lambda or Server.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeploymentInstance
//
// Deprecated: This operation is deprecated, use GetDeploymentTarget instead.
func (c *CodeDeploy) GetDeploymentInstance(input *GetDeploymentInstanceInput) (*GetDeploymentInstanceOutput, error) {
	req, out := c.GetDeploymentInstanceRequest(input)
	return out, req.Send()
}

// GetDeploymentInstanceWithContext is the same as GetDeploymentInstance with the addition of
// the ability to pass a context and additional request options.
//
// See GetDeploymentInstance for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
//
// Deprecated: This operation is deprecated, use GetDeploymentTarget instead.
func (c *CodeDeploy) GetDeploymentInstanceWithContext(ctx aws.Context, input *GetDeploymentInstanceInput, opts ...request.Option) (*GetDeploymentInstanceOutput, error) {
	req, out := c.GetDeploymentInstanceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetDeploymentTarget = "GetDeploymentTarget"

// GetDeploymentTargetRequest generates a "aws/request.Request" representing the
// client's request for the GetDeploymentTarget operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetDeploymentTarget for more information on using the GetDeploymentTarget
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetDeploymentTargetRequest method.
//    req, resp := client.GetDeploymentTargetRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeploymentTarget
func (c *CodeDeploy) GetDeploymentTargetRequest(input *GetDeploymentTargetInput) (req *request.Request, output *GetDeploymentTargetOutput) {
	op := &request.Operation{
		Name:       opGetDeploymentTarget,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetDeploymentTargetInput{}
	}

	output = &GetDeploymentTargetOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetDeploymentTarget API operation for AWS CodeDeploy.
//
// Returns information about a deployment target.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation GetDeploymentTarget for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentNotStartedException "DeploymentNotStartedException"
//   The specified deployment has not started.
//
//   * ErrCodeDeploymentTargetIdRequiredException "DeploymentTargetIdRequiredException"
//   A deployment target ID was not provided.
//
//   * ErrCodeInvalidDeploymentTargetIdException "InvalidDeploymentTargetIdException"
//   The target ID provided was not valid.
//
//   * ErrCodeDeploymentTargetDoesNotExistException "DeploymentTargetDoesNotExistException"
//   The provided target ID does not belong to the attempted deployment.
//
//   * ErrCodeInvalidInstanceNameException "InvalidInstanceNameException"
//   The on-premises instance name was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetDeploymentTarget
func (c *CodeDeploy) GetDeploymentTarget(input *GetDeploymentTargetInput) (*GetDeploymentTargetOutput, error) {
	req, out := c.GetDeploymentTargetRequest(input)
	return out, req.Send()
}

// GetDeploymentTargetWithContext is the same as GetDeploymentTarget with the addition of
// the ability to pass a context and additional request options.
//
// See GetDeploymentTarget for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) GetDeploymentTargetWithContext(ctx aws.Context, input *GetDeploymentTargetInput, opts ...request.Option) (*GetDeploymentTargetOutput, error) {
	req, out := c.GetDeploymentTargetRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetOnPremisesInstance = "GetOnPremisesInstance"

// GetOnPremisesInstanceRequest generates a "aws/request.Request" representing the
// client's request for the GetOnPremisesInstance operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetOnPremisesInstance for more information on using the GetOnPremisesInstance
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetOnPremisesInstanceRequest method.
//    req, resp := client.GetOnPremisesInstanceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetOnPremisesInstance
func (c *CodeDeploy) GetOnPremisesInstanceRequest(input *GetOnPremisesInstanceInput) (req *request.Request, output *GetOnPremisesInstanceOutput) {
	op := &request.Operation{
		Name:       opGetOnPremisesInstance,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetOnPremisesInstanceInput{}
	}

	output = &GetOnPremisesInstanceOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetOnPremisesInstance API operation for AWS CodeDeploy.
//
// Gets information about an on-premises instance.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation GetOnPremisesInstance for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInstanceNameRequiredException "InstanceNameRequiredException"
//   An on-premises instance name was not specified.
//
//   * ErrCodeInstanceNotRegisteredException "InstanceNotRegisteredException"
//   The specified on-premises instance is not registered.
//
//   * ErrCodeInvalidInstanceNameException "InvalidInstanceNameException"
//   The on-premises instance name was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/GetOnPremisesInstance
func (c *CodeDeploy) GetOnPremisesInstance(input *GetOnPremisesInstanceInput) (*GetOnPremisesInstanceOutput, error) {
	req, out := c.GetOnPremisesInstanceRequest(input)
	return out, req.Send()
}

// GetOnPremisesInstanceWithContext is the same as GetOnPremisesInstance with the addition of
// the ability to pass a context and additional request options.
//
// See GetOnPremisesInstance for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) GetOnPremisesInstanceWithContext(ctx aws.Context, input *GetOnPremisesInstanceInput, opts ...request.Option) (*GetOnPremisesInstanceOutput, error) {
	req, out := c.GetOnPremisesInstanceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListApplicationRevisions = "ListApplicationRevisions"

// ListApplicationRevisionsRequest generates a "aws/request.Request" representing the
// client's request for the ListApplicationRevisions operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListApplicationRevisions for more information on using the ListApplicationRevisions
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListApplicationRevisionsRequest method.
//    req, resp := client.ListApplicationRevisionsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListApplicationRevisions
func (c *CodeDeploy) ListApplicationRevisionsRequest(input *ListApplicationRevisionsInput) (req *request.Request, output *ListApplicationRevisionsOutput) {
	op := &request.Operation{
		Name:       opListApplicationRevisions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListApplicationRevisionsInput{}
	}

	output = &ListApplicationRevisionsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListApplicationRevisions API operation for AWS CodeDeploy.
//
// Lists information about revisions for an application.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListApplicationRevisions for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeInvalidSortByException "InvalidSortByException"
//   The column name to sort by is either not present or was specified in an invalid
//   format.
//
//   * ErrCodeInvalidSortOrderException "InvalidSortOrderException"
//   The sort order was specified in an invalid format.
//
//   * ErrCodeInvalidBucketNameFilterException "InvalidBucketNameFilterException"
//   The bucket name either doesn't exist or was specified in an invalid format.
//
//   * ErrCodeInvalidKeyPrefixFilterException "InvalidKeyPrefixFilterException"
//   The specified key prefix filter was specified in an invalid format.
//
//   * ErrCodeBucketNameFilterRequiredException "BucketNameFilterRequiredException"
//   A bucket name is required, but was not provided.
//
//   * ErrCodeInvalidDeployedStateFilterException "InvalidDeployedStateFilterException"
//   The deployed state filter was specified in an invalid format.
//
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   The next token was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListApplicationRevisions
func (c *CodeDeploy) ListApplicationRevisions(input *ListApplicationRevisionsInput) (*ListApplicationRevisionsOutput, error) {
	req, out := c.ListApplicationRevisionsRequest(input)
	return out, req.Send()
}

// ListApplicationRevisionsWithContext is the same as ListApplicationRevisions with the addition of
// the ability to pass a context and additional request options.
//
// See ListApplicationRevisions for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListApplicationRevisionsWithContext(ctx aws.Context, input *ListApplicationRevisionsInput, opts ...request.Option) (*ListApplicationRevisionsOutput, error) {
	req, out := c.ListApplicationRevisionsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListApplicationRevisionsPages iterates over the pages of a ListApplicationRevisions operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListApplicationRevisions method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListApplicationRevisions operation.
//    pageNum := 0
//    err := client.ListApplicationRevisionsPages(params,
//        func(page *codedeploy.ListApplicationRevisionsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeDeploy) ListApplicationRevisionsPages(input *ListApplicationRevisionsInput, fn func(*ListApplicationRevisionsOutput, bool) bool) error {
	return c.ListApplicationRevisionsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListApplicationRevisionsPagesWithContext same as ListApplicationRevisionsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListApplicationRevisionsPagesWithContext(ctx aws.Context, input *ListApplicationRevisionsInput, fn func(*ListApplicationRevisionsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListApplicationRevisionsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListApplicationRevisionsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListApplicationRevisionsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListApplications = "ListApplications"

// ListApplicationsRequest generates a "aws/request.Request" representing the
// client's request for the ListApplications operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListApplications for more information on using the ListApplications
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListApplicationsRequest method.
//    req, resp := client.ListApplicationsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListApplications
func (c *CodeDeploy) ListApplicationsRequest(input *ListApplicationsInput) (req *request.Request, output *ListApplicationsOutput) {
	op := &request.Operation{
		Name:       opListApplications,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListApplicationsInput{}
	}

	output = &ListApplicationsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListApplications API operation for AWS CodeDeploy.
//
// Lists the applications registered with the IAM user or AWS account.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListApplications for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   The next token was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListApplications
func (c *CodeDeploy) ListApplications(input *ListApplicationsInput) (*ListApplicationsOutput, error) {
	req, out := c.ListApplicationsRequest(input)
	return out, req.Send()
}

// ListApplicationsWithContext is the same as ListApplications with the addition of
// the ability to pass a context and additional request options.
//
// See ListApplications for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListApplicationsWithContext(ctx aws.Context, input *ListApplicationsInput, opts ...request.Option) (*ListApplicationsOutput, error) {
	req, out := c.ListApplicationsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListApplicationsPages iterates over the pages of a ListApplications operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListApplications method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListApplications operation.
//    pageNum := 0
//    err := client.ListApplicationsPages(params,
//        func(page *codedeploy.ListApplicationsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeDeploy) ListApplicationsPages(input *ListApplicationsInput, fn func(*ListApplicationsOutput, bool) bool) error {
	return c.ListApplicationsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListApplicationsPagesWithContext same as ListApplicationsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListApplicationsPagesWithContext(ctx aws.Context, input *ListApplicationsInput, fn func(*ListApplicationsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListApplicationsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListApplicationsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListApplicationsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListDeploymentConfigs = "ListDeploymentConfigs"

// ListDeploymentConfigsRequest generates a "aws/request.Request" representing the
// client's request for the ListDeploymentConfigs operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListDeploymentConfigs for more information on using the ListDeploymentConfigs
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListDeploymentConfigsRequest method.
//    req, resp := client.ListDeploymentConfigsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeploymentConfigs
func (c *CodeDeploy) ListDeploymentConfigsRequest(input *ListDeploymentConfigsInput) (req *request.Request, output *ListDeploymentConfigsOutput) {
	op := &request.Operation{
		Name:       opListDeploymentConfigs,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListDeploymentConfigsInput{}
	}

	output = &ListDeploymentConfigsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListDeploymentConfigs API operation for AWS CodeDeploy.
//
// Lists the deployment configurations with the IAM user or AWS account.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListDeploymentConfigs for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   The next token was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeploymentConfigs
func (c *CodeDeploy) ListDeploymentConfigs(input *ListDeploymentConfigsInput) (*ListDeploymentConfigsOutput, error) {
	req, out := c.ListDeploymentConfigsRequest(input)
	return out, req.Send()
}

// ListDeploymentConfigsWithContext is the same as ListDeploymentConfigs with the addition of
// the ability to pass a context and additional request options.
//
// See ListDeploymentConfigs for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListDeploymentConfigsWithContext(ctx aws.Context, input *ListDeploymentConfigsInput, opts ...request.Option) (*ListDeploymentConfigsOutput, error) {
	req, out := c.ListDeploymentConfigsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListDeploymentConfigsPages iterates over the pages of a ListDeploymentConfigs operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListDeploymentConfigs method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListDeploymentConfigs operation.
//    pageNum := 0
//    err := client.ListDeploymentConfigsPages(params,
//        func(page *codedeploy.ListDeploymentConfigsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeDeploy) ListDeploymentConfigsPages(input *ListDeploymentConfigsInput, fn func(*ListDeploymentConfigsOutput, bool) bool) error {
	return c.ListDeploymentConfigsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListDeploymentConfigsPagesWithContext same as ListDeploymentConfigsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListDeploymentConfigsPagesWithContext(ctx aws.Context, input *ListDeploymentConfigsInput, fn func(*ListDeploymentConfigsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListDeploymentConfigsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListDeploymentConfigsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListDeploymentConfigsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListDeploymentGroups = "ListDeploymentGroups"

// ListDeploymentGroupsRequest generates a "aws/request.Request" representing the
// client's request for the ListDeploymentGroups operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListDeploymentGroups for more information on using the ListDeploymentGroups
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListDeploymentGroupsRequest method.
//    req, resp := client.ListDeploymentGroupsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeploymentGroups
func (c *CodeDeploy) ListDeploymentGroupsRequest(input *ListDeploymentGroupsInput) (req *request.Request, output *ListDeploymentGroupsOutput) {
	op := &request.Operation{
		Name:       opListDeploymentGroups,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListDeploymentGroupsInput{}
	}

	output = &ListDeploymentGroupsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListDeploymentGroups API operation for AWS CodeDeploy.
//
// Lists the deployment groups for an application registered with the IAM user
// or AWS account.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListDeploymentGroups for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   The next token was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeploymentGroups
func (c *CodeDeploy) ListDeploymentGroups(input *ListDeploymentGroupsInput) (*ListDeploymentGroupsOutput, error) {
	req, out := c.ListDeploymentGroupsRequest(input)
	return out, req.Send()
}

// ListDeploymentGroupsWithContext is the same as ListDeploymentGroups with the addition of
// the ability to pass a context and additional request options.
//
// See ListDeploymentGroups for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListDeploymentGroupsWithContext(ctx aws.Context, input *ListDeploymentGroupsInput, opts ...request.Option) (*ListDeploymentGroupsOutput, error) {
	req, out := c.ListDeploymentGroupsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListDeploymentGroupsPages iterates over the pages of a ListDeploymentGroups operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListDeploymentGroups method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListDeploymentGroups operation.
//    pageNum := 0
//    err := client.ListDeploymentGroupsPages(params,
//        func(page *codedeploy.ListDeploymentGroupsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeDeploy) ListDeploymentGroupsPages(input *ListDeploymentGroupsInput, fn func(*ListDeploymentGroupsOutput, bool) bool) error {
	return c.ListDeploymentGroupsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListDeploymentGroupsPagesWithContext same as ListDeploymentGroupsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListDeploymentGroupsPagesWithContext(ctx aws.Context, input *ListDeploymentGroupsInput, fn func(*ListDeploymentGroupsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListDeploymentGroupsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListDeploymentGroupsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListDeploymentGroupsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListDeploymentInstances = "ListDeploymentInstances"

// ListDeploymentInstancesRequest generates a "aws/request.Request" representing the
// client's request for the ListDeploymentInstances operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListDeploymentInstances for more information on using the ListDeploymentInstances
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListDeploymentInstancesRequest method.
//    req, resp := client.ListDeploymentInstancesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeploymentInstances
//
// Deprecated: This operation is deprecated, use ListDeploymentTargets instead.
func (c *CodeDeploy) ListDeploymentInstancesRequest(input *ListDeploymentInstancesInput) (req *request.Request, output *ListDeploymentInstancesOutput) {
	if c.Client.Config.Logger != nil {
		c.Client.Config.Logger.Log("This operation, ListDeploymentInstances, has been deprecated")
	}
	op := &request.Operation{
		Name:       opListDeploymentInstances,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListDeploymentInstancesInput{}
	}

	output = &ListDeploymentInstancesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListDeploymentInstances API operation for AWS CodeDeploy.
//
//
// The newer BatchGetDeploymentTargets should be used instead because it works
// with all compute types. ListDeploymentInstances throws an exception if it
// is used with a compute platform other than EC2/On-premises or AWS Lambda.
//
// Lists the instance for a deployment associated with the IAM user or AWS account.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListDeploymentInstances for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentNotStartedException "DeploymentNotStartedException"
//   The specified deployment has not started.
//
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   The next token was specified in an invalid format.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeInvalidInstanceStatusException "InvalidInstanceStatusException"
//   The specified instance status does not exist.
//
//   * ErrCodeInvalidInstanceTypeException "InvalidInstanceTypeException"
//   An invalid instance type was specified for instances in a blue/green deployment.
//   Valid values include "Blue" for an original environment and "Green" for a
//   replacement environment.
//
//   * ErrCodeInvalidDeploymentInstanceTypeException "InvalidDeploymentInstanceTypeException"
//   An instance type was specified for an in-place deployment. Instance types
//   are supported for blue/green deployments only.
//
//   * ErrCodeInvalidTargetFilterNameException "InvalidTargetFilterNameException"
//   The target filter name is invalid.
//
//   * ErrCodeInvalidComputePlatformException "InvalidComputePlatformException"
//   The computePlatform is invalid. The computePlatform should be Lambda or Server.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeploymentInstances
//
// Deprecated: This operation is deprecated, use ListDeploymentTargets instead.
func (c *CodeDeploy) ListDeploymentInstances(input *ListDeploymentInstancesInput) (*ListDeploymentInstancesOutput, error) {
	req, out := c.ListDeploymentInstancesRequest(input)
	return out, req.Send()
}

// ListDeploymentInstancesWithContext is the same as ListDeploymentInstances with the addition of
// the ability to pass a context and additional request options.
//
// See ListDeploymentInstances for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
//
// Deprecated: This operation is deprecated, use ListDeploymentTargets instead.
func (c *CodeDeploy) ListDeploymentInstancesWithContext(ctx aws.Context, input *ListDeploymentInstancesInput, opts ...request.Option) (*ListDeploymentInstancesOutput, error) {
	req, out := c.ListDeploymentInstancesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListDeploymentInstancesPages iterates over the pages of a ListDeploymentInstances operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListDeploymentInstances method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListDeploymentInstances operation.
//    pageNum := 0
//    err := client.ListDeploymentInstancesPages(params,
//        func(page *codedeploy.ListDeploymentInstancesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
//
// Deprecated: This operation is deprecated, use ListDeploymentTargets instead.
func (c *CodeDeploy) ListDeploymentInstancesPages(input *ListDeploymentInstancesInput, fn func(*ListDeploymentInstancesOutput, bool) bool) error {
	return c.ListDeploymentInstancesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListDeploymentInstancesPagesWithContext same as ListDeploymentInstancesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
//
// Deprecated: This operation is deprecated, use ListDeploymentTargets instead.
func (c *CodeDeploy) ListDeploymentInstancesPagesWithContext(ctx aws.Context, input *ListDeploymentInstancesInput, fn func(*ListDeploymentInstancesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListDeploymentInstancesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListDeploymentInstancesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListDeploymentInstancesOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListDeploymentTargets = "ListDeploymentTargets"

// ListDeploymentTargetsRequest generates a "aws/request.Request" representing the
// client's request for the ListDeploymentTargets operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListDeploymentTargets for more information on using the ListDeploymentTargets
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListDeploymentTargetsRequest method.
//    req, resp := client.ListDeploymentTargetsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeploymentTargets
func (c *CodeDeploy) ListDeploymentTargetsRequest(input *ListDeploymentTargetsInput) (req *request.Request, output *ListDeploymentTargetsOutput) {
	op := &request.Operation{
		Name:       opListDeploymentTargets,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListDeploymentTargetsInput{}
	}

	output = &ListDeploymentTargetsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListDeploymentTargets API operation for AWS CodeDeploy.
//
// Returns an array of target IDs that are associated a deployment.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListDeploymentTargets for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentNotStartedException "DeploymentNotStartedException"
//   The specified deployment has not started.
//
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   The next token was specified in an invalid format.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeInvalidInstanceStatusException "InvalidInstanceStatusException"
//   The specified instance status does not exist.
//
//   * ErrCodeInvalidInstanceTypeException "InvalidInstanceTypeException"
//   An invalid instance type was specified for instances in a blue/green deployment.
//   Valid values include "Blue" for an original environment and "Green" for a
//   replacement environment.
//
//   * ErrCodeInvalidDeploymentInstanceTypeException "InvalidDeploymentInstanceTypeException"
//   An instance type was specified for an in-place deployment. Instance types
//   are supported for blue/green deployments only.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeploymentTargets
func (c *CodeDeploy) ListDeploymentTargets(input *ListDeploymentTargetsInput) (*ListDeploymentTargetsOutput, error) {
	req, out := c.ListDeploymentTargetsRequest(input)
	return out, req.Send()
}

// ListDeploymentTargetsWithContext is the same as ListDeploymentTargets with the addition of
// the ability to pass a context and additional request options.
//
// See ListDeploymentTargets for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListDeploymentTargetsWithContext(ctx aws.Context, input *ListDeploymentTargetsInput, opts ...request.Option) (*ListDeploymentTargetsOutput, error) {
	req, out := c.ListDeploymentTargetsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListDeployments = "ListDeployments"

// ListDeploymentsRequest generates a "aws/request.Request" representing the
// client's request for the ListDeployments operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListDeployments for more information on using the ListDeployments
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListDeploymentsRequest method.
//    req, resp := client.ListDeploymentsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeployments
func (c *CodeDeploy) ListDeploymentsRequest(input *ListDeploymentsInput) (req *request.Request, output *ListDeploymentsOutput) {
	op := &request.Operation{
		Name:       opListDeployments,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListDeploymentsInput{}
	}

	output = &ListDeploymentsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListDeployments API operation for AWS CodeDeploy.
//
// Lists the deployments in a deployment group for an application registered
// with the IAM user or AWS account.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListDeployments for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeInvalidDeploymentGroupNameException "InvalidDeploymentGroupNameException"
//   The deployment group name was specified in an invalid format.
//
//   * ErrCodeDeploymentGroupDoesNotExistException "DeploymentGroupDoesNotExistException"
//   The named deployment group with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentGroupNameRequiredException "DeploymentGroupNameRequiredException"
//   The deployment group name was not specified.
//
//   * ErrCodeInvalidTimeRangeException "InvalidTimeRangeException"
//   The specified time range was specified in an invalid format.
//
//   * ErrCodeInvalidDeploymentStatusException "InvalidDeploymentStatusException"
//   The specified deployment status doesn't exist or cannot be determined.
//
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   The next token was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListDeployments
func (c *CodeDeploy) ListDeployments(input *ListDeploymentsInput) (*ListDeploymentsOutput, error) {
	req, out := c.ListDeploymentsRequest(input)
	return out, req.Send()
}

// ListDeploymentsWithContext is the same as ListDeployments with the addition of
// the ability to pass a context and additional request options.
//
// See ListDeployments for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListDeploymentsWithContext(ctx aws.Context, input *ListDeploymentsInput, opts ...request.Option) (*ListDeploymentsOutput, error) {
	req, out := c.ListDeploymentsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListDeploymentsPages iterates over the pages of a ListDeployments operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListDeployments method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListDeployments operation.
//    pageNum := 0
//    err := client.ListDeploymentsPages(params,
//        func(page *codedeploy.ListDeploymentsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeDeploy) ListDeploymentsPages(input *ListDeploymentsInput, fn func(*ListDeploymentsOutput, bool) bool) error {
	return c.ListDeploymentsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListDeploymentsPagesWithContext same as ListDeploymentsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListDeploymentsPagesWithContext(ctx aws.Context, input *ListDeploymentsInput, fn func(*ListDeploymentsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListDeploymentsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListDeploymentsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListDeploymentsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListGitHubAccountTokenNames = "ListGitHubAccountTokenNames"

// ListGitHubAccountTokenNamesRequest generates a "aws/request.Request" representing the
// client's request for the ListGitHubAccountTokenNames operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListGitHubAccountTokenNames for more information on using the ListGitHubAccountTokenNames
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListGitHubAccountTokenNamesRequest method.
//    req, resp := client.ListGitHubAccountTokenNamesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListGitHubAccountTokenNames
func (c *CodeDeploy) ListGitHubAccountTokenNamesRequest(input *ListGitHubAccountTokenNamesInput) (req *request.Request, output *ListGitHubAccountTokenNamesOutput) {
	op := &request.Operation{
		Name:       opListGitHubAccountTokenNames,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListGitHubAccountTokenNamesInput{}
	}

	output = &ListGitHubAccountTokenNamesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListGitHubAccountTokenNames API operation for AWS CodeDeploy.
//
// Lists the names of stored connections to GitHub accounts.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListGitHubAccountTokenNames for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   The next token was specified in an invalid format.
//
//   * ErrCodeResourceValidationException "ResourceValidationException"
//   The specified resource could not be validated.
//
//   * ErrCodeOperationNotSupportedException "OperationNotSupportedException"
//   The API used does not support the deployment.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListGitHubAccountTokenNames
func (c *CodeDeploy) ListGitHubAccountTokenNames(input *ListGitHubAccountTokenNamesInput) (*ListGitHubAccountTokenNamesOutput, error) {
	req, out := c.ListGitHubAccountTokenNamesRequest(input)
	return out, req.Send()
}

// ListGitHubAccountTokenNamesWithContext is the same as ListGitHubAccountTokenNames with the addition of
// the ability to pass a context and additional request options.
//
// See ListGitHubAccountTokenNames for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListGitHubAccountTokenNamesWithContext(ctx aws.Context, input *ListGitHubAccountTokenNamesInput, opts ...request.Option) (*ListGitHubAccountTokenNamesOutput, error) {
	req, out := c.ListGitHubAccountTokenNamesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListOnPremisesInstances = "ListOnPremisesInstances"

// ListOnPremisesInstancesRequest generates a "aws/request.Request" representing the
// client's request for the ListOnPremisesInstances operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListOnPremisesInstances for more information on using the ListOnPremisesInstances
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListOnPremisesInstancesRequest method.
//    req, resp := client.ListOnPremisesInstancesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListOnPremisesInstances
func (c *CodeDeploy) ListOnPremisesInstancesRequest(input *ListOnPremisesInstancesInput) (req *request.Request, output *ListOnPremisesInstancesOutput) {
	op := &request.Operation{
		Name:       opListOnPremisesInstances,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListOnPremisesInstancesInput{}
	}

	output = &ListOnPremisesInstancesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListOnPremisesInstances API operation for AWS CodeDeploy.
//
// Gets a list of names for one or more on-premises instances.
//
// Unless otherwise specified, both registered and deregistered on-premises
// instance names are listed. To list only registered or deregistered on-premises
// instance names, use the registration status parameter.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListOnPremisesInstances for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidRegistrationStatusException "InvalidRegistrationStatusException"
//   The registration status was specified in an invalid format.
//
//   * ErrCodeInvalidTagFilterException "InvalidTagFilterException"
//   The tag filter was specified in an invalid format.
//
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   The next token was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListOnPremisesInstances
func (c *CodeDeploy) ListOnPremisesInstances(input *ListOnPremisesInstancesInput) (*ListOnPremisesInstancesOutput, error) {
	req, out := c.ListOnPremisesInstancesRequest(input)
	return out, req.Send()
}

// ListOnPremisesInstancesWithContext is the same as ListOnPremisesInstances with the addition of
// the ability to pass a context and additional request options.
//
// See ListOnPremisesInstances for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListOnPremisesInstancesWithContext(ctx aws.Context, input *ListOnPremisesInstancesInput, opts ...request.Option) (*ListOnPremisesInstancesOutput, error) {
	req, out := c.ListOnPremisesInstancesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListTagsForResource = "ListTagsForResource"

// ListTagsForResourceRequest generates a "aws/request.Request" representing the
// client's request for the ListTagsForResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListTagsForResource for more information on using the ListTagsForResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListTagsForResourceRequest method.
//    req, resp := client.ListTagsForResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListTagsForResource
func (c *CodeDeploy) ListTagsForResourceRequest(input *ListTagsForResourceInput) (req *request.Request, output *ListTagsForResourceOutput) {
	op := &request.Operation{
		Name:       opListTagsForResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListTagsForResourceInput{}
	}

	output = &ListTagsForResourceOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListTagsForResource API operation for AWS CodeDeploy.
//
// Returns a list of tags for the resource identified by a specified ARN. Tags
// are used to organize and categorize your CodeDeploy resources.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation ListTagsForResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeArnNotSupportedException "ArnNotSupportedException"
//   The specified ARN is not supported. For example, it might be an ARN for a
//   resource that is not expected.
//
//   * ErrCodeInvalidArnException "InvalidArnException"
//   The specified ARN is not in a valid format.
//
//   * ErrCodeResourceArnRequiredException "ResourceArnRequiredException"
//   The ARN of a resource is required, but was not found.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/ListTagsForResource
func (c *CodeDeploy) ListTagsForResource(input *ListTagsForResourceInput) (*ListTagsForResourceOutput, error) {
	req, out := c.ListTagsForResourceRequest(input)
	return out, req.Send()
}

// ListTagsForResourceWithContext is the same as ListTagsForResource with the addition of
// the ability to pass a context and additional request options.
//
// See ListTagsForResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) ListTagsForResourceWithContext(ctx aws.Context, input *ListTagsForResourceInput, opts ...request.Option) (*ListTagsForResourceOutput, error) {
	req, out := c.ListTagsForResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opPutLifecycleEventHookExecutionStatus = "PutLifecycleEventHookExecutionStatus"

// PutLifecycleEventHookExecutionStatusRequest generates a "aws/request.Request" representing the
// client's request for the PutLifecycleEventHookExecutionStatus operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See PutLifecycleEventHookExecutionStatus for more information on using the PutLifecycleEventHookExecutionStatus
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the PutLifecycleEventHookExecutionStatusRequest method.
//    req, resp := client.PutLifecycleEventHookExecutionStatusRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/PutLifecycleEventHookExecutionStatus
func (c *CodeDeploy) PutLifecycleEventHookExecutionStatusRequest(input *PutLifecycleEventHookExecutionStatusInput) (req *request.Request, output *PutLifecycleEventHookExecutionStatusOutput) {
	op := &request.Operation{
		Name:       opPutLifecycleEventHookExecutionStatus,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PutLifecycleEventHookExecutionStatusInput{}
	}

	output = &PutLifecycleEventHookExecutionStatusOutput{}
	req = c.newRequest(op, input, output)
	return
}

// PutLifecycleEventHookExecutionStatus API operation for AWS CodeDeploy.
//
// Sets the result of a Lambda validation function. The function validates one
// or both lifecycle events (BeforeAllowTraffic and AfterAllowTraffic) and returns
// Succeeded or Failed.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation PutLifecycleEventHookExecutionStatus for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidLifecycleEventHookExecutionStatusException "InvalidLifecycleEventHookExecutionStatusException"
//   The result of a Lambda validation function that verifies a lifecycle event
//   is invalid. It should return Succeeded or Failed.
//
//   * ErrCodeInvalidLifecycleEventHookExecutionIdException "InvalidLifecycleEventHookExecutionIdException"
//   A lifecycle event hook is invalid. Review the hooks section in your AppSpec
//   file to ensure the lifecycle events and hooks functions are valid.
//
//   * ErrCodeLifecycleEventAlreadyCompletedException "LifecycleEventAlreadyCompletedException"
//   An attempt to return the status of an already completed lifecycle event occurred.
//
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeUnsupportedActionForDeploymentTypeException "UnsupportedActionForDeploymentTypeException"
//   A call was submitted that is not supported for the specified deployment type.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/PutLifecycleEventHookExecutionStatus
func (c *CodeDeploy) PutLifecycleEventHookExecutionStatus(input *PutLifecycleEventHookExecutionStatusInput) (*PutLifecycleEventHookExecutionStatusOutput, error) {
	req, out := c.PutLifecycleEventHookExecutionStatusRequest(input)
	return out, req.Send()
}

// PutLifecycleEventHookExecutionStatusWithContext is the same as PutLifecycleEventHookExecutionStatus with the addition of
// the ability to pass a context and additional request options.
//
// See PutLifecycleEventHookExecutionStatus for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) PutLifecycleEventHookExecutionStatusWithContext(ctx aws.Context, input *PutLifecycleEventHookExecutionStatusInput, opts ...request.Option) (*PutLifecycleEventHookExecutionStatusOutput, error) {
	req, out := c.PutLifecycleEventHookExecutionStatusRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opRegisterApplicationRevision = "RegisterApplicationRevision"

// RegisterApplicationRevisionRequest generates a "aws/request.Request" representing the
// client's request for the RegisterApplicationRevision operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See RegisterApplicationRevision for more information on using the RegisterApplicationRevision
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the RegisterApplicationRevisionRequest method.
//    req, resp := client.RegisterApplicationRevisionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/RegisterApplicationRevision
func (c *CodeDeploy) RegisterApplicationRevisionRequest(input *RegisterApplicationRevisionInput) (req *request.Request, output *RegisterApplicationRevisionOutput) {
	op := &request.Operation{
		Name:       opRegisterApplicationRevision,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &RegisterApplicationRevisionInput{}
	}

	output = &RegisterApplicationRevisionOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// RegisterApplicationRevision API operation for AWS CodeDeploy.
//
// Registers with AWS CodeDeploy a revision for the specified application.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation RegisterApplicationRevision for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeDescriptionTooLongException "DescriptionTooLongException"
//   The description is too long.
//
//   * ErrCodeRevisionRequiredException "RevisionRequiredException"
//   The revision ID was not specified.
//
//   * ErrCodeInvalidRevisionException "InvalidRevisionException"
//   The revision was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/RegisterApplicationRevision
func (c *CodeDeploy) RegisterApplicationRevision(input *RegisterApplicationRevisionInput) (*RegisterApplicationRevisionOutput, error) {
	req, out := c.RegisterApplicationRevisionRequest(input)
	return out, req.Send()
}

// RegisterApplicationRevisionWithContext is the same as RegisterApplicationRevision with the addition of
// the ability to pass a context and additional request options.
//
// See RegisterApplicationRevision for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) RegisterApplicationRevisionWithContext(ctx aws.Context, input *RegisterApplicationRevisionInput, opts ...request.Option) (*RegisterApplicationRevisionOutput, error) {
	req, out := c.RegisterApplicationRevisionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opRegisterOnPremisesInstance = "RegisterOnPremisesInstance"

// RegisterOnPremisesInstanceRequest generates a "aws/request.Request" representing the
// client's request for the RegisterOnPremisesInstance operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See RegisterOnPremisesInstance for more information on using the RegisterOnPremisesInstance
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the RegisterOnPremisesInstanceRequest method.
//    req, resp := client.RegisterOnPremisesInstanceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/RegisterOnPremisesInstance
func (c *CodeDeploy) RegisterOnPremisesInstanceRequest(input *RegisterOnPremisesInstanceInput) (req *request.Request, output *RegisterOnPremisesInstanceOutput) {
	op := &request.Operation{
		Name:       opRegisterOnPremisesInstance,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &RegisterOnPremisesInstanceInput{}
	}

	output = &RegisterOnPremisesInstanceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// RegisterOnPremisesInstance API operation for AWS CodeDeploy.
//
// Registers an on-premises instance.
//
// Only one IAM ARN (an IAM session ARN or IAM user ARN) is supported in the
// request. You cannot use both.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation RegisterOnPremisesInstance for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInstanceNameAlreadyRegisteredException "InstanceNameAlreadyRegisteredException"
//   The specified on-premises instance name is already registered.
//
//   * ErrCodeIamArnRequiredException "IamArnRequiredException"
//   No IAM ARN was included in the request. You must use an IAM session ARN or
//   IAM user ARN in the request.
//
//   * ErrCodeIamSessionArnAlreadyRegisteredException "IamSessionArnAlreadyRegisteredException"
//   The request included an IAM session ARN that has already been used to register
//   a different instance.
//
//   * ErrCodeIamUserArnAlreadyRegisteredException "IamUserArnAlreadyRegisteredException"
//   The specified IAM user ARN is already registered with an on-premises instance.
//
//   * ErrCodeInstanceNameRequiredException "InstanceNameRequiredException"
//   An on-premises instance name was not specified.
//
//   * ErrCodeIamUserArnRequiredException "IamUserArnRequiredException"
//   An IAM user ARN was not specified.
//
//   * ErrCodeInvalidInstanceNameException "InvalidInstanceNameException"
//   The on-premises instance name was specified in an invalid format.
//
//   * ErrCodeInvalidIamSessionArnException "InvalidIamSessionArnException"
//   The IAM session ARN was specified in an invalid format.
//
//   * ErrCodeInvalidIamUserArnException "InvalidIamUserArnException"
//   The IAM user ARN was specified in an invalid format.
//
//   * ErrCodeMultipleIamArnsProvidedException "MultipleIamArnsProvidedException"
//   Both an IAM user ARN and an IAM session ARN were included in the request.
//   Use only one ARN type.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/RegisterOnPremisesInstance
func (c *CodeDeploy) RegisterOnPremisesInstance(input *RegisterOnPremisesInstanceInput) (*RegisterOnPremisesInstanceOutput, error) {
	req, out := c.RegisterOnPremisesInstanceRequest(input)
	return out, req.Send()
}

// RegisterOnPremisesInstanceWithContext is the same as RegisterOnPremisesInstance with the addition of
// the ability to pass a context and additional request options.
//
// See RegisterOnPremisesInstance for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) RegisterOnPremisesInstanceWithContext(ctx aws.Context, input *RegisterOnPremisesInstanceInput, opts ...request.Option) (*RegisterOnPremisesInstanceOutput, error) {
	req, out := c.RegisterOnPremisesInstanceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opRemoveTagsFromOnPremisesInstances = "RemoveTagsFromOnPremisesInstances"

// RemoveTagsFromOnPremisesInstancesRequest generates a "aws/request.Request" representing the
// client's request for the RemoveTagsFromOnPremisesInstances operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See RemoveTagsFromOnPremisesInstances for more information on using the RemoveTagsFromOnPremisesInstances
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the RemoveTagsFromOnPremisesInstancesRequest method.
//    req, resp := client.RemoveTagsFromOnPremisesInstancesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/RemoveTagsFromOnPremisesInstances
func (c *CodeDeploy) RemoveTagsFromOnPremisesInstancesRequest(input *RemoveTagsFromOnPremisesInstancesInput) (req *request.Request, output *RemoveTagsFromOnPremisesInstancesOutput) {
	op := &request.Operation{
		Name:       opRemoveTagsFromOnPremisesInstances,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &RemoveTagsFromOnPremisesInstancesInput{}
	}

	output = &RemoveTagsFromOnPremisesInstancesOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// RemoveTagsFromOnPremisesInstances API operation for AWS CodeDeploy.
//
// Removes one or more tags from one or more on-premises instances.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation RemoveTagsFromOnPremisesInstances for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInstanceNameRequiredException "InstanceNameRequiredException"
//   An on-premises instance name was not specified.
//
//   * ErrCodeInvalidInstanceNameException "InvalidInstanceNameException"
//   The on-premises instance name was specified in an invalid format.
//
//   * ErrCodeTagRequiredException "TagRequiredException"
//   A tag was not specified.
//
//   * ErrCodeInvalidTagException "InvalidTagException"
//   The tag was specified in an invalid format.
//
//   * ErrCodeTagLimitExceededException "TagLimitExceededException"
//   The maximum allowed number of tags was exceeded.
//
//   * ErrCodeInstanceLimitExceededException "InstanceLimitExceededException"
//   The maximum number of allowed on-premises instances in a single call was
//   exceeded.
//
//   * ErrCodeInstanceNotRegisteredException "InstanceNotRegisteredException"
//   The specified on-premises instance is not registered.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/RemoveTagsFromOnPremisesInstances
func (c *CodeDeploy) RemoveTagsFromOnPremisesInstances(input *RemoveTagsFromOnPremisesInstancesInput) (*RemoveTagsFromOnPremisesInstancesOutput, error) {
	req, out := c.RemoveTagsFromOnPremisesInstancesRequest(input)
	return out, req.Send()
}

// RemoveTagsFromOnPremisesInstancesWithContext is the same as RemoveTagsFromOnPremisesInstances with the addition of
// the ability to pass a context and additional request options.
//
// See RemoveTagsFromOnPremisesInstances for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) RemoveTagsFromOnPremisesInstancesWithContext(ctx aws.Context, input *RemoveTagsFromOnPremisesInstancesInput, opts ...request.Option) (*RemoveTagsFromOnPremisesInstancesOutput, error) {
	req, out := c.RemoveTagsFromOnPremisesInstancesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opSkipWaitTimeForInstanceTermination = "SkipWaitTimeForInstanceTermination"

// SkipWaitTimeForInstanceTerminationRequest generates a "aws/request.Request" representing the
// client's request for the SkipWaitTimeForInstanceTermination operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See SkipWaitTimeForInstanceTermination for more information on using the SkipWaitTimeForInstanceTermination
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the SkipWaitTimeForInstanceTerminationRequest method.
//    req, resp := client.SkipWaitTimeForInstanceTerminationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/SkipWaitTimeForInstanceTermination
//
// Deprecated: This operation is deprecated, use ContinueDeployment with DeploymentWaitType instead.
func (c *CodeDeploy) SkipWaitTimeForInstanceTerminationRequest(input *SkipWaitTimeForInstanceTerminationInput) (req *request.Request, output *SkipWaitTimeForInstanceTerminationOutput) {
	if c.Client.Config.Logger != nil {
		c.Client.Config.Logger.Log("This operation, SkipWaitTimeForInstanceTermination, has been deprecated")
	}
	op := &request.Operation{
		Name:       opSkipWaitTimeForInstanceTermination,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &SkipWaitTimeForInstanceTerminationInput{}
	}

	output = &SkipWaitTimeForInstanceTerminationOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// SkipWaitTimeForInstanceTermination API operation for AWS CodeDeploy.
//
// In a blue/green deployment, overrides any specified wait time and starts
// terminating instances immediately after the traffic routing is complete.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation SkipWaitTimeForInstanceTermination for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentAlreadyCompletedException "DeploymentAlreadyCompletedException"
//   The deployment is already complete.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
//   * ErrCodeDeploymentNotStartedException "DeploymentNotStartedException"
//   The specified deployment has not started.
//
//   * ErrCodeUnsupportedActionForDeploymentTypeException "UnsupportedActionForDeploymentTypeException"
//   A call was submitted that is not supported for the specified deployment type.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/SkipWaitTimeForInstanceTermination
//
// Deprecated: This operation is deprecated, use ContinueDeployment with DeploymentWaitType instead.
func (c *CodeDeploy) SkipWaitTimeForInstanceTermination(input *SkipWaitTimeForInstanceTerminationInput) (*SkipWaitTimeForInstanceTerminationOutput, error) {
	req, out := c.SkipWaitTimeForInstanceTerminationRequest(input)
	return out, req.Send()
}

// SkipWaitTimeForInstanceTerminationWithContext is the same as SkipWaitTimeForInstanceTermination with the addition of
// the ability to pass a context and additional request options.
//
// See SkipWaitTimeForInstanceTermination for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
//
// Deprecated: This operation is deprecated, use ContinueDeployment with DeploymentWaitType instead.
func (c *CodeDeploy) SkipWaitTimeForInstanceTerminationWithContext(ctx aws.Context, input *SkipWaitTimeForInstanceTerminationInput, opts ...request.Option) (*SkipWaitTimeForInstanceTerminationOutput, error) {
	req, out := c.SkipWaitTimeForInstanceTerminationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opStopDeployment = "StopDeployment"

// StopDeploymentRequest generates a "aws/request.Request" representing the
// client's request for the StopDeployment operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See StopDeployment for more information on using the StopDeployment
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the StopDeploymentRequest method.
//    req, resp := client.StopDeploymentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/StopDeployment
func (c *CodeDeploy) StopDeploymentRequest(input *StopDeploymentInput) (req *request.Request, output *StopDeploymentOutput) {
	op := &request.Operation{
		Name:       opStopDeployment,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &StopDeploymentInput{}
	}

	output = &StopDeploymentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// StopDeployment API operation for AWS CodeDeploy.
//
// Attempts to stop an ongoing deployment.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation StopDeployment for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeDeploymentIdRequiredException "DeploymentIdRequiredException"
//   At least one deployment ID must be specified.
//
//   * ErrCodeDeploymentDoesNotExistException "DeploymentDoesNotExistException"
//   The deployment with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentGroupDoesNotExistException "DeploymentGroupDoesNotExistException"
//   The named deployment group with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentAlreadyCompletedException "DeploymentAlreadyCompletedException"
//   The deployment is already complete.
//
//   * ErrCodeInvalidDeploymentIdException "InvalidDeploymentIdException"
//   At least one of the deployment IDs was specified in an invalid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/StopDeployment
func (c *CodeDeploy) StopDeployment(input *StopDeploymentInput) (*StopDeploymentOutput, error) {
	req, out := c.StopDeploymentRequest(input)
	return out, req.Send()
}

// StopDeploymentWithContext is the same as StopDeployment with the addition of
// the ability to pass a context and additional request options.
//
// See StopDeployment for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) StopDeploymentWithContext(ctx aws.Context, input *StopDeploymentInput, opts ...request.Option) (*StopDeploymentOutput, error) {
	req, out := c.StopDeploymentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opTagResource = "TagResource"

// TagResourceRequest generates a "aws/request.Request" representing the
// client's request for the TagResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See TagResource for more information on using the TagResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the TagResourceRequest method.
//    req, resp := client.TagResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/TagResource
func (c *CodeDeploy) TagResourceRequest(input *TagResourceInput) (req *request.Request, output *TagResourceOutput) {
	op := &request.Operation{
		Name:       opTagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &TagResourceInput{}
	}

	output = &TagResourceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// TagResource API operation for AWS CodeDeploy.
//
// Associates the list of tags in the input Tags parameter with the resource
// identified by the ResourceArn input parameter.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation TagResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceArnRequiredException "ResourceArnRequiredException"
//   The ARN of a resource is required, but was not found.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeDeploymentGroupDoesNotExistException "DeploymentGroupDoesNotExistException"
//   The named deployment group with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentConfigDoesNotExistException "DeploymentConfigDoesNotExistException"
//   The deployment configuration does not exist with the IAM user or AWS account.
//
//   * ErrCodeTagRequiredException "TagRequiredException"
//   A tag was not specified.
//
//   * ErrCodeInvalidTagsToAddException "InvalidTagsToAddException"
//   The specified tags are not valid.
//
//   * ErrCodeArnNotSupportedException "ArnNotSupportedException"
//   The specified ARN is not supported. For example, it might be an ARN for a
//   resource that is not expected.
//
//   * ErrCodeInvalidArnException "InvalidArnException"
//   The specified ARN is not in a valid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/TagResource
func (c *CodeDeploy) TagResource(input *TagResourceInput) (*TagResourceOutput, error) {
	req, out := c.TagResourceRequest(input)
	return out, req.Send()
}

// TagResourceWithContext is the same as TagResource with the addition of
// the ability to pass a context and additional request options.
//
// See TagResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) TagResourceWithContext(ctx aws.Context, input *TagResourceInput, opts ...request.Option) (*TagResourceOutput, error) {
	req, out := c.TagResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUntagResource = "UntagResource"

// UntagResourceRequest generates a "aws/request.Request" representing the
// client's request for the UntagResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UntagResource for more information on using the UntagResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UntagResourceRequest method.
//    req, resp := client.UntagResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/UntagResource
func (c *CodeDeploy) UntagResourceRequest(input *UntagResourceInput) (req *request.Request, output *UntagResourceOutput) {
	op := &request.Operation{
		Name:       opUntagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UntagResourceInput{}
	}

	output = &UntagResourceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// UntagResource API operation for AWS CodeDeploy.
//
// Disassociates a resource from a list of tags. The resource is identified
// by the ResourceArn input parameter. The tags are identfied by the list of
// keys in the TagKeys input parameter.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation UntagResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceArnRequiredException "ResourceArnRequiredException"
//   The ARN of a resource is required, but was not found.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeDeploymentGroupDoesNotExistException "DeploymentGroupDoesNotExistException"
//   The named deployment group with the IAM user or AWS account does not exist.
//
//   * ErrCodeDeploymentConfigDoesNotExistException "DeploymentConfigDoesNotExistException"
//   The deployment configuration does not exist with the IAM user or AWS account.
//
//   * ErrCodeTagRequiredException "TagRequiredException"
//   A tag was not specified.
//
//   * ErrCodeInvalidTagsToAddException "InvalidTagsToAddException"
//   The specified tags are not valid.
//
//   * ErrCodeArnNotSupportedException "ArnNotSupportedException"
//   The specified ARN is not supported. For example, it might be an ARN for a
//   resource that is not expected.
//
//   * ErrCodeInvalidArnException "InvalidArnException"
//   The specified ARN is not in a valid format.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/UntagResource
func (c *CodeDeploy) UntagResource(input *UntagResourceInput) (*UntagResourceOutput, error) {
	req, out := c.UntagResourceRequest(input)
	return out, req.Send()
}

// UntagResourceWithContext is the same as UntagResource with the addition of
// the ability to pass a context and additional request options.
//
// See UntagResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) UntagResourceWithContext(ctx aws.Context, input *UntagResourceInput, opts ...request.Option) (*UntagResourceOutput, error) {
	req, out := c.UntagResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateApplication = "UpdateApplication"

// UpdateApplicationRequest generates a "aws/request.Request" representing the
// client's request for the UpdateApplication operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateApplication for more information on using the UpdateApplication
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateApplicationRequest method.
//    req, resp := client.UpdateApplicationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/UpdateApplication
func (c *CodeDeploy) UpdateApplicationRequest(input *UpdateApplicationInput) (req *request.Request, output *UpdateApplicationOutput) {
	op := &request.Operation{
		Name:       opUpdateApplication,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateApplicationInput{}
	}

	output = &UpdateApplicationOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// UpdateApplication API operation for AWS CodeDeploy.
//
// Changes the name of an application.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation UpdateApplication for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationAlreadyExistsException "ApplicationAlreadyExistsException"
//   An application with the specified name with the IAM user or AWS account already
//   exists.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/UpdateApplication
func (c *CodeDeploy) UpdateApplication(input *UpdateApplicationInput) (*UpdateApplicationOutput, error) {
	req, out := c.UpdateApplicationRequest(input)
	return out, req.Send()
}

// UpdateApplicationWithContext is the same as UpdateApplication with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateApplication for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) UpdateApplicationWithContext(ctx aws.Context, input *UpdateApplicationInput, opts ...request.Option) (*UpdateApplicationOutput, error) {
	req, out := c.UpdateApplicationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateDeploymentGroup = "UpdateDeploymentGroup"

// UpdateDeploymentGroupRequest generates a "aws/request.Request" representing the
// client's request for the UpdateDeploymentGroup operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateDeploymentGroup for more information on using the UpdateDeploymentGroup
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateDeploymentGroupRequest method.
//    req, resp := client.UpdateDeploymentGroupRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/UpdateDeploymentGroup
func (c *CodeDeploy) UpdateDeploymentGroupRequest(input *UpdateDeploymentGroupInput) (req *request.Request, output *UpdateDeploymentGroupOutput) {
	op := &request.Operation{
		Name:       opUpdateDeploymentGroup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateDeploymentGroupInput{}
	}

	output = &UpdateDeploymentGroupOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateDeploymentGroup API operation for AWS CodeDeploy.
//
// Changes information about a deployment group.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeDeploy's
// API operation UpdateDeploymentGroup for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeApplicationNameRequiredException "ApplicationNameRequiredException"
//   The minimum number of required application names was not specified.
//
//   * ErrCodeInvalidApplicationNameException "InvalidApplicationNameException"
//   The application name was specified in an invalid format.
//
//   * ErrCodeApplicationDoesNotExistException "ApplicationDoesNotExistException"
//   The application does not exist with the IAM user or AWS account.
//
//   * ErrCodeInvalidDeploymentGroupNameException "InvalidDeploymentGroupNameException"
//   The deployment group name was specified in an invalid format.
//
//   * ErrCodeDeploymentGroupAlreadyExistsException "DeploymentGroupAlreadyExistsException"
//   A deployment group with the specified name with the IAM user or AWS account
//   already exists.
//
//   * ErrCodeDeploymentGroupNameRequiredException "DeploymentGroupNameRequiredException"
//   The deployment group name was not specified.
//
//   * ErrCodeDeploymentGroupDoesNotExistException "DeploymentGroupDoesNotExistException"
//   The named deployment group with the IAM user or AWS account does not exist.
//
//   * ErrCodeInvalidEC2TagException "InvalidEC2TagException"
//   The tag was specified in an invalid format.
//
//   * ErrCodeInvalidTagException "InvalidTagException"
//   The tag was specified in an invalid format.
//
//   * ErrCodeInvalidAutoScalingGroupException "InvalidAutoScalingGroupException"
//   The Auto Scaling group was specified in an invalid format or does not exist.
//
//   * ErrCodeInvalidDeploymentConfigNameException "InvalidDeploymentConfigNameException"
//   The deployment configuration name was specified in an invalid format.
//
//   * ErrCodeDeploymentConfigDoesNotExistException "DeploymentConfigDoesNotExistException"
//   The deployment configuration does not exist with the IAM user or AWS account.
//
//   * ErrCodeInvalidRoleException "InvalidRoleException"
//   The service role ARN was specified in an invalid format. Or, if an Auto Scaling
//   group was specified, the specified service role does not grant the appropriate
//   permissions to Amazon EC2 Auto Scaling.
//
//   * ErrCodeLifecycleHookLimitExceededException "LifecycleHookLimitExceededException"
//   The limit for lifecycle hooks was exceeded.
//
//   * ErrCodeInvalidTriggerConfigException "InvalidTriggerConfigException"
//   The trigger was specified in an invalid format.
//
//   * ErrCodeTriggerTargetsLimitExceededException "TriggerTargetsLimitExceededException"
//   The maximum allowed number of triggers was exceeded.
//
//   * ErrCodeInvalidAlarmConfigException "InvalidAlarmConfigException"
//   The format of the alarm configuration is invalid. Possible causes include:
//
//      * The alarm list is null.
//
//      * The alarm object is null.
//
//      * The alarm name is empty or null or exceeds the limit of 255 characters.
//
//      * Two alarms with the same name have been specified.
//
//      * The alarm configuration is enabled, but the alarm list is empty.
//
//   * ErrCodeAlarmsLimitExceededException "AlarmsLimitExceededException"
//   The maximum number of alarms for a deployment group (10) was exceeded.
//
//   * ErrCodeInvalidAutoRollbackConfigException "InvalidAutoRollbackConfigException"
//   The automatic rollback configuration was specified in an invalid format.
//   For example, automatic rollback is enabled, but an invalid triggering event
//   type or no event types were listed.
//
//   * ErrCodeInvalidLoadBalancerInfoException "InvalidLoadBalancerInfoException"
//   An invalid load balancer name, or no load balancer name, was specified.
//
//   * ErrCodeInvalidDeploymentStyleException "InvalidDeploymentStyleException"
//   An invalid deployment style was specified. Valid deployment types include
//   "IN_PLACE" and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL"
//   and "WITHOUT_TRAFFIC_CONTROL."
//
//   * ErrCodeInvalidBlueGreenDeploymentConfigurationException "InvalidBlueGreenDeploymentConfigurationException"
//   The configuration for the blue/green deployment group was provided in an
//   invalid format. For information about deployment configuration format, see
//   CreateDeploymentConfig.
//
//   * ErrCodeInvalidEC2TagCombinationException "InvalidEC2TagCombinationException"
//   A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but
//   only one of these data types can be used in a single call.
//
//   * ErrCodeInvalidOnPremisesTagCombinationException "InvalidOnPremisesTagCombinationException"
//   A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet,
//   but only one of these data types can be used in a single call.
//
//   * ErrCodeTagSetListLimitExceededException "TagSetListLimitExceededException"
//   The number of tag groups included in the tag set list exceeded the maximum
//   allowed limit of 3.
//
//   * ErrCodeInvalidInputException "InvalidInputException"
//   The input was specified in an invalid format.
//
//   * ErrCodeThrottlingException "ThrottlingException"
//   An API function was called too frequently.
//
//   * ErrCodeInvalidECSServiceException "InvalidECSServiceException"
//   The Amazon ECS service identifier is not valid.
//
//   * ErrCodeInvalidTargetGroupPairException "InvalidTargetGroupPairException"
//   A target group pair associated with this deployment is not valid.
//
//   * ErrCodeECSServiceMappingLimitExceededException "ECSServiceMappingLimitExceededException"
//   The Amazon ECS service is associated with more than one deployment groups.
//   An Amazon ECS service can be associated with only one deployment group.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codedeploy-2014-10-06/UpdateDeploymentGroup
func (c *CodeDeploy) UpdateDeploymentGroup(input *UpdateDeploymentGroupInput) (*UpdateDeploymentGroupOutput, error) {
	req, out := c.UpdateDeploymentGroupRequest(input)
	return out, req.Send()
}

// UpdateDeploymentGroupWithContext is the same as UpdateDeploymentGroup with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateDeploymentGroup for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeDeploy) UpdateDeploymentGroupWithContext(ctx aws.Context, input *UpdateDeploymentGroupInput, opts ...request.Option) (*UpdateDeploymentGroupOutput, error) {
	req, out := c.UpdateDeploymentGroupRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// Represents the input of, and adds tags to, an on-premises instance operation.
type AddTagsToOnPremisesInstancesInput struct {
	_ struct{} `type:"structure"`

	// The names of the on-premises instances to which to add tags.
	//
	// InstanceNames is a required field
	InstanceNames []*string `locationName:"instanceNames" type:"list" required:"true"`

	// The tag key-value pairs to add to the on-premises instances.
	//
	// Keys and values are both required. Keys cannot be null or empty strings.
	// Value-only tags are not allowed.
	//
	// Tags is a required field
	Tags []*Tag `locationName:"tags" type:"list" required:"true"`
}

// String returns the string representation
func (s AddTagsToOnPremisesInstancesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddTagsToOnPremisesInstancesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AddTagsToOnPremisesInstancesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "AddTagsToOnPremisesInstancesInput"}
	if s.InstanceNames == nil {
		invalidParams.Add(request.NewErrParamRequired("InstanceNames"))
	}
	if s.Tags == nil {
		invalidParams.Add(request.NewErrParamRequired("Tags"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetInstanceNames sets the InstanceNames field's value.
func (s *AddTagsToOnPremisesInstancesInput) SetInstanceNames(v []*string) *AddTagsToOnPremisesInstancesInput {
	s.InstanceNames = v
	return s
}

// SetTags sets the Tags field's value.
func (s *AddTagsToOnPremisesInstancesInput) SetTags(v []*Tag) *AddTagsToOnPremisesInstancesInput {
	s.Tags = v
	return s
}

type AddTagsToOnPremisesInstancesOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s AddTagsToOnPremisesInstancesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddTagsToOnPremisesInstancesOutput) GoString() string {
	return s.String()
}

// Information about an alarm.
type Alarm struct {
	_ struct{} `type:"structure"`

	// The name of the alarm. Maximum length is 255 characters. Each alarm name
	// can be used only once in a list of alarms.
	Name *string `locationName:"name" type:"string"`
}

// String returns the string representation
func (s Alarm) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Alarm) GoString() string {
	return s.String()
}

// SetName sets the Name field's value.
func (s *Alarm) SetName(v string) *Alarm {
	s.Name = &v
	return s
}

// Information about alarms associated with the deployment group.
type AlarmConfiguration struct {
	_ struct{} `type:"structure"`

	// A list of alarms configured for the deployment group. A maximum of 10 alarms
	// can be added to a deployment group.
	Alarms []*Alarm `locationName:"alarms" type:"list"`

	// Indicates whether the alarm configuration is enabled.
	Enabled *bool `locationName:"enabled" type:"boolean"`

	// Indicates whether a deployment should continue if information about the current
	// state of alarms cannot be retrieved from Amazon CloudWatch. The default value
	// is false.
	//
	//    * true: The deployment proceeds even if alarm status information can't
	//    be retrieved from Amazon CloudWatch.
	//
	//    * false: The deployment stops if alarm status information can't be retrieved
	//    from Amazon CloudWatch.
	IgnorePollAlarmFailure *bool `locationName:"ignorePollAlarmFailure" type:"boolean"`
}

// String returns the string representation
func (s AlarmConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AlarmConfiguration) GoString() string {
	return s.String()
}

// SetAlarms sets the Alarms field's value.
func (s *AlarmConfiguration) SetAlarms(v []*Alarm) *AlarmConfiguration {
	s.Alarms = v
	return s
}

// SetEnabled sets the Enabled field's value.
func (s *AlarmConfiguration) SetEnabled(v bool) *AlarmConfiguration {
	s.Enabled = &v
	return s
}

// SetIgnorePollAlarmFailure sets the IgnorePollAlarmFailure field's value.
func (s *AlarmConfiguration) SetIgnorePollAlarmFailure(v bool) *AlarmConfiguration {
	s.IgnorePollAlarmFailure = &v
	return s
}

// A revision for an AWS Lambda or Amazon ECS deployment that is a YAML-formatted
// or JSON-formatted string. For AWS Lambda and Amazon ECS deployments, the
// revision is the same as the AppSpec file. This method replaces the deprecated
// RawString data type.
type AppSpecContent struct {
	_ struct{} `type:"structure"`

	// The YAML-formatted or JSON-formatted revision string.
	//
	// For an AWS Lambda deployment, the content includes a Lambda function name,
	// the alias for its original version, and the alias for its replacement version.
	// The deployment shifts traffic from the original version of the Lambda function
	// to the replacement version.
	//
	// For an Amazon ECS deployment, the content includes the task name, information
	// about the load balancer that serves traffic to the container, and more.
	//
	// For both types of deployments, the content can specify Lambda functions that
	// run at specified hooks, such as BeforeInstall, during a deployment.
	Content *string `locationName:"content" type:"string"`

	// The SHA256 hash value of the revision content.
	Sha256 *string `locationName:"sha256" type:"string"`
}

// String returns the string representation
func (s AppSpecContent) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AppSpecContent) GoString() string {
	return s.String()
}

// SetContent sets the Content field's value.
func (s *AppSpecContent) SetContent(v string) *AppSpecContent {
	s.Content = &v
	return s
}

// SetSha256 sets the Sha256 field's value.
func (s *AppSpecContent) SetSha256(v string) *AppSpecContent {
	s.Sha256 = &v
	return s
}

// Information about an application.
type ApplicationInfo struct {
	_ struct{} `type:"structure"`

	// The application ID.
	ApplicationId *string `locationName:"applicationId" type:"string"`

	// The application name.
	ApplicationName *string `locationName:"applicationName" min:"1" type:"string"`

	// The destination platform type for deployment of the application (Lambda or
	// Server).
	ComputePlatform *string `locationName:"computePlatform" type:"string" enum:"ComputePlatform"`

	// The time at which the application was created.
	CreateTime *time.Time `locationName:"createTime" type:"timestamp"`

	// The name for a connection to a GitHub account.
	GitHubAccountName *string `locationName:"gitHubAccountName" type:"string"`

	// True if the user has authenticated with GitHub for the specified application.
	// Otherwise, false.
	LinkedToGitHub *bool `locationName:"linkedToGitHub" type:"boolean"`
}

// String returns the string representation
func (s ApplicationInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApplicationInfo) GoString() string {
	return s.String()
}

// SetApplicationId sets the ApplicationId field's value.
func (s *ApplicationInfo) SetApplicationId(v string) *ApplicationInfo {
	s.ApplicationId = &v
	return s
}

// SetApplicationName sets the ApplicationName field's value.
func (s *ApplicationInfo) SetApplicationName(v string) *ApplicationInfo {
	s.ApplicationName = &v
	return s
}

// SetComputePlatform sets the ComputePlatform field's value.
func (s *ApplicationInfo) SetComputePlatform(v string) *ApplicationInfo {
	s.ComputePlatform = &v
	return s
}

// SetCreateTime sets the CreateTime field's value.
func (s *ApplicationInfo) SetCreateTime(v time.Time) *ApplicationInfo {
	s.CreateTime = &v
	return s
}

// SetGitHubAccountName sets the GitHubAccountName field's value.
func (s *ApplicationInfo) SetGitHubAccountName(v string) *ApplicationInfo {
	s.GitHubAccountName = &v
	return s
}

// SetLinkedToGitHub sets the LinkedToGitHub field's value.
func (s *ApplicationInfo) SetLinkedToGitHub(v bool) *ApplicationInfo {
	s.LinkedToGitHub = &v
	return s
}

// Information about a configuration for automatically rolling back to a previous
// version of an application revision when a deployment is not completed successfully.
type AutoRollbackConfiguration struct {
	_ struct{} `type:"structure"`

	// Indicates whether a defined automatic rollback configuration is currently
	// enabled.
	Enabled *bool `locationName:"enabled" type:"boolean"`

	// The event type or types that trigger a rollback.
	Events []*string `locationName:"events" type:"list"`
}

// String returns the string representation
func (s AutoRollbackConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoRollbackConfiguration) GoString() string {
	return s.String()
}

// SetEnabled sets the Enabled field's value.
func (s *AutoRollbackConfiguration) SetEnabled(v bool) *AutoRollbackConfiguration {
	s.Enabled = &v
	return s
}

// SetEvents sets the Events field's value.
func (s *AutoRollbackConfiguration) SetEvents(v []*string) *AutoRollbackConfiguration {
	s.Events = v
	return s
}

// Information about an Auto Scaling group.
type AutoScalingGroup struct {
	_ struct{} `type:"structure"`

	// An Auto Scaling lifecycle event hook name.
	Hook *string `locationName:"hook" type:"string"`

	// The Auto Scaling group name.
	Name *string `locationName:"name" type:"string"`
}

// String returns the string representation
func (s AutoScalingGroup) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingGroup) GoString() string {
	return s.String()
}

// SetHook sets the Hook field's value.
func (s *AutoScalingGroup) SetHook(v string) *AutoScalingGroup {
	s.Hook = &v
	return s
}

// SetName sets the Name field's value.
func (s *AutoScalingGroup) SetName(v string) *AutoScalingGroup {
	s.Name = &v
	return s
}

// Represents the input of a BatchGetApplicationRevisions operation.
type BatchGetApplicationRevisionsInput struct {
	_ struct{} `type:"structure"`

	// The name of an AWS CodeDeploy application about which to get revision information.
	//
	// ApplicationName is a required field
	ApplicationName *string `locationName:"applicationName" min:"1" type:"string" required:"true"`

	// An array of RevisionLocation objects that specify information to get about
	// the application revisions, including type and location. The maximum number
	// of RevisionLocation objects you can specify is 25.
	//
	// Revisions is a required field
	Revisions []*RevisionLocation `locationName:"revisions" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchGetApplicationRevisionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetApplicationRevisionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetApplicationRevisionsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchGetApplicationRevisionsInput"}
	if s.ApplicationName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApplicationName"))
	}
	if s.ApplicationName != nil && len(*s.ApplicationName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApplicationName", 1))
	}
	if s.Revisions == nil {
		invalidParams.Add(request.NewErrParamRequired("Revisions"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApplicationName sets the ApplicationName field's value.
func (s *BatchGetApplicationRevisionsInput) SetApplicationName(v string) *BatchGetApplicationRevisionsInput {
	s.ApplicationName = &v
	return s
}

// SetRevisions sets the Revisions field's value.
func (s *BatchGetApplicationRevisionsInput) SetRevisions(v []*RevisionLocation) *BatchGetApplicationRevisionsInput {
	s.Revisions = v
	return s
}

// Represents the output of a BatchGetApplicationRevisions operation.
type BatchGetApplicationRevisionsOutput struct {
	_ struct{} `type:"structure"`

	// The name of the application that corresponds to the revisions.
	ApplicationName *string `locationName:"applicationName" min:"1" type:"string"`

	// Information about errors that might have occurred during the API call.
	ErrorMessage *string `locationName:"errorMessage" type:"string"`

	// Additional information about the revisions, including the type and location.
	Revisions []*RevisionInfo `locationName:"revisions" type:"list"`
}

// String returns the string representation
func (s BatchGetApplicationRevisionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetApplicationRevisionsOutput) GoString() string {
	return s.String()
}

// SetApplicationName sets the ApplicationName field's value.
func (s *BatchGetApplicationRevisionsOutput) SetApplicationName(v string) *BatchGetApplicationRevisionsOutput {
	s.ApplicationName = &v
	return s
}

// SetErrorMessage sets the ErrorMessage field's value.
func (s *BatchGetApplicationRevisionsOutput) SetErrorMessage(v string) *BatchGetApplicationRevisionsOutput {
	s.ErrorMessage = &v
	return s
}

// SetRevisions sets the Revisions field's value.
func (s *BatchGetApplicationRevisionsOutput) SetRevisions(v []*RevisionInfo) *BatchGetApplicationRevisionsOutput {
	s.Revisions = v
	return s
}

// Represents the input of a BatchGetApplications operation.
type BatchGetApplicationsInput struct {
	_ struct{} `type:"structure"`

	// A list of application names separated by spaces. The maximum number of application
	// names you can specify is 25.
	//
	// ApplicationNames is a required field
	ApplicationNames []*string `locationName:"applicationNames" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchGetApplicationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetApplicationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetApplicationsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchGetApplicationsInput"}
	if s.ApplicationNames == nil {
		invalidParams.Add(request.NewErrParamRequired("ApplicationNames"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApplicationNames sets the ApplicationNames field's value.
func (s *BatchGetApplicationsInput) SetApplicationNames(v []*string) *BatchGetApplicationsInput {
	s.ApplicationNames = v
	return s
}

// Represents the output of a BatchGetApplications operation.
type BatchGetApplicationsOutput struct {
	_ struct{} `type:"structure"`

	// Information about the applications.
	ApplicationsInfo []*ApplicationInfo `locationName:"applicationsInfo" type:"list"`
}

// String returns the string representation
func (s BatchGetApplicationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetApplicationsOutput) GoString() string {
	return s.String()
}

// SetApplicationsInfo sets the ApplicationsInfo field's value.
func (s *BatchGetApplicationsOutput) SetApplicationsInfo(v []*ApplicationInfo) *BatchGetApplicationsOutput {
	s.ApplicationsInfo = v
	return s
}

// Represents the input of a BatchGetDeploymentGroups operation.
type BatchGetDeploymentGroupsInput struct {
	_ struct{} `type:"structure"`

	// The name of an AWS CodeDeploy application associated with the applicable
	// IAM user or AWS account.
	//
	// ApplicationName is a required field
	ApplicationName *string `locationName:"applicationName" min:"1" type:"string" required:"true"`

	// The names of the deployment groups.
	//
	// DeploymentGroupNames is a required field
	DeploymentGroupNames []*string `locationName:"deploymentGroupNames" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchGetDeploymentGroupsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetDeploymentGroupsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetDeploymentGroupsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchGetDeploymentGroupsInput"}
	if s.ApplicationName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApplicationName"))
	}
	if s.ApplicationName != nil && len(*s.ApplicationName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApplicationName", 1))
	}
	if s.DeploymentGroupNames == nil {
		invalidParams.Add(request.NewErrParamRequired("DeploymentGroupNames"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApplicationName sets the ApplicationName field's value.
func (s *BatchGetDeploymentGroupsInput) SetApplicationName(v string) *BatchGetDeploymentGroupsInput {
	s.ApplicationName = &v
	return s
}

// SetDeploymentGroupNames sets the DeploymentGroupNames field's value.
func (s *BatchGetDeploymentGroupsInput) SetDeploymentGroupNames(v []*string) *BatchGetDeploymentGroupsInput {
	s.DeploymentGroupNames = v
	return s
}

// Represents the output of a BatchGetDeploymentGroups operation.
type BatchGetDeploymentGroupsOutput struct {
	_ struct{} `type:"structure"`

	// Information about the deployment groups.
	DeploymentGroupsInfo []*DeploymentGroupInfo `locationName:"deploymentGroupsInfo" type:"list"`

	// Information about errors that might have occurred during the API call.
	ErrorMessage *string `locationName:"errorMessage" type:"string"`
}

// String returns the string representation
func (s BatchGetDeploymentGroupsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetDeploymentGroupsOutput) GoString() string {
	return s.String()
}

// SetDeploymentGroupsInfo sets the DeploymentGroupsInfo field's value.
func (s *BatchGetDeploymentGroupsOutput) SetDeploymentGroupsInfo(v []*DeploymentGroupInfo) *BatchGetDeploymentGroupsOutput {
	s.DeploymentGroupsInfo = v
	return s
}

// SetErrorMessage sets the ErrorMessage field's value.
func (s *BatchGetDeploymentGroupsOutput) SetErrorMessage(v string) *BatchGetDeploymentGroupsOutput {
	s.ErrorMessage = &v
	return s
}

// Represents the input of a BatchGetDeploymentInstances operation.
type BatchGetDeploymentInstancesInput struct {
	_ struct{} `type:"structure"`

	// The unique ID of a deployment.
	//
	// DeploymentId is a required field
	DeploymentId *string `locationName:"deploymentId" type:"string" required:"true"`

	// The unique IDs of instances used in the deployment. The maximum number of
	// instance IDs you can specify is 25.
	//
	// InstanceIds is a required field
	InstanceIds []*string `locationName:"instanceIds" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchGetDeploymentInstancesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetDeploymentInstancesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetDeploymentInstancesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchGetDeploymentInstancesInput"}
	if s.DeploymentId == nil {
		invalidParams.Add(request.NewErrParamRequired("DeploymentId"))
	}
	if s.InstanceIds == nil {
		invalidParams.Add(request.NewErrParamRequired("InstanceIds"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDeploymentId sets the DeploymentId field's value.
func (s *BatchGetDeploymentInstancesInput) SetDeploymentId(v string) *BatchGetDeploymentInstancesInput {
	s.DeploymentId = &v
	return s
}

// SetInstanceIds sets the InstanceIds field's value.
func (s *BatchGetDeploymentInstancesInput) SetInstanceIds(v []*string) *BatchGetDeploymentInstancesInput {
	s.InstanceIds = v
	return s
}

// Represents the output of a BatchGetDeploymentInstances operation.
type BatchGetDeploymentInstancesOutput struct {
	_ struct{} `type:"structure"`

	// Information about errors that might have occurred during the API call.
	ErrorMessage *string `locationName:"errorMessage" type:"string"`

	// Information about the instance.
	InstancesSummary []*InstanceSummary `locationName:"instancesSummary" type:"list"`
}

// String returns the string representation
func (s BatchGetDeploymentInstancesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetDeploymentInstancesOutput) GoString() string {
	return s.String()
}

// SetErrorMessage sets the ErrorMessage field's value.
func (s *BatchGetDeploymentInstancesOutput) SetErrorMessage(v string) *BatchGetDeploymentInstancesOutput {
	s.ErrorMessage = &v
	return s
}

// SetInstancesSummary sets the InstancesSummary field's value.
func (s *BatchGetDeploymentInstancesOutput) SetInstancesSummary(v []*InstanceSummary) *BatchGetDeploymentInstancesOutput {
	s.InstancesSummary = v
	return s
}

type BatchGetDeploymentTargetsInput struct {
	_ struct{} `type:"structure"`

	// The unique ID of a deployment.
	DeploymentId *string `locationName:"deploymentId" type:"string"`

	// The unique IDs of the deployment targets. The compute platform of the deployment
	// determines the type of the targets and their formats. The maximum number
	// of deployment target IDs you can specify is 25.
	//
	//    * For deployments that use the EC2/On-premises compute platform, the target
	//    IDs are EC2 or on-premises instances IDs, and their target type is instanceTarget.
	//
	//    * For deployments that use the AWS Lambda compute platform, the target
	//    IDs are the names of Lambda functions, and their target type is instanceTarget.
	//
	//    * For deployments that use the Amazon ECS compute platform, the target
	//    IDs are pairs of Amazon ECS clusters and services specified using the
	//    format <clustername>:<servicename>. Their target type is ecsTarget.
	TargetIds []*string `locationName:"targetIds" type:"list"`
}

// String returns the string representation
func (s BatchGetDeploymentTargetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetDeploymentTargetsInput) GoString() string {
	return s.String()
}

// SetDeploymentId sets the DeploymentId field's value.
func (s *BatchGetDeploymentTargetsInput) SetDeploymentId(v string) *BatchGetDeploymentTargetsInput {
	s.DeploymentId = &v
	return s
}

// SetTargetIds sets the TargetIds field's value.
func (s *BatchGetDeploymentTargetsInput) SetTargetIds(v []*string) *BatchGetDeploymentTargetsInput {
	s.TargetIds = v
	return s
}

type BatchGetDeploymentTargetsOutput struct {
	_ struct{} `type:"structure"`

	// A list of target objects for a deployment. Each target object contains details
	// about the target, such as its status and lifecycle events. The type of the
	// target objects depends on the deployment' compute platform.
	//
	//    * EC2/On-premises: Each target object is an EC2 or on-premises instance.
	//
	//    * AWS Lambda: The target object is a specific version of an AWS Lambda
	//    function.
	//
	//    * Amazon ECS: The target object is an Amazon ECS service.
	DeploymentTargets []*DeploymentTarget `locationName:"deploymentTargets" type:"list"`
}

// String returns the string representation
func (s BatchGetDeploymentTargetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetDeploymentTargetsOutput) GoString() string {
	return s.String()
}

// SetDeploymentTargets sets the DeploymentTargets field's value.
func (s *BatchGetDeploymentTargetsOutput) SetDeploymentTargets(v []*DeploymentTarget) *BatchGetDeploymentTargetsOutput {
	s.DeploymentTargets = v
	return s
}

// Represents the input of a BatchGetDeployments operation.
type BatchGetDeploymentsInput struct {
	_ struct{} `type:"structure"`

	// A list of deployment IDs, separated by spaces. The maximum number of deployment
	// IDs you can specify is 25.
	//
	// DeploymentIds is a required field
	DeploymentIds []*string `locationName:"deploymentIds" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchGetDeploymentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetDeploymentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetDeploymentsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchGetDeploymentsInput"}
	if s.DeploymentIds == nil {
		invalidParams.Add(request.NewErrParamRequired("DeploymentIds"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDeploymentIds sets the DeploymentIds field's value.
func (s *BatchGetDeploymentsInput) SetDeploymentIds(v []*string) *BatchGetDeploymentsInput {
	s.DeploymentIds = v
	return s
}

// Represents the output of a BatchGetDeployments operation.
type BatchGetDeploymentsOutput struct {
	_ struct{} `type:"structure"`

	// Information about the deployments.
	DeploymentsInfo []*DeploymentInfo `locationName:"deploymentsInfo" type:"list"`
}

// String returns the string representation
func (s BatchGetDeploymentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetDeploymentsOutput) GoString() string {
	return s.String()
}

// SetDeploymentsInfo sets the DeploymentsInfo field's value.
func (s *BatchGetDeploymentsOutput) SetDeploymentsInfo(v []*DeploymentInfo) *BatchGetDeploymentsOutput {
	s.DeploymentsInfo = v
	return s
}

// Represents the input of a BatchGetOnPremisesInstances operation.
type BatchGetOnPremisesInstancesInput struct {
	_ struct{} `type:"structure"`

	// The names of the on-premises instances about which to get information. The
	// maximum number of instance names you can specify is 25.
	//
	// InstanceNames is a required field
	InstanceNames []*string `locationName:"instanceNames" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchGetOnPremisesInstancesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetOnPremisesInstancesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetOnPremisesInstancesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchGetOnPremisesInstancesInput"}
	if s.InstanceNames == nil {
		invalidParams.Add(request.NewErrParamRequired("InstanceNames"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetInstanceNames sets the InstanceNames field's value.
func (s *BatchGetOnPremisesInstancesInput) SetInstanceNames(v []*string) *BatchGetOnPremisesInstancesInput {
	s.InstanceNames = v
	return s
}

// Represents the output of a BatchGetOnPremisesInstances operation.
type BatchGetOnPremisesInstancesOutput struct {
	_ struct{} `type:"structure"`

	// Information about the on-premises instances.
	InstanceInfos []*InstanceInfo `locationName:"instanceInfos" type:"list"`
}

// String returns the string representation
func (s BatchGetOnPremisesInstancesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetOnPremisesInstancesOutput) GoString() string {
	return s.String()
}

// SetInstanceInfos sets the InstanceInfos field's value.
func (s *BatchGetOnPremisesInstancesOutput) SetInstanceInfos(v []*InstanceInfo) *BatchGetOnPremisesInstancesOutput {
	s.InstanceInfos = v
	return s
}

// Information about blue/green deployment options for a deployment group.
type BlueGreenDeploymentConfiguration struct {
	_ struct{} `type:"structure"`

	// Information about the action to take when newly provisioned instances are
	// ready to receive traffic in a blue/green deployment.
	DeploymentReadyOption *DeploymentReadyOption `locationName:"deploymentReadyOption" type:"structure"`

	// Information about how instances are provisioned for a replacement environment
	// in a blue/green deployment.
	GreenFleetProvisioningOption *GreenFleetProvisioningOption `locationName:"greenFleetProvisioningOption" type:"structure"`

	// Information about whether to terminate instances in the original fleet during
	// a blue/green deployment.
	TerminateBlueInstancesOnDeploymentSuccess *BlueInstanceTerminationOption `locationName:"terminateBlueInstancesOnDeploymentSuccess" type:"structure"`
}

// String returns the string representation
func (s BlueGreenDeploymentConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BlueGreenDeploymentConfiguration) GoString() string {
	return s.String()
}

// SetDeploymentReadyOption sets the DeploymentReadyOption field's value.
func (s *BlueGreenDeploymentConfiguration) SetDeploymentReadyOption(v *DeploymentReadyOption) *BlueGreenDeploymentConfiguration {
	s.DeploymentReadyOption = v
	return s
}

// SetGreenFleetProvisioningOption sets the GreenFleetProvisioningOption field's value.
func (s *BlueGreenDeploymentConfiguration) SetGreenFleetProvisioningOption(v *GreenFleetProvisioningOption) *BlueGreenDeploymentConfiguration {
	s.GreenFleetProvisioningOption = v
	return s
}

// SetTerminateBlueInstancesOnDeploymentSuccess sets the TerminateBlueInstancesOnDeploymentSuccess field's value.
func (s *BlueGreenDeploymentConfiguration) SetTerminateBlueInstancesOnDeploymentSuccess(v *BlueInstanceTerminationOption) *BlueGreenDeploymentConfiguration {
	s.TerminateBlueInstancesOnDeploymentSuccess = v
	return s
}

// Information about whether instances in the original environment are terminated
// when a blue/green deployment is successful. BlueInstanceTerminationOption
// does not apply to Lambda deployments.
type BlueInstanceTerminationOption struct {
	_ struct{} `type:"structure"`

	// The action to take on instances in the original environment after a successful
	// blue/green deployment.
	//
	//    * TERMINATE: Instances are terminated after a specified wait time.
	//
	//    * KEEP_ALIVE: Instances are left running after they are deregistered from
	//    the load balancer and removed from the deployment group.
	Action *string `locationName:"action" type:"string" enum:"InstanceAction"`

	// For an Amazon EC2 deployment, the number of minutes to wait after a successful
	// blue/green deployment before terminating instances from the original environment.
	//
	// For an Amazon ECS deployment, the number of minutes before deleting the original
	// (blue) task set. During an Amazon ECS deployment, CodeDeploy shifts traffic
	// from the original (blue) task set to a replacement (green) task set.
	//
	// The maximum setting is 2880 minutes (2 days).
	TerminationWaitTimeInMinutes *int64 `locationName:"terminationWaitTimeInMinutes" type:"integer"`
}

// String returns the string representation
func (s BlueInstanceTerminationOption) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BlueInstanceTerminationOption) GoString() string {
	return s.String()
}

// SetAction sets the Action field's value.
func (s *BlueInstanceTerminationOption) SetAction(v string) *BlueInstanceTerminationOption {
	s.Action = &v
	return s
}

// SetTerminationWaitTimeInMinutes sets the TerminationWaitTimeInMinutes field's value.
func (s *BlueInstanceTerminationOption) SetTerminationWaitTimeInMinutes(v int64) *BlueInstanceTerminationOption {
	s.TerminationWaitTimeInMinutes = &v
	return s
}

type ContinueDeploymentInput struct {
	_ struct{} `type:"structure"`

	// The unique ID of a blue/green deployment for which you want to start rerouting
	// traffic to the replacement environment.
	DeploymentId *string `locationName:"deploymentId" type:"string"`

	// The status of the deployment's waiting period. READY_WAIT indicates the deployment
	// is ready to start shifting traffic. TERMINATION_WAIT indicates the traffic
	// is shifted, but the original target is not terminated.
	DeploymentWaitType *string `locationName:"deploymentWaitType" type:"string" enum:"DeploymentWaitType"`
}

// String returns the string representation
func (s ContinueDeploymentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContinueDeploymentInput) GoString() string {
	return s.String()
}

// SetDeploymentId sets the DeploymentId field's value.
func (s *ContinueDeploymentInput) SetDeploymentId(v string) *ContinueDeploymentInput {
	s.DeploymentId = &v
	return s
}

// SetDeploymentWaitType sets the DeploymentWaitType field's value.
func (s *ContinueDeploymentInput) SetDeploymentWaitType(v string) *ContinueDeploymentInput {
	s.DeploymentWaitType = &v
	return s
}

type ContinueDeploymentOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s ContinueDeploymentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContinueDeploymentOutput) GoString() string {
	return s.String()
}

// Represents the input of a CreateApplication operation.
type CreateApplicationInput struct {
	_ struct{} `type:"structure"`

	// The name of the application. This name must be unique with the applicable
	// IAM user or AWS account.
	//
	// ApplicationName is a required field
	ApplicationName *string `locationName:"applicationName" min:"1" type:"string" required:"true"`

	// The destination platform type for the deployment (Lambda, Server, or ECS).
	ComputePlatform *string `locationName:"computePlatform" type:"string" enum:"ComputePlatform"`

	// The metadata that you apply to CodeDeploy applications to help you organize
	// and categorize them. Each tag consists of a key and an optional value, both
	// of which you define.
	Tags []*Tag `locationName:"tags" type:"list"`
}

// String returns the string representation
func (s CreateApplicationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateApplicationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateApplicationInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateApplicationInput"}
	if s.ApplicationName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApplicationName"))
	}
	if s.ApplicationName != nil && len(*s.ApplicationName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApplicationName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApplicationName sets the ApplicationName field's value.
func (s *CreateApplicationInput) SetApplicationName(v string) *CreateApplicationInput {
	s.ApplicationName = &v
	return s
}

// SetComputePlatform sets the ComputePlatform field's value.
func (s *CreateApplicationInput) SetComputePlatform(v string) *CreateApplicationInput {
	s.ComputePlatform = &v
	return s
}

// SetTags sets the Tags field's value.
func (s *CreateApplicationInput) SetTags(v []*Tag) *CreateApplicationInput {
	s.Tags = v
	return s
}

// Represents the output of a CreateApplication operation.
type CreateApplicationOutput struct {
	_ struct{} `type:"structure"`

	// A unique application ID.
	ApplicationId *string `locationName:"applicationId" type:"string"`
}

// String returns the string representation
func (s CreateApplicationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateApplicationOutput) GoString() string {
	return s.String()
}

// SetApplicationId sets the ApplicationId field's value.
func (s *CreateApplicationOutput) SetApplicationId(v string) *CreateApplicationOutput {
	s.ApplicationId = &v
	return s
}

// Represents the input of a CreateDeploymentConfig operation.
type CreateDeploymentConfigInput struct {
	_ struct{} `type:"structure"`

	// The destination platform type for the deployment (Lambda, Server, or ECS).
	ComputePlatform *string `locationName:"computePlatform" type:"string" enum:"ComputePlatform"`

	// The name of the deployment configuration to create.
	//
	// DeploymentConfigName is a required field
	DeploymentConfigName *string `locationName:"deploymentConfigName" min:"1" type:"string" required:"true"`

	// The minimum number of healthy instances that should be available at any time
	// during the deployment. There are two parameters expected in the input: type
	// and value.
	//
	// The type parameter takes either of the following values:
	//
	//    * HOST_COUNT: The value parameter represents the minimum number of healthy
	//    instances as an absolute value.
	//
	//    * FLEET_PERCENT: The value parameter represents the minimum number of
	//    healthy instances as a percentage of the total number of instances in
	//    the deployment. If you specify FLEET_PERCENT, at the start of the deployment,
	//    AWS CodeDeploy converts the percentage to the equivalent number of instance
	//    and rounds up fractional instances.
	//
	// The value parameter takes an integer.
	//
	// For example, to set a minimum of 95% healthy instance, specify a type of
	// FLEET_PERCENT and a value of 95.
	MinimumHealthyHosts *MinimumHealthyHosts `locationName:"minimumHealthyHosts" type:"structure"`

	// The configuration that specifies how the deployment traffic is routed.
	TrafficRoutingConfig *TrafficRoutingConfig `locationName:"trafficRoutingConfig" type:"structure"`
}

// String returns the string representation
func (s CreateDeploymentConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDeploymentConfigInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDeploymentConfigInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateDeploymentConfigInput"}
	if s.DeploymentConfigName == nil {
		invalidParams.Add(request.NewErrParamRequired("DeploymentConfigName"))
	}
	if s.DeploymentConfigName != nil && len(*s.DeploymentConfigName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("DeploymentConfigName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetComputePlatform sets the ComputePlatform field's value.
func (s *CreateDeploymentConfigInput) SetComputePlatform(v string) *CreateDeploymentConfigInput {
	s.ComputePlatform = &v
	return s
}

// SetDeploymentConfigName sets the DeploymentConfigName field's value.
func (s *CreateDeploymentConfigInput) SetDeploymentConfigName(v string) *CreateDeploymentConfigInput {
	s.DeploymentConfigName = &v
	return s
}

// SetMinimumHealthyHosts sets the MinimumHealthyHosts field's value.
func (s *CreateDeploymentConfigInput) SetMinimumHealthyHosts(v *MinimumHealthyHosts) *CreateDeploymentConfigInput {
	s.MinimumHealthyHosts = v
	return s
}

// SetTrafficRoutingConfig sets the TrafficRoutingConfig field's value.
func (s *CreateDeploymentConfigInput) SetTrafficRoutingConfig(v *TrafficRoutingConfig) *CreateDeploymentConfigInput {
	s.TrafficRoutingConfig = v
	return s
}

// Represents the output of a CreateDeploymentConfig operation.
type CreateDeploymentConfigOutput struct {
	_ struct{} `type:"structure"`

	// A unique deployment configuration ID.
	DeploymentConfigId *string `locationName:"deploymentConfigId" type:"string"`
}

// String returns the string representation
func (s CreateDeploymentConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDeploymentConfigOutput) GoString() string {
	return s.String()
}

// SetDeploymentConfigId sets the DeploymentConfigId field's value.
func (s *CreateDeploymentConfigOutput) SetDeploymentConfigId(v string) *CreateDeploymentConfigOutput {
	s.DeploymentConfigId = &v
	return s
}

// Represents the input of a CreateDeploymentGroup operation.
type CreateDeploymentGroupInput struct {
	_ struct{} `type:"structure"`

	// Information to add about Amazon CloudWatch alarms when the deployment group
	// is created.
	AlarmConfiguration *AlarmConfiguration `locationName:"alarmConfiguration" type:"structure"`

	// The name of an AWS CodeDeploy application associated with the IAM user or
	// AWS account.
	//
	// ApplicationName is a required field
	ApplicationName *string `locationName:"applicationName" min:"1" type:"string" required:"true"`

	// Configuration information for an automatic rollback that is added when a
	// deployment group is created.
	AutoRollbackConfiguration *AutoRollbackConfiguration `locationName:"autoRollbackConfiguration" type:"structure"`

	// A list of associated Amazon EC2 Auto Scaling groups.
	AutoScalingGroups []*string `locationName:"autoScalingGroups" type:"list"`

	// Information about blue/green deployment options for a deployment group.
	BlueGreenDeploymentConfiguration *BlueGreenDeploymentConfiguration `locationName:"blueGreenDeploymentConfiguration" type:"structure"`

	// If specified, the deployment configuration name can be either one of th