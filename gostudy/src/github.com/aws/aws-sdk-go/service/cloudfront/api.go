// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package cloudfront

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/private/protocol"
	"github.com/aws/aws-sdk-go/private/protocol/restxml"
)

const opCreateCloudFrontOriginAccessIdentity = "CreateCloudFrontOriginAccessIdentity2019_03_26"

// CreateCloudFrontOriginAccessIdentityRequest generates a "aws/request.Request" representing the
// client's request for the CreateCloudFrontOriginAccessIdentity operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateCloudFrontOriginAccessIdentity for more information on using the CreateCloudFrontOriginAccessIdentity
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateCloudFrontOriginAccessIdentityRequest method.
//    req, resp := client.CreateCloudFrontOriginAccessIdentityRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateCloudFrontOriginAccessIdentity
func (c *CloudFront) CreateCloudFrontOriginAccessIdentityRequest(input *CreateCloudFrontOriginAccessIdentityInput) (req *request.Request, output *CreateCloudFrontOriginAccessIdentityOutput) {
	op := &request.Operation{
		Name:       opCreateCloudFrontOriginAccessIdentity,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/origin-access-identity/cloudfront",
	}

	if input == nil {
		input = &CreateCloudFrontOriginAccessIdentityInput{}
	}

	output = &CreateCloudFrontOriginAccessIdentityOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateCloudFrontOriginAccessIdentity API operation for Amazon CloudFront.
//
// Creates a new origin access identity. If you're using Amazon S3 for your
// origin, you can use an origin access identity to require users to access
// your content using a CloudFront URL instead of the Amazon S3 URL. For more
// information about how to use origin access identities, see Serving Private
// Content through CloudFront (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html)
// in the Amazon CloudFront Developer Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation CreateCloudFrontOriginAccessIdentity for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeOriginAccessIdentityAlreadyExists "CloudFrontOriginAccessIdentityAlreadyExists"
//   If the CallerReference is a value you already sent in a previous request
//   to create an identity but the content of the CloudFrontOriginAccessIdentityConfig
//   is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists
//   error.
//
//   * ErrCodeMissingBody "MissingBody"
//   This operation requires a body. Ensure that the body is present and the Content-Type
//   header is set.
//
//   * ErrCodeTooManyCloudFrontOriginAccessIdentities "TooManyCloudFrontOriginAccessIdentities"
//   Processing your request would cause you to exceed the maximum number of origin
//   access identities allowed.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateCloudFrontOriginAccessIdentity
func (c *CloudFront) CreateCloudFrontOriginAccessIdentity(input *CreateCloudFrontOriginAccessIdentityInput) (*CreateCloudFrontOriginAccessIdentityOutput, error) {
	req, out := c.CreateCloudFrontOriginAccessIdentityRequest(input)
	return out, req.Send()
}

// CreateCloudFrontOriginAccessIdentityWithContext is the same as CreateCloudFrontOriginAccessIdentity with the addition of
// the ability to pass a context and additional request options.
//
// See CreateCloudFrontOriginAccessIdentity for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) CreateCloudFrontOriginAccessIdentityWithContext(ctx aws.Context, input *CreateCloudFrontOriginAccessIdentityInput, opts ...request.Option) (*CreateCloudFrontOriginAccessIdentityOutput, error) {
	req, out := c.CreateCloudFrontOriginAccessIdentityRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateDistribution = "CreateDistribution2019_03_26"

// CreateDistributionRequest generates a "aws/request.Request" representing the
// client's request for the CreateDistribution operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateDistribution for more information on using the CreateDistribution
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateDistributionRequest method.
//    req, resp := client.CreateDistributionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateDistribution
func (c *CloudFront) CreateDistributionRequest(input *CreateDistributionInput) (req *request.Request, output *CreateDistributionOutput) {
	op := &request.Operation{
		Name:       opCreateDistribution,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/distribution",
	}

	if input == nil {
		input = &CreateDistributionInput{}
	}

	output = &CreateDistributionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateDistribution API operation for Amazon CloudFront.
//
// Creates a new web distribution. You create a CloudFront distribution to tell
// CloudFront where you want content to be delivered from, and the details about
// how to track and manage content delivery. Send a POST request to the /CloudFront
// API version/distribution/distribution ID resource.
//
// When you update a distribution, there are more required fields than when
// you create a distribution. When you update your distribution by using UpdateDistribution
// (https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_UpdateDistribution.html),
// follow the steps included in the documentation to get the current configuration
// and then make your updates. This helps to make sure that you include all
// of the required fields. To view a summary, see Required Fields for Create
// Distribution and Update Distribution (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html)
// in the Amazon CloudFront Developer Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation CreateDistribution for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeCNAMEAlreadyExists "CNAMEAlreadyExists"
//   The CNAME specified is already defined for CloudFront.
//
//   * ErrCodeDistributionAlreadyExists "DistributionAlreadyExists"
//   The caller reference you attempted to create the distribution with is associated
//   with another distribution.
//
//   * ErrCodeInvalidOrigin "InvalidOrigin"
//   The Amazon S3 origin server specified does not refer to a valid Amazon S3
//   bucket.
//
//   * ErrCodeInvalidOriginAccessIdentity "InvalidOriginAccessIdentity"
//   The origin access identity is not valid or doesn't exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeTooManyTrustedSigners "TooManyTrustedSigners"
//   Your request contains more trusted signers than are allowed per distribution.
//
//   * ErrCodeTrustedSignerDoesNotExist "TrustedSignerDoesNotExist"
//   One or more of your trusted signers don't exist.
//
//   * ErrCodeInvalidViewerCertificate "InvalidViewerCertificate"
//   A viewer certificate specified in the response body is not valid.
//
//   * ErrCodeInvalidMinimumProtocolVersion "InvalidMinimumProtocolVersion"
//   The minimum protocol version specified is not valid.
//
//   * ErrCodeMissingBody "MissingBody"
//   This operation requires a body. Ensure that the body is present and the Content-Type
//   header is set.
//
//   * ErrCodeTooManyDistributionCNAMEs "TooManyDistributionCNAMEs"
//   Your request contains more CNAMEs than are allowed per distribution.
//
//   * ErrCodeTooManyDistributions "TooManyDistributions"
//   Processing your request would cause you to exceed the maximum number of distributions
//   allowed.
//
//   * ErrCodeInvalidDefaultRootObject "InvalidDefaultRootObject"
//   The default root object file name is too big or contains an invalid character.
//
//   * ErrCodeInvalidRelativePath "InvalidRelativePath"
//   The relative path is too big, is not URL-encoded, or does not begin with
//   a slash (/).
//
//   * ErrCodeInvalidErrorCode "InvalidErrorCode"
//   An invalid error code was specified.
//
//   * ErrCodeInvalidResponseCode "InvalidResponseCode"
//   A response code specified in the response body is not valid.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidRequiredProtocol "InvalidRequiredProtocol"
//   This operation requires the HTTPS protocol. Ensure that you specify the HTTPS
//   protocol in your request, or omit the RequiredProtocols element from your
//   distribution configuration.
//
//   * ErrCodeNoSuchOrigin "NoSuchOrigin"
//   No origin exists with the specified Origin Id.
//
//   * ErrCodeTooManyOrigins "TooManyOrigins"
//   You cannot create more origins for the distribution.
//
//   * ErrCodeTooManyOriginGroupsPerDistribution "TooManyOriginGroupsPerDistribution"
//   Processing your request would cause you to exceed the maximum number of origin
//   groups allowed.
//
//   * ErrCodeTooManyCacheBehaviors "TooManyCacheBehaviors"
//   You cannot create more cache behaviors for the distribution.
//
//   * ErrCodeTooManyCookieNamesInWhiteList "TooManyCookieNamesInWhiteList"
//   Your request contains more cookie names in the whitelist than are allowed
//   per cache behavior.
//
//   * ErrCodeInvalidForwardCookies "InvalidForwardCookies"
//   Your request contains forward cookies option which doesn't match with the
//   expectation for the whitelisted list of cookie names. Either list of cookie
//   names has been specified when not allowed or list of cookie names is missing
//   when expected.
//
//   * ErrCodeTooManyHeadersInForwardedValues "TooManyHeadersInForwardedValues"
//   Your request contains too many headers in forwarded values.
//
//   * ErrCodeInvalidHeadersForS3Origin "InvalidHeadersForS3Origin"
//   The headers specified are not valid for an Amazon S3 origin.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
//   * ErrCodeTooManyCertificates "TooManyCertificates"
//   You cannot create anymore custom SSL/TLS certificates.
//
//   * ErrCodeInvalidLocationCode "InvalidLocationCode"
//   The location code specified is not valid.
//
//   * ErrCodeInvalidGeoRestrictionParameter "InvalidGeoRestrictionParameter"
//   The specified geo restriction parameter is not valid.
//
//   * ErrCodeInvalidProtocolSettings "InvalidProtocolSettings"
//   You cannot specify SSLv3 as the minimum protocol version if you only want
//   to support only clients that support Server Name Indication (SNI).
//
//   * ErrCodeInvalidTTLOrder "InvalidTTLOrder"
//   TTL order specified in the response body is not valid.
//
//   * ErrCodeInvalidWebACLId "InvalidWebACLId"
//   A web ACL id specified in the response body is not valid.
//
//   * ErrCodeTooManyOriginCustomHeaders "TooManyOriginCustomHeaders"
//   Your request contains too many origin custom headers.
//
//   * ErrCodeTooManyQueryStringParameters "TooManyQueryStringParameters"
//   Your request contains too many query string parameters.
//
//   * ErrCodeInvalidQueryStringParameters "InvalidQueryStringParameters"
//   Query string parameters specified in the response body are not valid.
//
//   * ErrCodeTooManyDistributionsWithLambdaAssociations "TooManyDistributionsWithLambdaAssociations"
//   Processing your request would cause the maximum number of distributions with
//   Lambda function associations per owner to be exceeded.
//
//   * ErrCodeTooManyLambdaFunctionAssociations "TooManyLambdaFunctionAssociations"
//   Your request contains more Lambda function associations than are allowed
//   per distribution.
//
//   * ErrCodeInvalidLambdaFunctionAssociation "InvalidLambdaFunctionAssociation"
//   The specified Lambda function association is invalid.
//
//   * ErrCodeInvalidOriginReadTimeout "InvalidOriginReadTimeout"
//   The read timeout specified for the origin is not valid.
//
//   * ErrCodeInvalidOriginKeepaliveTimeout "InvalidOriginKeepaliveTimeout"
//   The keep alive timeout specified for the origin is not valid.
//
//   * ErrCodeNoSuchFieldLevelEncryptionConfig "NoSuchFieldLevelEncryptionConfig"
//   The specified configuration for field-level encryption doesn't exist.
//
//   * ErrCodeIllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior"
//   The specified configuration for field-level encryption can't be associated
//   with the specified cache behavior.
//
//   * ErrCodeTooManyDistributionsAssociatedToFieldLevelEncryptionConfig "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig"
//   The maximum number of distributions have been associated with the specified
//   configuration for field-level encryption.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateDistribution
func (c *CloudFront) CreateDistribution(input *CreateDistributionInput) (*CreateDistributionOutput, error) {
	req, out := c.CreateDistributionRequest(input)
	return out, req.Send()
}

// CreateDistributionWithContext is the same as CreateDistribution with the addition of
// the ability to pass a context and additional request options.
//
// See CreateDistribution for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) CreateDistributionWithContext(ctx aws.Context, input *CreateDistributionInput, opts ...request.Option) (*CreateDistributionOutput, error) {
	req, out := c.CreateDistributionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateDistributionWithTags = "CreateDistributionWithTags2019_03_26"

// CreateDistributionWithTagsRequest generates a "aws/request.Request" representing the
// client's request for the CreateDistributionWithTags operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateDistributionWithTags for more information on using the CreateDistributionWithTags
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateDistributionWithTagsRequest method.
//    req, resp := client.CreateDistributionWithTagsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateDistributionWithTags
func (c *CloudFront) CreateDistributionWithTagsRequest(input *CreateDistributionWithTagsInput) (req *request.Request, output *CreateDistributionWithTagsOutput) {
	op := &request.Operation{
		Name:       opCreateDistributionWithTags,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/distribution?WithTags",
	}

	if input == nil {
		input = &CreateDistributionWithTagsInput{}
	}

	output = &CreateDistributionWithTagsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateDistributionWithTags API operation for Amazon CloudFront.
//
// Create a new distribution with tags.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation CreateDistributionWithTags for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeCNAMEAlreadyExists "CNAMEAlreadyExists"
//   The CNAME specified is already defined for CloudFront.
//
//   * ErrCodeDistributionAlreadyExists "DistributionAlreadyExists"
//   The caller reference you attempted to create the distribution with is associated
//   with another distribution.
//
//   * ErrCodeInvalidOrigin "InvalidOrigin"
//   The Amazon S3 origin server specified does not refer to a valid Amazon S3
//   bucket.
//
//   * ErrCodeInvalidOriginAccessIdentity "InvalidOriginAccessIdentity"
//   The origin access identity is not valid or doesn't exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeTooManyTrustedSigners "TooManyTrustedSigners"
//   Your request contains more trusted signers than are allowed per distribution.
//
//   * ErrCodeTrustedSignerDoesNotExist "TrustedSignerDoesNotExist"
//   One or more of your trusted signers don't exist.
//
//   * ErrCodeInvalidViewerCertificate "InvalidViewerCertificate"
//   A viewer certificate specified in the response body is not valid.
//
//   * ErrCodeInvalidMinimumProtocolVersion "InvalidMinimumProtocolVersion"
//   The minimum protocol version specified is not valid.
//
//   * ErrCodeMissingBody "MissingBody"
//   This operation requires a body. Ensure that the body is present and the Content-Type
//   header is set.
//
//   * ErrCodeTooManyDistributionCNAMEs "TooManyDistributionCNAMEs"
//   Your request contains more CNAMEs than are allowed per distribution.
//
//   * ErrCodeTooManyDistributions "TooManyDistributions"
//   Processing your request would cause you to exceed the maximum number of distributions
//   allowed.
//
//   * ErrCodeInvalidDefaultRootObject "InvalidDefaultRootObject"
//   The default root object file name is too big or contains an invalid character.
//
//   * ErrCodeInvalidRelativePath "InvalidRelativePath"
//   The relative path is too big, is not URL-encoded, or does not begin with
//   a slash (/).
//
//   * ErrCodeInvalidErrorCode "InvalidErrorCode"
//   An invalid error code was specified.
//
//   * ErrCodeInvalidResponseCode "InvalidResponseCode"
//   A response code specified in the response body is not valid.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidRequiredProtocol "InvalidRequiredProtocol"
//   This operation requires the HTTPS protocol. Ensure that you specify the HTTPS
//   protocol in your request, or omit the RequiredProtocols element from your
//   distribution configuration.
//
//   * ErrCodeNoSuchOrigin "NoSuchOrigin"
//   No origin exists with the specified Origin Id.
//
//   * ErrCodeTooManyOrigins "TooManyOrigins"
//   You cannot create more origins for the distribution.
//
//   * ErrCodeTooManyOriginGroupsPerDistribution "TooManyOriginGroupsPerDistribution"
//   Processing your request would cause you to exceed the maximum number of origin
//   groups allowed.
//
//   * ErrCodeTooManyCacheBehaviors "TooManyCacheBehaviors"
//   You cannot create more cache behaviors for the distribution.
//
//   * ErrCodeTooManyCookieNamesInWhiteList "TooManyCookieNamesInWhiteList"
//   Your request contains more cookie names in the whitelist than are allowed
//   per cache behavior.
//
//   * ErrCodeInvalidForwardCookies "InvalidForwardCookies"
//   Your request contains forward cookies option which doesn't match with the
//   expectation for the whitelisted list of cookie names. Either list of cookie
//   names has been specified when not allowed or list of cookie names is missing
//   when expected.
//
//   * ErrCodeTooManyHeadersInForwardedValues "TooManyHeadersInForwardedValues"
//   Your request contains too many headers in forwarded values.
//
//   * ErrCodeInvalidHeadersForS3Origin "InvalidHeadersForS3Origin"
//   The headers specified are not valid for an Amazon S3 origin.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
//   * ErrCodeTooManyCertificates "TooManyCertificates"
//   You cannot create anymore custom SSL/TLS certificates.
//
//   * ErrCodeInvalidLocationCode "InvalidLocationCode"
//   The location code specified is not valid.
//
//   * ErrCodeInvalidGeoRestrictionParameter "InvalidGeoRestrictionParameter"
//   The specified geo restriction parameter is not valid.
//
//   * ErrCodeInvalidProtocolSettings "InvalidProtocolSettings"
//   You cannot specify SSLv3 as the minimum protocol version if you only want
//   to support only clients that support Server Name Indication (SNI).
//
//   * ErrCodeInvalidTTLOrder "InvalidTTLOrder"
//   TTL order specified in the response body is not valid.
//
//   * ErrCodeInvalidWebACLId "InvalidWebACLId"
//   A web ACL id specified in the response body is not valid.
//
//   * ErrCodeTooManyOriginCustomHeaders "TooManyOriginCustomHeaders"
//   Your request contains too many origin custom headers.
//
//   * ErrCodeInvalidTagging "InvalidTagging"
//   Tagging specified in the response body is not valid.
//
//   * ErrCodeTooManyQueryStringParameters "TooManyQueryStringParameters"
//   Your request contains too many query string parameters.
//
//   * ErrCodeInvalidQueryStringParameters "InvalidQueryStringParameters"
//   Query string parameters specified in the response body are not valid.
//
//   * ErrCodeTooManyDistributionsWithLambdaAssociations "TooManyDistributionsWithLambdaAssociations"
//   Processing your request would cause the maximum number of distributions with
//   Lambda function associations per owner to be exceeded.
//
//   * ErrCodeTooManyLambdaFunctionAssociations "TooManyLambdaFunctionAssociations"
//   Your request contains more Lambda function associations than are allowed
//   per distribution.
//
//   * ErrCodeInvalidLambdaFunctionAssociation "InvalidLambdaFunctionAssociation"
//   The specified Lambda function association is invalid.
//
//   * ErrCodeInvalidOriginReadTimeout "InvalidOriginReadTimeout"
//   The read timeout specified for the origin is not valid.
//
//   * ErrCodeInvalidOriginKeepaliveTimeout "InvalidOriginKeepaliveTimeout"
//   The keep alive timeout specified for the origin is not valid.
//
//   * ErrCodeNoSuchFieldLevelEncryptionConfig "NoSuchFieldLevelEncryptionConfig"
//   The specified configuration for field-level encryption doesn't exist.
//
//   * ErrCodeIllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior"
//   The specified configuration for field-level encryption can't be associated
//   with the specified cache behavior.
//
//   * ErrCodeTooManyDistributionsAssociatedToFieldLevelEncryptionConfig "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig"
//   The maximum number of distributions have been associated with the specified
//   configuration for field-level encryption.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateDistributionWithTags
func (c *CloudFront) CreateDistributionWithTags(input *CreateDistributionWithTagsInput) (*CreateDistributionWithTagsOutput, error) {
	req, out := c.CreateDistributionWithTagsRequest(input)
	return out, req.Send()
}

// CreateDistributionWithTagsWithContext is the same as CreateDistributionWithTags with the addition of
// the ability to pass a context and additional request options.
//
// See CreateDistributionWithTags for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) CreateDistributionWithTagsWithContext(ctx aws.Context, input *CreateDistributionWithTagsInput, opts ...request.Option) (*CreateDistributionWithTagsOutput, error) {
	req, out := c.CreateDistributionWithTagsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateFieldLevelEncryptionConfig = "CreateFieldLevelEncryptionConfig2019_03_26"

// CreateFieldLevelEncryptionConfigRequest generates a "aws/request.Request" representing the
// client's request for the CreateFieldLevelEncryptionConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateFieldLevelEncryptionConfig for more information on using the CreateFieldLevelEncryptionConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateFieldLevelEncryptionConfigRequest method.
//    req, resp := client.CreateFieldLevelEncryptionConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateFieldLevelEncryptionConfig
func (c *CloudFront) CreateFieldLevelEncryptionConfigRequest(input *CreateFieldLevelEncryptionConfigInput) (req *request.Request, output *CreateFieldLevelEncryptionConfigOutput) {
	op := &request.Operation{
		Name:       opCreateFieldLevelEncryptionConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/field-level-encryption",
	}

	if input == nil {
		input = &CreateFieldLevelEncryptionConfigInput{}
	}

	output = &CreateFieldLevelEncryptionConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateFieldLevelEncryptionConfig API operation for Amazon CloudFront.
//
// Create a new field-level encryption configuration.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation CreateFieldLevelEncryptionConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeNoSuchFieldLevelEncryptionProfile "NoSuchFieldLevelEncryptionProfile"
//   The specified profile for field-level encryption doesn't exist.
//
//   * ErrCodeFieldLevelEncryptionConfigAlreadyExists "FieldLevelEncryptionConfigAlreadyExists"
//   The specified configuration for field-level encryption already exists.
//
//   * ErrCodeTooManyFieldLevelEncryptionConfigs "TooManyFieldLevelEncryptionConfigs"
//   The maximum number of configurations for field-level encryption have been
//   created.
//
//   * ErrCodeTooManyFieldLevelEncryptionQueryArgProfiles "TooManyFieldLevelEncryptionQueryArgProfiles"
//   The maximum number of query arg profiles for field-level encryption have
//   been created.
//
//   * ErrCodeTooManyFieldLevelEncryptionContentTypeProfiles "TooManyFieldLevelEncryptionContentTypeProfiles"
//   The maximum number of content type profiles for field-level encryption have
//   been created.
//
//   * ErrCodeQueryArgProfileEmpty "QueryArgProfileEmpty"
//   No profile specified for the field-level encryption query argument.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateFieldLevelEncryptionConfig
func (c *CloudFront) CreateFieldLevelEncryptionConfig(input *CreateFieldLevelEncryptionConfigInput) (*CreateFieldLevelEncryptionConfigOutput, error) {
	req, out := c.CreateFieldLevelEncryptionConfigRequest(input)
	return out, req.Send()
}

// CreateFieldLevelEncryptionConfigWithContext is the same as CreateFieldLevelEncryptionConfig with the addition of
// the ability to pass a context and additional request options.
//
// See CreateFieldLevelEncryptionConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) CreateFieldLevelEncryptionConfigWithContext(ctx aws.Context, input *CreateFieldLevelEncryptionConfigInput, opts ...request.Option) (*CreateFieldLevelEncryptionConfigOutput, error) {
	req, out := c.CreateFieldLevelEncryptionConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateFieldLevelEncryptionProfile = "CreateFieldLevelEncryptionProfile2019_03_26"

// CreateFieldLevelEncryptionProfileRequest generates a "aws/request.Request" representing the
// client's request for the CreateFieldLevelEncryptionProfile operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateFieldLevelEncryptionProfile for more information on using the CreateFieldLevelEncryptionProfile
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateFieldLevelEncryptionProfileRequest method.
//    req, resp := client.CreateFieldLevelEncryptionProfileRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateFieldLevelEncryptionProfile
func (c *CloudFront) CreateFieldLevelEncryptionProfileRequest(input *CreateFieldLevelEncryptionProfileInput) (req *request.Request, output *CreateFieldLevelEncryptionProfileOutput) {
	op := &request.Operation{
		Name:       opCreateFieldLevelEncryptionProfile,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/field-level-encryption-profile",
	}

	if input == nil {
		input = &CreateFieldLevelEncryptionProfileInput{}
	}

	output = &CreateFieldLevelEncryptionProfileOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateFieldLevelEncryptionProfile API operation for Amazon CloudFront.
//
// Create a field-level encryption profile.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation CreateFieldLevelEncryptionProfile for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeNoSuchPublicKey "NoSuchPublicKey"
//   The specified public key doesn't exist.
//
//   * ErrCodeFieldLevelEncryptionProfileAlreadyExists "FieldLevelEncryptionProfileAlreadyExists"
//   The specified profile for field-level encryption already exists.
//
//   * ErrCodeFieldLevelEncryptionProfileSizeExceeded "FieldLevelEncryptionProfileSizeExceeded"
//   The maximum size of a profile for field-level encryption was exceeded.
//
//   * ErrCodeTooManyFieldLevelEncryptionProfiles "TooManyFieldLevelEncryptionProfiles"
//   The maximum number of profiles for field-level encryption have been created.
//
//   * ErrCodeTooManyFieldLevelEncryptionEncryptionEntities "TooManyFieldLevelEncryptionEncryptionEntities"
//   The maximum number of encryption entities for field-level encryption have
//   been created.
//
//   * ErrCodeTooManyFieldLevelEncryptionFieldPatterns "TooManyFieldLevelEncryptionFieldPatterns"
//   The maximum number of field patterns for field-level encryption have been
//   created.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateFieldLevelEncryptionProfile
func (c *CloudFront) CreateFieldLevelEncryptionProfile(input *CreateFieldLevelEncryptionProfileInput) (*CreateFieldLevelEncryptionProfileOutput, error) {
	req, out := c.CreateFieldLevelEncryptionProfileRequest(input)
	return out, req.Send()
}

// CreateFieldLevelEncryptionProfileWithContext is the same as CreateFieldLevelEncryptionProfile with the addition of
// the ability to pass a context and additional request options.
//
// See CreateFieldLevelEncryptionProfile for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) CreateFieldLevelEncryptionProfileWithContext(ctx aws.Context, input *CreateFieldLevelEncryptionProfileInput, opts ...request.Option) (*CreateFieldLevelEncryptionProfileOutput, error) {
	req, out := c.CreateFieldLevelEncryptionProfileRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateInvalidation = "CreateInvalidation2019_03_26"

// CreateInvalidationRequest generates a "aws/request.Request" representing the
// client's request for the CreateInvalidation operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateInvalidation for more information on using the CreateInvalidation
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateInvalidationRequest method.
//    req, resp := client.CreateInvalidationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateInvalidation
func (c *CloudFront) CreateInvalidationRequest(input *CreateInvalidationInput) (req *request.Request, output *CreateInvalidationOutput) {
	op := &request.Operation{
		Name:       opCreateInvalidation,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/distribution/{DistributionId}/invalidation",
	}

	if input == nil {
		input = &CreateInvalidationInput{}
	}

	output = &CreateInvalidationOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateInvalidation API operation for Amazon CloudFront.
//
// Create a new invalidation.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation CreateInvalidation for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeMissingBody "MissingBody"
//   This operation requires a body. Ensure that the body is present and the Content-Type
//   header is set.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeNoSuchDistribution "NoSuchDistribution"
//   The specified distribution does not exist.
//
//   * ErrCodeBatchTooLarge "BatchTooLarge"
//   Invalidation batch specified is too large.
//
//   * ErrCodeTooManyInvalidationsInProgress "TooManyInvalidationsInProgress"
//   You have exceeded the maximum number of allowable InProgress invalidation
//   batch requests, or invalidation objects.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateInvalidation
func (c *CloudFront) CreateInvalidation(input *CreateInvalidationInput) (*CreateInvalidationOutput, error) {
	req, out := c.CreateInvalidationRequest(input)
	return out, req.Send()
}

// CreateInvalidationWithContext is the same as CreateInvalidation with the addition of
// the ability to pass a context and additional request options.
//
// See CreateInvalidation for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) CreateInvalidationWithContext(ctx aws.Context, input *CreateInvalidationInput, opts ...request.Option) (*CreateInvalidationOutput, error) {
	req, out := c.CreateInvalidationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreatePublicKey = "CreatePublicKey2019_03_26"

// CreatePublicKeyRequest generates a "aws/request.Request" representing the
// client's request for the CreatePublicKey operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreatePublicKey for more information on using the CreatePublicKey
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreatePublicKeyRequest method.
//    req, resp := client.CreatePublicKeyRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreatePublicKey
func (c *CloudFront) CreatePublicKeyRequest(input *CreatePublicKeyInput) (req *request.Request, output *CreatePublicKeyOutput) {
	op := &request.Operation{
		Name:       opCreatePublicKey,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/public-key",
	}

	if input == nil {
		input = &CreatePublicKeyInput{}
	}

	output = &CreatePublicKeyOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreatePublicKey API operation for Amazon CloudFront.
//
// Add a new public key to CloudFront to use, for example, for field-level encryption.
// You can add a maximum of 10 public keys with one AWS account.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation CreatePublicKey for usage and error information.
//
// Returned Error Codes:
//   * ErrCodePublicKeyAlreadyExists "PublicKeyAlreadyExists"
//   The specified public key already exists.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeTooManyPublicKeys "TooManyPublicKeys"
//   The maximum number of public keys for field-level encryption have been created.
//   To create a new public key, delete one of the existing keys.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreatePublicKey
func (c *CloudFront) CreatePublicKey(input *CreatePublicKeyInput) (*CreatePublicKeyOutput, error) {
	req, out := c.CreatePublicKeyRequest(input)
	return out, req.Send()
}

// CreatePublicKeyWithContext is the same as CreatePublicKey with the addition of
// the ability to pass a context and additional request options.
//
// See CreatePublicKey for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) CreatePublicKeyWithContext(ctx aws.Context, input *CreatePublicKeyInput, opts ...request.Option) (*CreatePublicKeyOutput, error) {
	req, out := c.CreatePublicKeyRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateStreamingDistribution = "CreateStreamingDistribution2019_03_26"

// CreateStreamingDistributionRequest generates a "aws/request.Request" representing the
// client's request for the CreateStreamingDistribution operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateStreamingDistribution for more information on using the CreateStreamingDistribution
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateStreamingDistributionRequest method.
//    req, resp := client.CreateStreamingDistributionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateStreamingDistribution
func (c *CloudFront) CreateStreamingDistributionRequest(input *CreateStreamingDistributionInput) (req *request.Request, output *CreateStreamingDistributionOutput) {
	op := &request.Operation{
		Name:       opCreateStreamingDistribution,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/streaming-distribution",
	}

	if input == nil {
		input = &CreateStreamingDistributionInput{}
	}

	output = &CreateStreamingDistributionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateStreamingDistribution API operation for Amazon CloudFront.
//
// Creates a new RTMP distribution. An RTMP distribution is similar to a web
// distribution, but an RTMP distribution streams media files using the Adobe
// Real-Time Messaging Protocol (RTMP) instead of serving files using HTTP.
//
// To create a new distribution, submit a POST request to the CloudFront API
// version/distribution resource. The request body must include a document with
// a StreamingDistributionConfig element. The response echoes the StreamingDistributionConfig
// element and returns other information about the RTMP distribution.
//
// To get the status of your request, use the GET StreamingDistribution API
// action. When the value of Enabled is true and the value of Status is Deployed,
// your distribution is ready. A distribution usually deploys in less than 15
// minutes.
//
// For more information about web distributions, see Working with RTMP Distributions
// (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-rtmp.html)
// in the Amazon CloudFront Developer Guide.
//
// Beginning with the 2012-05-05 version of the CloudFront API, we made substantial
// changes to the format of the XML document that you include in the request
// body when you create or update a web distribution or an RTMP distribution,
// and when you invalidate objects. With previous versions of the API, we discovered
// that it was too easy to accidentally delete one or more values for an element
// that accepts multiple values, for example, CNAMEs and trusted signers. Our
// changes for the 2012-05-05 release are intended to prevent these accidental
// deletions and to notify you when there's a mismatch between the number of
// values you say you're specifying in the Quantity element and the number of
// values specified.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation CreateStreamingDistribution for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeCNAMEAlreadyExists "CNAMEAlreadyExists"
//   The CNAME specified is already defined for CloudFront.
//
//   * ErrCodeStreamingDistributionAlreadyExists "StreamingDistributionAlreadyExists"
//   The caller reference you attempted to create the streaming distribution with
//   is associated with another distribution
//
//   * ErrCodeInvalidOrigin "InvalidOrigin"
//   The Amazon S3 origin server specified does not refer to a valid Amazon S3
//   bucket.
//
//   * ErrCodeInvalidOriginAccessIdentity "InvalidOriginAccessIdentity"
//   The origin access identity is not valid or doesn't exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeTooManyTrustedSigners "TooManyTrustedSigners"
//   Your request contains more trusted signers than are allowed per distribution.
//
//   * ErrCodeTrustedSignerDoesNotExist "TrustedSignerDoesNotExist"
//   One or more of your trusted signers don't exist.
//
//   * ErrCodeMissingBody "MissingBody"
//   This operation requires a body. Ensure that the body is present and the Content-Type
//   header is set.
//
//   * ErrCodeTooManyStreamingDistributionCNAMEs "TooManyStreamingDistributionCNAMEs"
//   Your request contains more CNAMEs than are allowed per distribution.
//
//   * ErrCodeTooManyStreamingDistributions "TooManyStreamingDistributions"
//   Processing your request would cause you to exceed the maximum number of streaming
//   distributions allowed.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateStreamingDistribution
func (c *CloudFront) CreateStreamingDistribution(input *CreateStreamingDistributionInput) (*CreateStreamingDistributionOutput, error) {
	req, out := c.CreateStreamingDistributionRequest(input)
	return out, req.Send()
}

// CreateStreamingDistributionWithContext is the same as CreateStreamingDistribution with the addition of
// the ability to pass a context and additional request options.
//
// See CreateStreamingDistribution for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) CreateStreamingDistributionWithContext(ctx aws.Context, input *CreateStreamingDistributionInput, opts ...request.Option) (*CreateStreamingDistributionOutput, error) {
	req, out := c.CreateStreamingDistributionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateStreamingDistributionWithTags = "CreateStreamingDistributionWithTags2019_03_26"

// CreateStreamingDistributionWithTagsRequest generates a "aws/request.Request" representing the
// client's request for the CreateStreamingDistributionWithTags operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateStreamingDistributionWithTags for more information on using the CreateStreamingDistributionWithTags
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateStreamingDistributionWithTagsRequest method.
//    req, resp := client.CreateStreamingDistributionWithTagsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateStreamingDistributionWithTags
func (c *CloudFront) CreateStreamingDistributionWithTagsRequest(input *CreateStreamingDistributionWithTagsInput) (req *request.Request, output *CreateStreamingDistributionWithTagsOutput) {
	op := &request.Operation{
		Name:       opCreateStreamingDistributionWithTags,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/streaming-distribution?WithTags",
	}

	if input == nil {
		input = &CreateStreamingDistributionWithTagsInput{}
	}

	output = &CreateStreamingDistributionWithTagsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateStreamingDistributionWithTags API operation for Amazon CloudFront.
//
// Create a new streaming distribution with tags.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation CreateStreamingDistributionWithTags for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeCNAMEAlreadyExists "CNAMEAlreadyExists"
//   The CNAME specified is already defined for CloudFront.
//
//   * ErrCodeStreamingDistributionAlreadyExists "StreamingDistributionAlreadyExists"
//   The caller reference you attempted to create the streaming distribution with
//   is associated with another distribution
//
//   * ErrCodeInvalidOrigin "InvalidOrigin"
//   The Amazon S3 origin server specified does not refer to a valid Amazon S3
//   bucket.
//
//   * ErrCodeInvalidOriginAccessIdentity "InvalidOriginAccessIdentity"
//   The origin access identity is not valid or doesn't exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeTooManyTrustedSigners "TooManyTrustedSigners"
//   Your request contains more trusted signers than are allowed per distribution.
//
//   * ErrCodeTrustedSignerDoesNotExist "TrustedSignerDoesNotExist"
//   One or more of your trusted signers don't exist.
//
//   * ErrCodeMissingBody "MissingBody"
//   This operation requires a body. Ensure that the body is present and the Content-Type
//   header is set.
//
//   * ErrCodeTooManyStreamingDistributionCNAMEs "TooManyStreamingDistributionCNAMEs"
//   Your request contains more CNAMEs than are allowed per distribution.
//
//   * ErrCodeTooManyStreamingDistributions "TooManyStreamingDistributions"
//   Processing your request would cause you to exceed the maximum number of streaming
//   distributions allowed.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
//   * ErrCodeInvalidTagging "InvalidTagging"
//   Tagging specified in the response body is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/CreateStreamingDistributionWithTags
func (c *CloudFront) CreateStreamingDistributionWithTags(input *CreateStreamingDistributionWithTagsInput) (*CreateStreamingDistributionWithTagsOutput, error) {
	req, out := c.CreateStreamingDistributionWithTagsRequest(input)
	return out, req.Send()
}

// CreateStreamingDistributionWithTagsWithContext is the same as CreateStreamingDistributionWithTags with the addition of
// the ability to pass a context and additional request options.
//
// See CreateStreamingDistributionWithTags for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) CreateStreamingDistributionWithTagsWithContext(ctx aws.Context, input *CreateStreamingDistributionWithTagsInput, opts ...request.Option) (*CreateStreamingDistributionWithTagsOutput, error) {
	req, out := c.CreateStreamingDistributionWithTagsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteCloudFrontOriginAccessIdentity = "DeleteCloudFrontOriginAccessIdentity2019_03_26"

// DeleteCloudFrontOriginAccessIdentityRequest generates a "aws/request.Request" representing the
// client's request for the DeleteCloudFrontOriginAccessIdentity operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteCloudFrontOriginAccessIdentity for more information on using the DeleteCloudFrontOriginAccessIdentity
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteCloudFrontOriginAccessIdentityRequest method.
//    req, resp := client.DeleteCloudFrontOriginAccessIdentityRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteCloudFrontOriginAccessIdentity
func (c *CloudFront) DeleteCloudFrontOriginAccessIdentityRequest(input *DeleteCloudFrontOriginAccessIdentityInput) (req *request.Request, output *DeleteCloudFrontOriginAccessIdentityOutput) {
	op := &request.Operation{
		Name:       opDeleteCloudFrontOriginAccessIdentity,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2019-03-26/origin-access-identity/cloudfront/{Id}",
	}

	if input == nil {
		input = &DeleteCloudFrontOriginAccessIdentityInput{}
	}

	output = &DeleteCloudFrontOriginAccessIdentityOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(restxml.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DeleteCloudFrontOriginAccessIdentity API operation for Amazon CloudFront.
//
// Delete an origin access identity.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation DeleteCloudFrontOriginAccessIdentity for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeNoSuchCloudFrontOriginAccessIdentity "NoSuchCloudFrontOriginAccessIdentity"
//   The specified origin access identity does not exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
//   * ErrCodeOriginAccessIdentityInUse "CloudFrontOriginAccessIdentityInUse"
//   The Origin Access Identity specified is already in use.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteCloudFrontOriginAccessIdentity
func (c *CloudFront) DeleteCloudFrontOriginAccessIdentity(input *DeleteCloudFrontOriginAccessIdentityInput) (*DeleteCloudFrontOriginAccessIdentityOutput, error) {
	req, out := c.DeleteCloudFrontOriginAccessIdentityRequest(input)
	return out, req.Send()
}

// DeleteCloudFrontOriginAccessIdentityWithContext is the same as DeleteCloudFrontOriginAccessIdentity with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteCloudFrontOriginAccessIdentity for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) DeleteCloudFrontOriginAccessIdentityWithContext(ctx aws.Context, input *DeleteCloudFrontOriginAccessIdentityInput, opts ...request.Option) (*DeleteCloudFrontOriginAccessIdentityOutput, error) {
	req, out := c.DeleteCloudFrontOriginAccessIdentityRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteDistribution = "DeleteDistribution2019_03_26"

// DeleteDistributionRequest generates a "aws/request.Request" representing the
// client's request for the DeleteDistribution operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteDistribution for more information on using the DeleteDistribution
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteDistributionRequest method.
//    req, resp := client.DeleteDistributionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteDistribution
func (c *CloudFront) DeleteDistributionRequest(input *DeleteDistributionInput) (req *request.Request, output *DeleteDistributionOutput) {
	op := &request.Operation{
		Name:       opDeleteDistribution,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2019-03-26/distribution/{Id}",
	}

	if input == nil {
		input = &DeleteDistributionInput{}
	}

	output = &DeleteDistributionOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(restxml.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DeleteDistribution API operation for Amazon CloudFront.
//
// Delete a distribution.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation DeleteDistribution for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeDistributionNotDisabled "DistributionNotDisabled"
//   The specified CloudFront distribution is not disabled. You must disable the
//   distribution before you can delete it.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeNoSuchDistribution "NoSuchDistribution"
//   The specified distribution does not exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteDistribution
func (c *CloudFront) DeleteDistribution(input *DeleteDistributionInput) (*DeleteDistributionOutput, error) {
	req, out := c.DeleteDistributionRequest(input)
	return out, req.Send()
}

// DeleteDistributionWithContext is the same as DeleteDistribution with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteDistribution for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) DeleteDistributionWithContext(ctx aws.Context, input *DeleteDistributionInput, opts ...request.Option) (*DeleteDistributionOutput, error) {
	req, out := c.DeleteDistributionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteFieldLevelEncryptionConfig = "DeleteFieldLevelEncryptionConfig2019_03_26"

// DeleteFieldLevelEncryptionConfigRequest generates a "aws/request.Request" representing the
// client's request for the DeleteFieldLevelEncryptionConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteFieldLevelEncryptionConfig for more information on using the DeleteFieldLevelEncryptionConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteFieldLevelEncryptionConfigRequest method.
//    req, resp := client.DeleteFieldLevelEncryptionConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteFieldLevelEncryptionConfig
func (c *CloudFront) DeleteFieldLevelEncryptionConfigRequest(input *DeleteFieldLevelEncryptionConfigInput) (req *request.Request, output *DeleteFieldLevelEncryptionConfigOutput) {
	op := &request.Operation{
		Name:       opDeleteFieldLevelEncryptionConfig,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2019-03-26/field-level-encryption/{Id}",
	}

	if input == nil {
		input = &DeleteFieldLevelEncryptionConfigInput{}
	}

	output = &DeleteFieldLevelEncryptionConfigOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(restxml.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DeleteFieldLevelEncryptionConfig API operation for Amazon CloudFront.
//
// Remove a field-level encryption configuration.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation DeleteFieldLevelEncryptionConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeNoSuchFieldLevelEncryptionConfig "NoSuchFieldLevelEncryptionConfig"
//   The specified configuration for field-level encryption doesn't exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
//   * ErrCodeFieldLevelEncryptionConfigInUse "FieldLevelEncryptionConfigInUse"
//   The specified configuration for field-level encryption is in use.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteFieldLevelEncryptionConfig
func (c *CloudFront) DeleteFieldLevelEncryptionConfig(input *DeleteFieldLevelEncryptionConfigInput) (*DeleteFieldLevelEncryptionConfigOutput, error) {
	req, out := c.DeleteFieldLevelEncryptionConfigRequest(input)
	return out, req.Send()
}

// DeleteFieldLevelEncryptionConfigWithContext is the same as DeleteFieldLevelEncryptionConfig with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteFieldLevelEncryptionConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) DeleteFieldLevelEncryptionConfigWithContext(ctx aws.Context, input *DeleteFieldLevelEncryptionConfigInput, opts ...request.Option) (*DeleteFieldLevelEncryptionConfigOutput, error) {
	req, out := c.DeleteFieldLevelEncryptionConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteFieldLevelEncryptionProfile = "DeleteFieldLevelEncryptionProfile2019_03_26"

// DeleteFieldLevelEncryptionProfileRequest generates a "aws/request.Request" representing the
// client's request for the DeleteFieldLevelEncryptionProfile operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteFieldLevelEncryptionProfile for more information on using the DeleteFieldLevelEncryptionProfile
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteFieldLevelEncryptionProfileRequest method.
//    req, resp := client.DeleteFieldLevelEncryptionProfileRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteFieldLevelEncryptionProfile
func (c *CloudFront) DeleteFieldLevelEncryptionProfileRequest(input *DeleteFieldLevelEncryptionProfileInput) (req *request.Request, output *DeleteFieldLevelEncryptionProfileOutput) {
	op := &request.Operation{
		Name:       opDeleteFieldLevelEncryptionProfile,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2019-03-26/field-level-encryption-profile/{Id}",
	}

	if input == nil {
		input = &DeleteFieldLevelEncryptionProfileInput{}
	}

	output = &DeleteFieldLevelEncryptionProfileOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(restxml.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DeleteFieldLevelEncryptionProfile API operation for Amazon CloudFront.
//
// Remove a field-level encryption profile.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation DeleteFieldLevelEncryptionProfile for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeNoSuchFieldLevelEncryptionProfile "NoSuchFieldLevelEncryptionProfile"
//   The specified profile for field-level encryption doesn't exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
//   * ErrCodeFieldLevelEncryptionProfileInUse "FieldLevelEncryptionProfileInUse"
//   The specified profile for field-level encryption is in use.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteFieldLevelEncryptionProfile
func (c *CloudFront) DeleteFieldLevelEncryptionProfile(input *DeleteFieldLevelEncryptionProfileInput) (*DeleteFieldLevelEncryptionProfileOutput, error) {
	req, out := c.DeleteFieldLevelEncryptionProfileRequest(input)
	return out, req.Send()
}

// DeleteFieldLevelEncryptionProfileWithContext is the same as DeleteFieldLevelEncryptionProfile with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteFieldLevelEncryptionProfile for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) DeleteFieldLevelEncryptionProfileWithContext(ctx aws.Context, input *DeleteFieldLevelEncryptionProfileInput, opts ...request.Option) (*DeleteFieldLevelEncryptionProfileOutput, error) {
	req, out := c.DeleteFieldLevelEncryptionProfileRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeletePublicKey = "DeletePublicKey2019_03_26"

// DeletePublicKeyRequest generates a "aws/request.Request" representing the
// client's request for the DeletePublicKey operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeletePublicKey for more information on using the DeletePublicKey
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeletePublicKeyRequest method.
//    req, resp := client.DeletePublicKeyRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeletePublicKey
func (c *CloudFront) DeletePublicKeyRequest(input *DeletePublicKeyInput) (req *request.Request, output *DeletePublicKeyOutput) {
	op := &request.Operation{
		Name:       opDeletePublicKey,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2019-03-26/public-key/{Id}",
	}

	if input == nil {
		input = &DeletePublicKeyInput{}
	}

	output = &DeletePublicKeyOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(restxml.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DeletePublicKey API operation for Amazon CloudFront.
//
// Remove a public key you previously added to CloudFront.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation DeletePublicKey for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodePublicKeyInUse "PublicKeyInUse"
//   The specified public key is in use.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeNoSuchPublicKey "NoSuchPublicKey"
//   The specified public key doesn't exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeletePublicKey
func (c *CloudFront) DeletePublicKey(input *DeletePublicKeyInput) (*DeletePublicKeyOutput, error) {
	req, out := c.DeletePublicKeyRequest(input)
	return out, req.Send()
}

// DeletePublicKeyWithContext is the same as DeletePublicKey with the addition of
// the ability to pass a context and additional request options.
//
// See DeletePublicKey for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) DeletePublicKeyWithContext(ctx aws.Context, input *DeletePublicKeyInput, opts ...request.Option) (*DeletePublicKeyOutput, error) {
	req, out := c.DeletePublicKeyRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteStreamingDistribution = "DeleteStreamingDistribution2019_03_26"

// DeleteStreamingDistributionRequest generates a "aws/request.Request" representing the
// client's request for the DeleteStreamingDistribution operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteStreamingDistribution for more information on using the DeleteStreamingDistribution
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteStreamingDistributionRequest method.
//    req, resp := client.DeleteStreamingDistributionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteStreamingDistribution
func (c *CloudFront) DeleteStreamingDistributionRequest(input *DeleteStreamingDistributionInput) (req *request.Request, output *DeleteStreamingDistributionOutput) {
	op := &request.Operation{
		Name:       opDeleteStreamingDistribution,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2019-03-26/streaming-distribution/{Id}",
	}

	if input == nil {
		input = &DeleteStreamingDistributionInput{}
	}

	output = &DeleteStreamingDistributionOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(restxml.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DeleteStreamingDistribution API operation for Amazon CloudFront.
//
// Delete a streaming distribution. To delete an RTMP distribution using the
// CloudFront API, perform the following steps.
//
// To delete an RTMP distribution using the CloudFront API:
//
// Disable the RTMP distribution.
//
// Submit a GET Streaming Distribution Config request to get the current configuration
// and the Etag header for the distribution.
//
// Update the XML document that was returned in the response to your GET Streaming
// Distribution Config request to change the value of Enabled to false.
//
// Submit a PUT Streaming Distribution Config request to update the configuration
// for your distribution. In the request body, include the XML document that
// you updated in Step 3. Then set the value of the HTTP If-Match header to
// the value of the ETag header that CloudFront returned when you submitted
// the GET Streaming Distribution Config request in Step 2.
//
// Review the response to the PUT Streaming Distribution Config request to confirm
// that the distribution was successfully disabled.
//
// Submit a GET Streaming Distribution Config request to confirm that your changes
// have propagated. When propagation is complete, the value of Status is Deployed.
//
// Submit a DELETE Streaming Distribution request. Set the value of the HTTP
// If-Match header to the value of the ETag header that CloudFront returned
// when you submitted the GET Streaming Distribution Config request in Step
// 2.
//
// Review the response to your DELETE Streaming Distribution request to confirm
// that the distribution was successfully deleted.
//
// For information about deleting a distribution using the CloudFront console,
// see Deleting a Distribution (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html)
// in the Amazon CloudFront Developer Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation DeleteStreamingDistribution for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeStreamingDistributionNotDisabled "StreamingDistributionNotDisabled"
//   The specified CloudFront distribution is not disabled. You must disable the
//   distribution before you can delete it.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeNoSuchStreamingDistribution "NoSuchStreamingDistribution"
//   The specified streaming distribution does not exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/DeleteStreamingDistribution
func (c *CloudFront) DeleteStreamingDistribution(input *DeleteStreamingDistributionInput) (*DeleteStreamingDistributionOutput, error) {
	req, out := c.DeleteStreamingDistributionRequest(input)
	return out, req.Send()
}

// DeleteStreamingDistributionWithContext is the same as DeleteStreamingDistribution with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteStreamingDistribution for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) DeleteStreamingDistributionWithContext(ctx aws.Context, input *DeleteStreamingDistributionInput, opts ...request.Option) (*DeleteStreamingDistributionOutput, error) {
	req, out := c.DeleteStreamingDistributionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetCloudFrontOriginAccessIdentity = "GetCloudFrontOriginAccessIdentity2019_03_26"

// GetCloudFrontOriginAccessIdentityRequest generates a "aws/request.Request" representing the
// client's request for the GetCloudFrontOriginAccessIdentity operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetCloudFrontOriginAccessIdentity for more information on using the GetCloudFrontOriginAccessIdentity
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCloudFrontOriginAccessIdentityRequest method.
//    req, resp := client.GetCloudFrontOriginAccessIdentityRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetCloudFrontOriginAccessIdentity
func (c *CloudFront) GetCloudFrontOriginAccessIdentityRequest(input *GetCloudFrontOriginAccessIdentityInput) (req *request.Request, output *GetCloudFrontOriginAccessIdentityOutput) {
	op := &request.Operation{
		Name:       opGetCloudFrontOriginAccessIdentity,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/origin-access-identity/cloudfront/{Id}",
	}

	if input == nil {
		input = &GetCloudFrontOriginAccessIdentityInput{}
	}

	output = &GetCloudFrontOriginAccessIdentityOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetCloudFrontOriginAccessIdentity API operation for Amazon CloudFront.
//
// Get the information about an origin access identity.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetCloudFrontOriginAccessIdentity for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeNoSuchCloudFrontOriginAccessIdentity "NoSuchCloudFrontOriginAccessIdentity"
//   The specified origin access identity does not exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetCloudFrontOriginAccessIdentity
func (c *CloudFront) GetCloudFrontOriginAccessIdentity(input *GetCloudFrontOriginAccessIdentityInput) (*GetCloudFrontOriginAccessIdentityOutput, error) {
	req, out := c.GetCloudFrontOriginAccessIdentityRequest(input)
	return out, req.Send()
}

// GetCloudFrontOriginAccessIdentityWithContext is the same as GetCloudFrontOriginAccessIdentity with the addition of
// the ability to pass a context and additional request options.
//
// See GetCloudFrontOriginAccessIdentity for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetCloudFrontOriginAccessIdentityWithContext(ctx aws.Context, input *GetCloudFrontOriginAccessIdentityInput, opts ...request.Option) (*GetCloudFrontOriginAccessIdentityOutput, error) {
	req, out := c.GetCloudFrontOriginAccessIdentityRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetCloudFrontOriginAccessIdentityConfig = "GetCloudFrontOriginAccessIdentityConfig2019_03_26"

// GetCloudFrontOriginAccessIdentityConfigRequest generates a "aws/request.Request" representing the
// client's request for the GetCloudFrontOriginAccessIdentityConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetCloudFrontOriginAccessIdentityConfig for more information on using the GetCloudFrontOriginAccessIdentityConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCloudFrontOriginAccessIdentityConfigRequest method.
//    req, resp := client.GetCloudFrontOriginAccessIdentityConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetCloudFrontOriginAccessIdentityConfig
func (c *CloudFront) GetCloudFrontOriginAccessIdentityConfigRequest(input *GetCloudFrontOriginAccessIdentityConfigInput) (req *request.Request, output *GetCloudFrontOriginAccessIdentityConfigOutput) {
	op := &request.Operation{
		Name:       opGetCloudFrontOriginAccessIdentityConfig,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/origin-access-identity/cloudfront/{Id}/config",
	}

	if input == nil {
		input = &GetCloudFrontOriginAccessIdentityConfigInput{}
	}

	output = &GetCloudFrontOriginAccessIdentityConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetCloudFrontOriginAccessIdentityConfig API operation for Amazon CloudFront.
//
// Get the configuration information about an origin access identity.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetCloudFrontOriginAccessIdentityConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeNoSuchCloudFrontOriginAccessIdentity "NoSuchCloudFrontOriginAccessIdentity"
//   The specified origin access identity does not exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetCloudFrontOriginAccessIdentityConfig
func (c *CloudFront) GetCloudFrontOriginAccessIdentityConfig(input *GetCloudFrontOriginAccessIdentityConfigInput) (*GetCloudFrontOriginAccessIdentityConfigOutput, error) {
	req, out := c.GetCloudFrontOriginAccessIdentityConfigRequest(input)
	return out, req.Send()
}

// GetCloudFrontOriginAccessIdentityConfigWithContext is the same as GetCloudFrontOriginAccessIdentityConfig with the addition of
// the ability to pass a context and additional request options.
//
// See GetCloudFrontOriginAccessIdentityConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetCloudFrontOriginAccessIdentityConfigWithContext(ctx aws.Context, input *GetCloudFrontOriginAccessIdentityConfigInput, opts ...request.Option) (*GetCloudFrontOriginAccessIdentityConfigOutput, error) {
	req, out := c.GetCloudFrontOriginAccessIdentityConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetDistribution = "GetDistribution2019_03_26"

// GetDistributionRequest generates a "aws/request.Request" representing the
// client's request for the GetDistribution operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetDistribution for more information on using the GetDistribution
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetDistributionRequest method.
//    req, resp := client.GetDistributionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetDistribution
func (c *CloudFront) GetDistributionRequest(input *GetDistributionInput) (req *request.Request, output *GetDistributionOutput) {
	op := &request.Operation{
		Name:       opGetDistribution,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/distribution/{Id}",
	}

	if input == nil {
		input = &GetDistributionInput{}
	}

	output = &GetDistributionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetDistribution API operation for Amazon CloudFront.
//
// Get the information about a distribution.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetDistribution for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeNoSuchDistribution "NoSuchDistribution"
//   The specified distribution does not exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetDistribution
func (c *CloudFront) GetDistribution(input *GetDistributionInput) (*GetDistributionOutput, error) {
	req, out := c.GetDistributionRequest(input)
	return out, req.Send()
}

// GetDistributionWithContext is the same as GetDistribution with the addition of
// the ability to pass a context and additional request options.
//
// See GetDistribution for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetDistributionWithContext(ctx aws.Context, input *GetDistributionInput, opts ...request.Option) (*GetDistributionOutput, error) {
	req, out := c.GetDistributionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetDistributionConfig = "GetDistributionConfig2019_03_26"

// GetDistributionConfigRequest generates a "aws/request.Request" representing the
// client's request for the GetDistributionConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetDistributionConfig for more information on using the GetDistributionConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetDistributionConfigRequest method.
//    req, resp := client.GetDistributionConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetDistributionConfig
func (c *CloudFront) GetDistributionConfigRequest(input *GetDistributionConfigInput) (req *request.Request, output *GetDistributionConfigOutput) {
	op := &request.Operation{
		Name:       opGetDistributionConfig,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/distribution/{Id}/config",
	}

	if input == nil {
		input = &GetDistributionConfigInput{}
	}

	output = &GetDistributionConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetDistributionConfig API operation for Amazon CloudFront.
//
// Get the configuration information about a distribution.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetDistributionConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeNoSuchDistribution "NoSuchDistribution"
//   The specified distribution does not exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetDistributionConfig
func (c *CloudFront) GetDistributionConfig(input *GetDistributionConfigInput) (*GetDistributionConfigOutput, error) {
	req, out := c.GetDistributionConfigRequest(input)
	return out, req.Send()
}

// GetDistributionConfigWithContext is the same as GetDistributionConfig with the addition of
// the ability to pass a context and additional request options.
//
// See GetDistributionConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetDistributionConfigWithContext(ctx aws.Context, input *GetDistributionConfigInput, opts ...request.Option) (*GetDistributionConfigOutput, error) {
	req, out := c.GetDistributionConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetFieldLevelEncryption = "GetFieldLevelEncryption2019_03_26"

// GetFieldLevelEncryptionRequest generates a "aws/request.Request" representing the
// client's request for the GetFieldLevelEncryption operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetFieldLevelEncryption for more information on using the GetFieldLevelEncryption
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetFieldLevelEncryptionRequest method.
//    req, resp := client.GetFieldLevelEncryptionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetFieldLevelEncryption
func (c *CloudFront) GetFieldLevelEncryptionRequest(input *GetFieldLevelEncryptionInput) (req *request.Request, output *GetFieldLevelEncryptionOutput) {
	op := &request.Operation{
		Name:       opGetFieldLevelEncryption,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/field-level-encryption/{Id}",
	}

	if input == nil {
		input = &GetFieldLevelEncryptionInput{}
	}

	output = &GetFieldLevelEncryptionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetFieldLevelEncryption API operation for Amazon CloudFront.
//
// Get the field-level encryption configuration information.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetFieldLevelEncryption for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeNoSuchFieldLevelEncryptionConfig "NoSuchFieldLevelEncryptionConfig"
//   The specified configuration for field-level encryption doesn't exist.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetFieldLevelEncryption
func (c *CloudFront) GetFieldLevelEncryption(input *GetFieldLevelEncryptionInput) (*GetFieldLevelEncryptionOutput, error) {
	req, out := c.GetFieldLevelEncryptionRequest(input)
	return out, req.Send()
}

// GetFieldLevelEncryptionWithContext is the same as GetFieldLevelEncryption with the addition of
// the ability to pass a context and additional request options.
//
// See GetFieldLevelEncryption for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetFieldLevelEncryptionWithContext(ctx aws.Context, input *GetFieldLevelEncryptionInput, opts ...request.Option) (*GetFieldLevelEncryptionOutput, error) {
	req, out := c.GetFieldLevelEncryptionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetFieldLevelEncryptionConfig = "GetFieldLevelEncryptionConfig2019_03_26"

// GetFieldLevelEncryptionConfigRequest generates a "aws/request.Request" representing the
// client's request for the GetFieldLevelEncryptionConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetFieldLevelEncryptionConfig for more information on using the GetFieldLevelEncryptionConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetFieldLevelEncryptionConfigRequest method.
//    req, resp := client.GetFieldLevelEncryptionConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetFieldLevelEncryptionConfig
func (c *CloudFront) GetFieldLevelEncryptionConfigRequest(input *GetFieldLevelEncryptionConfigInput) (req *request.Request, output *GetFieldLevelEncryptionConfigOutput) {
	op := &request.Operation{
		Name:       opGetFieldLevelEncryptionConfig,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/field-level-encryption/{Id}/config",
	}

	if input == nil {
		input = &GetFieldLevelEncryptionConfigInput{}
	}

	output = &GetFieldLevelEncryptionConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetFieldLevelEncryptionConfig API operation for Amazon CloudFront.
//
// Get the field-level encryption configuration information.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetFieldLevelEncryptionConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeNoSuchFieldLevelEncryptionConfig "NoSuchFieldLevelEncryptionConfig"
//   The specified configuration for field-level encryption doesn't exist.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetFieldLevelEncryptionConfig
func (c *CloudFront) GetFieldLevelEncryptionConfig(input *GetFieldLevelEncryptionConfigInput) (*GetFieldLevelEncryptionConfigOutput, error) {
	req, out := c.GetFieldLevelEncryptionConfigRequest(input)
	return out, req.Send()
}

// GetFieldLevelEncryptionConfigWithContext is the same as GetFieldLevelEncryptionConfig with the addition of
// the ability to pass a context and additional request options.
//
// See GetFieldLevelEncryptionConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetFieldLevelEncryptionConfigWithContext(ctx aws.Context, input *GetFieldLevelEncryptionConfigInput, opts ...request.Option) (*GetFieldLevelEncryptionConfigOutput, error) {
	req, out := c.GetFieldLevelEncryptionConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetFieldLevelEncryptionProfile = "GetFieldLevelEncryptionProfile2019_03_26"

// GetFieldLevelEncryptionProfileRequest generates a "aws/request.Request" representing the
// client's request for the GetFieldLevelEncryptionProfile operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetFieldLevelEncryptionProfile for more information on using the GetFieldLevelEncryptionProfile
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetFieldLevelEncryptionProfileRequest method.
//    req, resp := client.GetFieldLevelEncryptionProfileRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetFieldLevelEncryptionProfile
func (c *CloudFront) GetFieldLevelEncryptionProfileRequest(input *GetFieldLevelEncryptionProfileInput) (req *request.Request, output *GetFieldLevelEncryptionProfileOutput) {
	op := &request.Operation{
		Name:       opGetFieldLevelEncryptionProfile,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/field-level-encryption-profile/{Id}",
	}

	if input == nil {
		input = &GetFieldLevelEncryptionProfileInput{}
	}

	output = &GetFieldLevelEncryptionProfileOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetFieldLevelEncryptionProfile API operation for Amazon CloudFront.
//
// Get the field-level encryption profile information.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetFieldLevelEncryptionProfile for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeNoSuchFieldLevelEncryptionProfile "NoSuchFieldLevelEncryptionProfile"
//   The specified profile for field-level encryption doesn't exist.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetFieldLevelEncryptionProfile
func (c *CloudFront) GetFieldLevelEncryptionProfile(input *GetFieldLevelEncryptionProfileInput) (*GetFieldLevelEncryptionProfileOutput, error) {
	req, out := c.GetFieldLevelEncryptionProfileRequest(input)
	return out, req.Send()
}

// GetFieldLevelEncryptionProfileWithContext is the same as GetFieldLevelEncryptionProfile with the addition of
// the ability to pass a context and additional request options.
//
// See GetFieldLevelEncryptionProfile for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetFieldLevelEncryptionProfileWithContext(ctx aws.Context, input *GetFieldLevelEncryptionProfileInput, opts ...request.Option) (*GetFieldLevelEncryptionProfileOutput, error) {
	req, out := c.GetFieldLevelEncryptionProfileRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetFieldLevelEncryptionProfileConfig = "GetFieldLevelEncryptionProfileConfig2019_03_26"

// GetFieldLevelEncryptionProfileConfigRequest generates a "aws/request.Request" representing the
// client's request for the GetFieldLevelEncryptionProfileConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetFieldLevelEncryptionProfileConfig for more information on using the GetFieldLevelEncryptionProfileConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetFieldLevelEncryptionProfileConfigRequest method.
//    req, resp := client.GetFieldLevelEncryptionProfileConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetFieldLevelEncryptionProfileConfig
func (c *CloudFront) GetFieldLevelEncryptionProfileConfigRequest(input *GetFieldLevelEncryptionProfileConfigInput) (req *request.Request, output *GetFieldLevelEncryptionProfileConfigOutput) {
	op := &request.Operation{
		Name:       opGetFieldLevelEncryptionProfileConfig,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/field-level-encryption-profile/{Id}/config",
	}

	if input == nil {
		input = &GetFieldLevelEncryptionProfileConfigInput{}
	}

	output = &GetFieldLevelEncryptionProfileConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetFieldLevelEncryptionProfileConfig API operation for Amazon CloudFront.
//
// Get the field-level encryption profile configuration information.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetFieldLevelEncryptionProfileConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeNoSuchFieldLevelEncryptionProfile "NoSuchFieldLevelEncryptionProfile"
//   The specified profile for field-level encryption doesn't exist.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetFieldLevelEncryptionProfileConfig
func (c *CloudFront) GetFieldLevelEncryptionProfileConfig(input *GetFieldLevelEncryptionProfileConfigInput) (*GetFieldLevelEncryptionProfileConfigOutput, error) {
	req, out := c.GetFieldLevelEncryptionProfileConfigRequest(input)
	return out, req.Send()
}

// GetFieldLevelEncryptionProfileConfigWithContext is the same as GetFieldLevelEncryptionProfileConfig with the addition of
// the ability to pass a context and additional request options.
//
// See GetFieldLevelEncryptionProfileConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetFieldLevelEncryptionProfileConfigWithContext(ctx aws.Context, input *GetFieldLevelEncryptionProfileConfigInput, opts ...request.Option) (*GetFieldLevelEncryptionProfileConfigOutput, error) {
	req, out := c.GetFieldLevelEncryptionProfileConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetInvalidation = "GetInvalidation2019_03_26"

// GetInvalidationRequest generates a "aws/request.Request" representing the
// client's request for the GetInvalidation operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetInvalidation for more information on using the GetInvalidation
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetInvalidationRequest method.
//    req, resp := client.GetInvalidationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetInvalidation
func (c *CloudFront) GetInvalidationRequest(input *GetInvalidationInput) (req *request.Request, output *GetInvalidationOutput) {
	op := &request.Operation{
		Name:       opGetInvalidation,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/distribution/{DistributionId}/invalidation/{Id}",
	}

	if input == nil {
		input = &GetInvalidationInput{}
	}

	output = &GetInvalidationOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetInvalidation API operation for Amazon CloudFront.
//
// Get the information about an invalidation.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetInvalidation for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeNoSuchInvalidation "NoSuchInvalidation"
//   The specified invalidation does not exist.
//
//   * ErrCodeNoSuchDistribution "NoSuchDistribution"
//   The specified distribution does not exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetInvalidation
func (c *CloudFront) GetInvalidation(input *GetInvalidationInput) (*GetInvalidationOutput, error) {
	req, out := c.GetInvalidationRequest(input)
	return out, req.Send()
}

// GetInvalidationWithContext is the same as GetInvalidation with the addition of
// the ability to pass a context and additional request options.
//
// See GetInvalidation for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetInvalidationWithContext(ctx aws.Context, input *GetInvalidationInput, opts ...request.Option) (*GetInvalidationOutput, error) {
	req, out := c.GetInvalidationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetPublicKey = "GetPublicKey2019_03_26"

// GetPublicKeyRequest generates a "aws/request.Request" representing the
// client's request for the GetPublicKey operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetPublicKey for more information on using the GetPublicKey
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetPublicKeyRequest method.
//    req, resp := client.GetPublicKeyRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetPublicKey
func (c *CloudFront) GetPublicKeyRequest(input *GetPublicKeyInput) (req *request.Request, output *GetPublicKeyOutput) {
	op := &request.Operation{
		Name:       opGetPublicKey,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/public-key/{Id}",
	}

	if input == nil {
		input = &GetPublicKeyInput{}
	}

	output = &GetPublicKeyOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetPublicKey API operation for Amazon CloudFront.
//
// Get the public key information.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetPublicKey for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeNoSuchPublicKey "NoSuchPublicKey"
//   The specified public key doesn't exist.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetPublicKey
func (c *CloudFront) GetPublicKey(input *GetPublicKeyInput) (*GetPublicKeyOutput, error) {
	req, out := c.GetPublicKeyRequest(input)
	return out, req.Send()
}

// GetPublicKeyWithContext is the same as GetPublicKey with the addition of
// the ability to pass a context and additional request options.
//
// See GetPublicKey for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetPublicKeyWithContext(ctx aws.Context, input *GetPublicKeyInput, opts ...request.Option) (*GetPublicKeyOutput, error) {
	req, out := c.GetPublicKeyRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetPublicKeyConfig = "GetPublicKeyConfig2019_03_26"

// GetPublicKeyConfigRequest generates a "aws/request.Request" representing the
// client's request for the GetPublicKeyConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetPublicKeyConfig for more information on using the GetPublicKeyConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetPublicKeyConfigRequest method.
//    req, resp := client.GetPublicKeyConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetPublicKeyConfig
func (c *CloudFront) GetPublicKeyConfigRequest(input *GetPublicKeyConfigInput) (req *request.Request, output *GetPublicKeyConfigOutput) {
	op := &request.Operation{
		Name:       opGetPublicKeyConfig,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/public-key/{Id}/config",
	}

	if input == nil {
		input = &GetPublicKeyConfigInput{}
	}

	output = &GetPublicKeyConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetPublicKeyConfig API operation for Amazon CloudFront.
//
// Return public key configuration informaation
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetPublicKeyConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeNoSuchPublicKey "NoSuchPublicKey"
//   The specified public key doesn't exist.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetPublicKeyConfig
func (c *CloudFront) GetPublicKeyConfig(input *GetPublicKeyConfigInput) (*GetPublicKeyConfigOutput, error) {
	req, out := c.GetPublicKeyConfigRequest(input)
	return out, req.Send()
}

// GetPublicKeyConfigWithContext is the same as GetPublicKeyConfig with the addition of
// the ability to pass a context and additional request options.
//
// See GetPublicKeyConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetPublicKeyConfigWithContext(ctx aws.Context, input *GetPublicKeyConfigInput, opts ...request.Option) (*GetPublicKeyConfigOutput, error) {
	req, out := c.GetPublicKeyConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetStreamingDistribution = "GetStreamingDistribution2019_03_26"

// GetStreamingDistributionRequest generates a "aws/request.Request" representing the
// client's request for the GetStreamingDistribution operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetStreamingDistribution for more information on using the GetStreamingDistribution
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetStreamingDistributionRequest method.
//    req, resp := client.GetStreamingDistributionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetStreamingDistribution
func (c *CloudFront) GetStreamingDistributionRequest(input *GetStreamingDistributionInput) (req *request.Request, output *GetStreamingDistributionOutput) {
	op := &request.Operation{
		Name:       opGetStreamingDistribution,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/streaming-distribution/{Id}",
	}

	if input == nil {
		input = &GetStreamingDistributionInput{}
	}

	output = &GetStreamingDistributionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetStreamingDistribution API operation for Amazon CloudFront.
//
// Gets information about a specified RTMP distribution, including the distribution
// configuration.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetStreamingDistribution for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeNoSuchStreamingDistribution "NoSuchStreamingDistribution"
//   The specified streaming distribution does not exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetStreamingDistribution
func (c *CloudFront) GetStreamingDistribution(input *GetStreamingDistributionInput) (*GetStreamingDistributionOutput, error) {
	req, out := c.GetStreamingDistributionRequest(input)
	return out, req.Send()
}

// GetStreamingDistributionWithContext is the same as GetStreamingDistribution with the addition of
// the ability to pass a context and additional request options.
//
// See GetStreamingDistribution for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetStreamingDistributionWithContext(ctx aws.Context, input *GetStreamingDistributionInput, opts ...request.Option) (*GetStreamingDistributionOutput, error) {
	req, out := c.GetStreamingDistributionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetStreamingDistributionConfig = "GetStreamingDistributionConfig2019_03_26"

// GetStreamingDistributionConfigRequest generates a "aws/request.Request" representing the
// client's request for the GetStreamingDistributionConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetStreamingDistributionConfig for more information on using the GetStreamingDistributionConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetStreamingDistributionConfigRequest method.
//    req, resp := client.GetStreamingDistributionConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetStreamingDistributionConfig
func (c *CloudFront) GetStreamingDistributionConfigRequest(input *GetStreamingDistributionConfigInput) (req *request.Request, output *GetStreamingDistributionConfigOutput) {
	op := &request.Operation{
		Name:       opGetStreamingDistributionConfig,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/streaming-distribution/{Id}/config",
	}

	if input == nil {
		input = &GetStreamingDistributionConfigInput{}
	}

	output = &GetStreamingDistributionConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetStreamingDistributionConfig API operation for Amazon CloudFront.
//
// Get the configuration information about a streaming distribution.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation GetStreamingDistributionConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeNoSuchStreamingDistribution "NoSuchStreamingDistribution"
//   The specified streaming distribution does not exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/GetStreamingDistributionConfig
func (c *CloudFront) GetStreamingDistributionConfig(input *GetStreamingDistributionConfigInput) (*GetStreamingDistributionConfigOutput, error) {
	req, out := c.GetStreamingDistributionConfigRequest(input)
	return out, req.Send()
}

// GetStreamingDistributionConfigWithContext is the same as GetStreamingDistributionConfig with the addition of
// the ability to pass a context and additional request options.
//
// See GetStreamingDistributionConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) GetStreamingDistributionConfigWithContext(ctx aws.Context, input *GetStreamingDistributionConfigInput, opts ...request.Option) (*GetStreamingDistributionConfigOutput, error) {
	req, out := c.GetStreamingDistributionConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListCloudFrontOriginAccessIdentities = "ListCloudFrontOriginAccessIdentities2019_03_26"

// ListCloudFrontOriginAccessIdentitiesRequest generates a "aws/request.Request" representing the
// client's request for the ListCloudFrontOriginAccessIdentities operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListCloudFrontOriginAccessIdentities for more information on using the ListCloudFrontOriginAccessIdentities
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListCloudFrontOriginAccessIdentitiesRequest method.
//    req, resp := client.ListCloudFrontOriginAccessIdentitiesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListCloudFrontOriginAccessIdentities
func (c *CloudFront) ListCloudFrontOriginAccessIdentitiesRequest(input *ListCloudFrontOriginAccessIdentitiesInput) (req *request.Request, output *ListCloudFrontOriginAccessIdentitiesOutput) {
	op := &request.Operation{
		Name:       opListCloudFrontOriginAccessIdentities,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/origin-access-identity/cloudfront",
		Paginator: &request.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"CloudFrontOriginAccessIdentityList.NextMarker"},
			LimitToken:      "MaxItems",
			TruncationToken: "CloudFrontOriginAccessIdentityList.IsTruncated",
		},
	}

	if input == nil {
		input = &ListCloudFrontOriginAccessIdentitiesInput{}
	}

	output = &ListCloudFrontOriginAccessIdentitiesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListCloudFrontOriginAccessIdentities API operation for Amazon CloudFront.
//
// Lists origin access identities.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation ListCloudFrontOriginAccessIdentities for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListCloudFrontOriginAccessIdentities
func (c *CloudFront) ListCloudFrontOriginAccessIdentities(input *ListCloudFrontOriginAccessIdentitiesInput) (*ListCloudFrontOriginAccessIdentitiesOutput, error) {
	req, out := c.ListCloudFrontOriginAccessIdentitiesRequest(input)
	return out, req.Send()
}

// ListCloudFrontOriginAccessIdentitiesWithContext is the same as ListCloudFrontOriginAccessIdentities with the addition of
// the ability to pass a context and additional request options.
//
// See ListCloudFrontOriginAccessIdentities for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListCloudFrontOriginAccessIdentitiesWithContext(ctx aws.Context, input *ListCloudFrontOriginAccessIdentitiesInput, opts ...request.Option) (*ListCloudFrontOriginAccessIdentitiesOutput, error) {
	req, out := c.ListCloudFrontOriginAccessIdentitiesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListCloudFrontOriginAccessIdentitiesPages iterates over the pages of a ListCloudFrontOriginAccessIdentities operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListCloudFrontOriginAccessIdentities method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListCloudFrontOriginAccessIdentities operation.
//    pageNum := 0
//    err := client.ListCloudFrontOriginAccessIdentitiesPages(params,
//        func(page *cloudfront.ListCloudFrontOriginAccessIdentitiesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CloudFront) ListCloudFrontOriginAccessIdentitiesPages(input *ListCloudFrontOriginAccessIdentitiesInput, fn func(*ListCloudFrontOriginAccessIdentitiesOutput, bool) bool) error {
	return c.ListCloudFrontOriginAccessIdentitiesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListCloudFrontOriginAccessIdentitiesPagesWithContext same as ListCloudFrontOriginAccessIdentitiesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListCloudFrontOriginAccessIdentitiesPagesWithContext(ctx aws.Context, input *ListCloudFrontOriginAccessIdentitiesInput, fn func(*ListCloudFrontOriginAccessIdentitiesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListCloudFrontOriginAccessIdentitiesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListCloudFrontOriginAccessIdentitiesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListCloudFrontOriginAccessIdentitiesOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListDistributions = "ListDistributions2019_03_26"

// ListDistributionsRequest generates a "aws/request.Request" representing the
// client's request for the ListDistributions operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListDistributions for more information on using the ListDistributions
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListDistributionsRequest method.
//    req, resp := client.ListDistributionsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListDistributions
func (c *CloudFront) ListDistributionsRequest(input *ListDistributionsInput) (req *request.Request, output *ListDistributionsOutput) {
	op := &request.Operation{
		Name:       opListDistributions,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/distribution",
		Paginator: &request.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"DistributionList.NextMarker"},
			LimitToken:      "MaxItems",
			TruncationToken: "DistributionList.IsTruncated",
		},
	}

	if input == nil {
		input = &ListDistributionsInput{}
	}

	output = &ListDistributionsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListDistributions API operation for Amazon CloudFront.
//
// List CloudFront distributions.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation ListDistributions for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListDistributions
func (c *CloudFront) ListDistributions(input *ListDistributionsInput) (*ListDistributionsOutput, error) {
	req, out := c.ListDistributionsRequest(input)
	return out, req.Send()
}

// ListDistributionsWithContext is the same as ListDistributions with the addition of
// the ability to pass a context and additional request options.
//
// See ListDistributions for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListDistributionsWithContext(ctx aws.Context, input *ListDistributionsInput, opts ...request.Option) (*ListDistributionsOutput, error) {
	req, out := c.ListDistributionsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListDistributionsPages iterates over the pages of a ListDistributions operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListDistributions method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListDistributions operation.
//    pageNum := 0
//    err := client.ListDistributionsPages(params,
//        func(page *cloudfront.ListDistributionsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CloudFront) ListDistributionsPages(input *ListDistributionsInput, fn func(*ListDistributionsOutput, bool) bool) error {
	return c.ListDistributionsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListDistributionsPagesWithContext same as ListDistributionsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListDistributionsPagesWithContext(ctx aws.Context, input *ListDistributionsInput, fn func(*ListDistributionsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListDistributionsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListDistributionsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListDistributionsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListDistributionsByWebACLId = "ListDistributionsByWebACLId2019_03_26"

// ListDistributionsByWebACLIdRequest generates a "aws/request.Request" representing the
// client's request for the ListDistributionsByWebACLId operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListDistributionsByWebACLId for more information on using the ListDistributionsByWebACLId
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListDistributionsByWebACLIdRequest method.
//    req, resp := client.ListDistributionsByWebACLIdRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListDistributionsByWebACLId
func (c *CloudFront) ListDistributionsByWebACLIdRequest(input *ListDistributionsByWebACLIdInput) (req *request.Request, output *ListDistributionsByWebACLIdOutput) {
	op := &request.Operation{
		Name:       opListDistributionsByWebACLId,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/distributionsByWebACLId/{WebACLId}",
	}

	if input == nil {
		input = &ListDistributionsByWebACLIdInput{}
	}

	output = &ListDistributionsByWebACLIdOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListDistributionsByWebACLId API operation for Amazon CloudFront.
//
// List the distributions that are associated with a specified AWS WAF web ACL.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation ListDistributionsByWebACLId for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidWebACLId "InvalidWebACLId"
//   A web ACL id specified in the response body is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListDistributionsByWebACLId
func (c *CloudFront) ListDistributionsByWebACLId(input *ListDistributionsByWebACLIdInput) (*ListDistributionsByWebACLIdOutput, error) {
	req, out := c.ListDistributionsByWebACLIdRequest(input)
	return out, req.Send()
}

// ListDistributionsByWebACLIdWithContext is the same as ListDistributionsByWebACLId with the addition of
// the ability to pass a context and additional request options.
//
// See ListDistributionsByWebACLId for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListDistributionsByWebACLIdWithContext(ctx aws.Context, input *ListDistributionsByWebACLIdInput, opts ...request.Option) (*ListDistributionsByWebACLIdOutput, error) {
	req, out := c.ListDistributionsByWebACLIdRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListFieldLevelEncryptionConfigs = "ListFieldLevelEncryptionConfigs2019_03_26"

// ListFieldLevelEncryptionConfigsRequest generates a "aws/request.Request" representing the
// client's request for the ListFieldLevelEncryptionConfigs operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListFieldLevelEncryptionConfigs for more information on using the ListFieldLevelEncryptionConfigs
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListFieldLevelEncryptionConfigsRequest method.
//    req, resp := client.ListFieldLevelEncryptionConfigsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListFieldLevelEncryptionConfigs
func (c *CloudFront) ListFieldLevelEncryptionConfigsRequest(input *ListFieldLevelEncryptionConfigsInput) (req *request.Request, output *ListFieldLevelEncryptionConfigsOutput) {
	op := &request.Operation{
		Name:       opListFieldLevelEncryptionConfigs,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/field-level-encryption",
	}

	if input == nil {
		input = &ListFieldLevelEncryptionConfigsInput{}
	}

	output = &ListFieldLevelEncryptionConfigsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListFieldLevelEncryptionConfigs API operation for Amazon CloudFront.
//
// List all field-level encryption configurations that have been created in
// CloudFront for this account.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation ListFieldLevelEncryptionConfigs for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListFieldLevelEncryptionConfigs
func (c *CloudFront) ListFieldLevelEncryptionConfigs(input *ListFieldLevelEncryptionConfigsInput) (*ListFieldLevelEncryptionConfigsOutput, error) {
	req, out := c.ListFieldLevelEncryptionConfigsRequest(input)
	return out, req.Send()
}

// ListFieldLevelEncryptionConfigsWithContext is the same as ListFieldLevelEncryptionConfigs with the addition of
// the ability to pass a context and additional request options.
//
// See ListFieldLevelEncryptionConfigs for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListFieldLevelEncryptionConfigsWithContext(ctx aws.Context, input *ListFieldLevelEncryptionConfigsInput, opts ...request.Option) (*ListFieldLevelEncryptionConfigsOutput, error) {
	req, out := c.ListFieldLevelEncryptionConfigsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListFieldLevelEncryptionProfiles = "ListFieldLevelEncryptionProfiles2019_03_26"

// ListFieldLevelEncryptionProfilesRequest generates a "aws/request.Request" representing the
// client's request for the ListFieldLevelEncryptionProfiles operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListFieldLevelEncryptionProfiles for more information on using the ListFieldLevelEncryptionProfiles
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListFieldLevelEncryptionProfilesRequest method.
//    req, resp := client.ListFieldLevelEncryptionProfilesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListFieldLevelEncryptionProfiles
func (c *CloudFront) ListFieldLevelEncryptionProfilesRequest(input *ListFieldLevelEncryptionProfilesInput) (req *request.Request, output *ListFieldLevelEncryptionProfilesOutput) {
	op := &request.Operation{
		Name:       opListFieldLevelEncryptionProfiles,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/field-level-encryption-profile",
	}

	if input == nil {
		input = &ListFieldLevelEncryptionProfilesInput{}
	}

	output = &ListFieldLevelEncryptionProfilesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListFieldLevelEncryptionProfiles API operation for Amazon CloudFront.
//
// Request a list of field-level encryption profiles that have been created
// in CloudFront for this account.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation ListFieldLevelEncryptionProfiles for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListFieldLevelEncryptionProfiles
func (c *CloudFront) ListFieldLevelEncryptionProfiles(input *ListFieldLevelEncryptionProfilesInput) (*ListFieldLevelEncryptionProfilesOutput, error) {
	req, out := c.ListFieldLevelEncryptionProfilesRequest(input)
	return out, req.Send()
}

// ListFieldLevelEncryptionProfilesWithContext is the same as ListFieldLevelEncryptionProfiles with the addition of
// the ability to pass a context and additional request options.
//
// See ListFieldLevelEncryptionProfiles for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListFieldLevelEncryptionProfilesWithContext(ctx aws.Context, input *ListFieldLevelEncryptionProfilesInput, opts ...request.Option) (*ListFieldLevelEncryptionProfilesOutput, error) {
	req, out := c.ListFieldLevelEncryptionProfilesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListInvalidations = "ListInvalidations2019_03_26"

// ListInvalidationsRequest generates a "aws/request.Request" representing the
// client's request for the ListInvalidations operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListInvalidations for more information on using the ListInvalidations
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListInvalidationsRequest method.
//    req, resp := client.ListInvalidationsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListInvalidations
func (c *CloudFront) ListInvalidationsRequest(input *ListInvalidationsInput) (req *request.Request, output *ListInvalidationsOutput) {
	op := &request.Operation{
		Name:       opListInvalidations,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/distribution/{DistributionId}/invalidation",
		Paginator: &request.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"InvalidationList.NextMarker"},
			LimitToken:      "MaxItems",
			TruncationToken: "InvalidationList.IsTruncated",
		},
	}

	if input == nil {
		input = &ListInvalidationsInput{}
	}

	output = &ListInvalidationsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListInvalidations API operation for Amazon CloudFront.
//
// Lists invalidation batches.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation ListInvalidations for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeNoSuchDistribution "NoSuchDistribution"
//   The specified distribution does not exist.
//
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListInvalidations
func (c *CloudFront) ListInvalidations(input *ListInvalidationsInput) (*ListInvalidationsOutput, error) {
	req, out := c.ListInvalidationsRequest(input)
	return out, req.Send()
}

// ListInvalidationsWithContext is the same as ListInvalidations with the addition of
// the ability to pass a context and additional request options.
//
// See ListInvalidations for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListInvalidationsWithContext(ctx aws.Context, input *ListInvalidationsInput, opts ...request.Option) (*ListInvalidationsOutput, error) {
	req, out := c.ListInvalidationsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListInvalidationsPages iterates over the pages of a ListInvalidations operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListInvalidations method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListInvalidations operation.
//    pageNum := 0
//    err := client.ListInvalidationsPages(params,
//        func(page *cloudfront.ListInvalidationsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CloudFront) ListInvalidationsPages(input *ListInvalidationsInput, fn func(*ListInvalidationsOutput, bool) bool) error {
	return c.ListInvalidationsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListInvalidationsPagesWithContext same as ListInvalidationsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListInvalidationsPagesWithContext(ctx aws.Context, input *ListInvalidationsInput, fn func(*ListInvalidationsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListInvalidationsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListInvalidationsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListInvalidationsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListPublicKeys = "ListPublicKeys2019_03_26"

// ListPublicKeysRequest generates a "aws/request.Request" representing the
// client's request for the ListPublicKeys operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListPublicKeys for more information on using the ListPublicKeys
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListPublicKeysRequest method.
//    req, resp := client.ListPublicKeysRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListPublicKeys
func (c *CloudFront) ListPublicKeysRequest(input *ListPublicKeysInput) (req *request.Request, output *ListPublicKeysOutput) {
	op := &request.Operation{
		Name:       opListPublicKeys,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/public-key",
	}

	if input == nil {
		input = &ListPublicKeysInput{}
	}

	output = &ListPublicKeysOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListPublicKeys API operation for Amazon CloudFront.
//
// List all public keys that have been added to CloudFront for this account.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation ListPublicKeys for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListPublicKeys
func (c *CloudFront) ListPublicKeys(input *ListPublicKeysInput) (*ListPublicKeysOutput, error) {
	req, out := c.ListPublicKeysRequest(input)
	return out, req.Send()
}

// ListPublicKeysWithContext is the same as ListPublicKeys with the addition of
// the ability to pass a context and additional request options.
//
// See ListPublicKeys for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListPublicKeysWithContext(ctx aws.Context, input *ListPublicKeysInput, opts ...request.Option) (*ListPublicKeysOutput, error) {
	req, out := c.ListPublicKeysRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListStreamingDistributions = "ListStreamingDistributions2019_03_26"

// ListStreamingDistributionsRequest generates a "aws/request.Request" representing the
// client's request for the ListStreamingDistributions operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListStreamingDistributions for more information on using the ListStreamingDistributions
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListStreamingDistributionsRequest method.
//    req, resp := client.ListStreamingDistributionsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListStreamingDistributions
func (c *CloudFront) ListStreamingDistributionsRequest(input *ListStreamingDistributionsInput) (req *request.Request, output *ListStreamingDistributionsOutput) {
	op := &request.Operation{
		Name:       opListStreamingDistributions,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/streaming-distribution",
		Paginator: &request.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"StreamingDistributionList.NextMarker"},
			LimitToken:      "MaxItems",
			TruncationToken: "StreamingDistributionList.IsTruncated",
		},
	}

	if input == nil {
		input = &ListStreamingDistributionsInput{}
	}

	output = &ListStreamingDistributionsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListStreamingDistributions API operation for Amazon CloudFront.
//
// List streaming distributions.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation ListStreamingDistributions for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListStreamingDistributions
func (c *CloudFront) ListStreamingDistributions(input *ListStreamingDistributionsInput) (*ListStreamingDistributionsOutput, error) {
	req, out := c.ListStreamingDistributionsRequest(input)
	return out, req.Send()
}

// ListStreamingDistributionsWithContext is the same as ListStreamingDistributions with the addition of
// the ability to pass a context and additional request options.
//
// See ListStreamingDistributions for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListStreamingDistributionsWithContext(ctx aws.Context, input *ListStreamingDistributionsInput, opts ...request.Option) (*ListStreamingDistributionsOutput, error) {
	req, out := c.ListStreamingDistributionsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListStreamingDistributionsPages iterates over the pages of a ListStreamingDistributions operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListStreamingDistributions method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListStreamingDistributions operation.
//    pageNum := 0
//    err := client.ListStreamingDistributionsPages(params,
//        func(page *cloudfront.ListStreamingDistributionsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CloudFront) ListStreamingDistributionsPages(input *ListStreamingDistributionsInput, fn func(*ListStreamingDistributionsOutput, bool) bool) error {
	return c.ListStreamingDistributionsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListStreamingDistributionsPagesWithContext same as ListStreamingDistributionsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListStreamingDistributionsPagesWithContext(ctx aws.Context, input *ListStreamingDistributionsInput, fn func(*ListStreamingDistributionsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListStreamingDistributionsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListStreamingDistributionsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListStreamingDistributionsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListTagsForResource = "ListTagsForResource2019_03_26"

// ListTagsForResourceRequest generates a "aws/request.Request" representing the
// client's request for the ListTagsForResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListTagsForResource for more information on using the ListTagsForResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListTagsForResourceRequest method.
//    req, resp := client.ListTagsForResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListTagsForResource
func (c *CloudFront) ListTagsForResourceRequest(input *ListTagsForResourceInput) (req *request.Request, output *ListTagsForResourceOutput) {
	op := &request.Operation{
		Name:       opListTagsForResource,
		HTTPMethod: "GET",
		HTTPPath:   "/2019-03-26/tagging",
	}

	if input == nil {
		input = &ListTagsForResourceInput{}
	}

	output = &ListTagsForResourceOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListTagsForResource API operation for Amazon CloudFront.
//
// List tags for a CloudFront resource.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation ListTagsForResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidTagging "InvalidTagging"
//   Tagging specified in the response body is not valid.
//
//   * ErrCodeNoSuchResource "NoSuchResource"
//   A resource that was specified is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/ListTagsForResource
func (c *CloudFront) ListTagsForResource(input *ListTagsForResourceInput) (*ListTagsForResourceOutput, error) {
	req, out := c.ListTagsForResourceRequest(input)
	return out, req.Send()
}

// ListTagsForResourceWithContext is the same as ListTagsForResource with the addition of
// the ability to pass a context and additional request options.
//
// See ListTagsForResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) ListTagsForResourceWithContext(ctx aws.Context, input *ListTagsForResourceInput, opts ...request.Option) (*ListTagsForResourceOutput, error) {
	req, out := c.ListTagsForResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opTagResource = "TagResource2019_03_26"

// TagResourceRequest generates a "aws/request.Request" representing the
// client's request for the TagResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See TagResource for more information on using the TagResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the TagResourceRequest method.
//    req, resp := client.TagResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/TagResource
func (c *CloudFront) TagResourceRequest(input *TagResourceInput) (req *request.Request, output *TagResourceOutput) {
	op := &request.Operation{
		Name:       opTagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/tagging?Operation=Tag",
	}

	if input == nil {
		input = &TagResourceInput{}
	}

	output = &TagResourceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(restxml.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// TagResource API operation for Amazon CloudFront.
//
// Add tags to a CloudFront resource.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation TagResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidTagging "InvalidTagging"
//   Tagging specified in the response body is not valid.
//
//   * ErrCodeNoSuchResource "NoSuchResource"
//   A resource that was specified is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/TagResource
func (c *CloudFront) TagResource(input *TagResourceInput) (*TagResourceOutput, error) {
	req, out := c.TagResourceRequest(input)
	return out, req.Send()
}

// TagResourceWithContext is the same as TagResource with the addition of
// the ability to pass a context and additional request options.
//
// See TagResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) TagResourceWithContext(ctx aws.Context, input *TagResourceInput, opts ...request.Option) (*TagResourceOutput, error) {
	req, out := c.TagResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUntagResource = "UntagResource2019_03_26"

// UntagResourceRequest generates a "aws/request.Request" representing the
// client's request for the UntagResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UntagResource for more information on using the UntagResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UntagResourceRequest method.
//    req, resp := client.UntagResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UntagResource
func (c *CloudFront) UntagResourceRequest(input *UntagResourceInput) (req *request.Request, output *UntagResourceOutput) {
	op := &request.Operation{
		Name:       opUntagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/2019-03-26/tagging?Operation=Untag",
	}

	if input == nil {
		input = &UntagResourceInput{}
	}

	output = &UntagResourceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(restxml.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// UntagResource API operation for Amazon CloudFront.
//
// Remove tags from a CloudFront resource.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation UntagResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidTagging "InvalidTagging"
//   Tagging specified in the response body is not valid.
//
//   * ErrCodeNoSuchResource "NoSuchResource"
//   A resource that was specified is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UntagResource
func (c *CloudFront) UntagResource(input *UntagResourceInput) (*UntagResourceOutput, error) {
	req, out := c.UntagResourceRequest(input)
	return out, req.Send()
}

// UntagResourceWithContext is the same as UntagResource with the addition of
// the ability to pass a context and additional request options.
//
// See UntagResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) UntagResourceWithContext(ctx aws.Context, input *UntagResourceInput, opts ...request.Option) (*UntagResourceOutput, error) {
	req, out := c.UntagResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateCloudFrontOriginAccessIdentity = "UpdateCloudFrontOriginAccessIdentity2019_03_26"

// UpdateCloudFrontOriginAccessIdentityRequest generates a "aws/request.Request" representing the
// client's request for the UpdateCloudFrontOriginAccessIdentity operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateCloudFrontOriginAccessIdentity for more information on using the UpdateCloudFrontOriginAccessIdentity
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateCloudFrontOriginAccessIdentityRequest method.
//    req, resp := client.UpdateCloudFrontOriginAccessIdentityRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateCloudFrontOriginAccessIdentity
func (c *CloudFront) UpdateCloudFrontOriginAccessIdentityRequest(input *UpdateCloudFrontOriginAccessIdentityInput) (req *request.Request, output *UpdateCloudFrontOriginAccessIdentityOutput) {
	op := &request.Operation{
		Name:       opUpdateCloudFrontOriginAccessIdentity,
		HTTPMethod: "PUT",
		HTTPPath:   "/2019-03-26/origin-access-identity/cloudfront/{Id}/config",
	}

	if input == nil {
		input = &UpdateCloudFrontOriginAccessIdentityInput{}
	}

	output = &UpdateCloudFrontOriginAccessIdentityOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateCloudFrontOriginAccessIdentity API operation for Amazon CloudFront.
//
// Update an origin access identity.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation UpdateCloudFrontOriginAccessIdentity for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeIllegalUpdate "IllegalUpdate"
//   Origin and CallerReference cannot be updated.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeMissingBody "MissingBody"
//   This operation requires a body. Ensure that the body is present and the Content-Type
//   header is set.
//
//   * ErrCodeNoSuchCloudFrontOriginAccessIdentity "NoSuchCloudFrontOriginAccessIdentity"
//   The specified origin access identity does not exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateCloudFrontOriginAccessIdentity
func (c *CloudFront) UpdateCloudFrontOriginAccessIdentity(input *UpdateCloudFrontOriginAccessIdentityInput) (*UpdateCloudFrontOriginAccessIdentityOutput, error) {
	req, out := c.UpdateCloudFrontOriginAccessIdentityRequest(input)
	return out, req.Send()
}

// UpdateCloudFrontOriginAccessIdentityWithContext is the same as UpdateCloudFrontOriginAccessIdentity with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateCloudFrontOriginAccessIdentity for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) UpdateCloudFrontOriginAccessIdentityWithContext(ctx aws.Context, input *UpdateCloudFrontOriginAccessIdentityInput, opts ...request.Option) (*UpdateCloudFrontOriginAccessIdentityOutput, error) {
	req, out := c.UpdateCloudFrontOriginAccessIdentityRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateDistribution = "UpdateDistribution2019_03_26"

// UpdateDistributionRequest generates a "aws/request.Request" representing the
// client's request for the UpdateDistribution operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateDistribution for more information on using the UpdateDistribution
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateDistributionRequest method.
//    req, resp := client.UpdateDistributionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateDistribution
func (c *CloudFront) UpdateDistributionRequest(input *UpdateDistributionInput) (req *request.Request, output *UpdateDistributionOutput) {
	op := &request.Operation{
		Name:       opUpdateDistribution,
		HTTPMethod: "PUT",
		HTTPPath:   "/2019-03-26/distribution/{Id}/config",
	}

	if input == nil {
		input = &UpdateDistributionInput{}
	}

	output = &UpdateDistributionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateDistribution API operation for Amazon CloudFront.
//
// Updates the configuration for a web distribution.
//
// When you update a distribution, there are more required fields than when
// you create a distribution. When you update your distribution by using this
// API action, follow the steps here to get the current configuration and then
// make your updates, to make sure that you include all of the required fields.
// To view a summary, see Required Fields for Create Distribution and Update
// Distribution (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html)
// in the Amazon CloudFront Developer Guide.
//
// The update process includes getting the current distribution configuration,
// updating the XML document that is returned to make your changes, and then
// submitting an UpdateDistribution request to make the updates.
//
// For information about updating a distribution using the CloudFront console
// instead, see Creating a Distribution (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-creating-console.html)
// in the Amazon CloudFront Developer Guide.
//
// To update a web distribution using the CloudFront API
//
// Submit a GetDistributionConfig (https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistributionConfig.html)
// request to get the current configuration and an Etag header for the distribution.
//
// If you update the distribution again, you must get a new Etag header.
//
// Update the XML document that was returned in the response to your GetDistributionConfig
// request to include your changes.
//
// When you edit the XML file, be aware of the following:
//
//    * You must strip out the ETag parameter that is returned.
//
//    * Additional fields are required when you update a distribution. There
//    may be fields included in the XML file for features that you haven't configured
//    for your distribution. This is expected and required to successfully update
//    the distribution.
//
//    * You can't change the value of CallerReference. If you try to change
//    this value, CloudFront returns an IllegalUpdate error.
//
//    * The new configuration replaces the existing configuration; the values
//    that you specify in an UpdateDistribution request are not merged into
//    your existing configuration. When you add, delete, or replace values in
//    an element that allows multiple values (for example, CNAME), you must
//    specify all of the values that you want to appear in the updated distribution.
//    In addition, you must update the corresponding Quantity element.
//
// Submit an UpdateDistribution request to update the configuration for your
// distribution:
//
//    * In the request body, include the XML document that you updated in Step
//    2. The request body must include an XML document with a DistributionConfig
//    element.
//
//    * Set the value of the HTTP If-Match header to the value of the ETag header
//    that CloudFront returned when you submitted the GetDistributionConfig
//    request in Step 1.
//
// Review the response to the UpdateDistribution request to confirm that the
// configuration was successfully updated.
//
// Optional: Submit a GetDistribution (https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistribution.html)
// request to confirm that your changes have propagated. When propagation is
// complete, the value of Status is Deployed.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation UpdateDistribution for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeCNAMEAlreadyExists "CNAMEAlreadyExists"
//   The CNAME specified is already defined for CloudFront.
//
//   * ErrCodeIllegalUpdate "IllegalUpdate"
//   Origin and CallerReference cannot be updated.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeMissingBody "MissingBody"
//   This operation requires a body. Ensure that the body is present and the Content-Type
//   header is set.
//
//   * ErrCodeNoSuchDistribution "NoSuchDistribution"
//   The specified distribution does not exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
//   * ErrCodeTooManyDistributionCNAMEs "TooManyDistributionCNAMEs"
//   Your request contains more CNAMEs than are allowed per distribution.
//
//   * ErrCodeInvalidDefaultRootObject "InvalidDefaultRootObject"
//   The default root object file name is too big or contains an invalid character.
//
//   * ErrCodeInvalidRelativePath "InvalidRelativePath"
//   The relative path is too big, is not URL-encoded, or does not begin with
//   a slash (/).
//
//   * ErrCodeInvalidErrorCode "InvalidErrorCode"
//   An invalid error code was specified.
//
//   * ErrCodeInvalidResponseCode "InvalidResponseCode"
//   A response code specified in the response body is not valid.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidOriginAccessIdentity "InvalidOriginAccessIdentity"
//   The origin access identity is not valid or doesn't exist.
//
//   * ErrCodeTooManyTrustedSigners "TooManyTrustedSigners"
//   Your request contains more trusted signers than are allowed per distribution.
//
//   * ErrCodeTrustedSignerDoesNotExist "TrustedSignerDoesNotExist"
//   One or more of your trusted signers don't exist.
//
//   * ErrCodeInvalidViewerCertificate "InvalidViewerCertificate"
//   A viewer certificate specified in the response body is not valid.
//
//   * ErrCodeInvalidMinimumProtocolVersion "InvalidMinimumProtocolVersion"
//   The minimum protocol version specified is not valid.
//
//   * ErrCodeInvalidRequiredProtocol "InvalidRequiredProtocol"
//   This operation requires the HTTPS protocol. Ensure that you specify the HTTPS
//   protocol in your request, or omit the RequiredProtocols element from your
//   distribution configuration.
//
//   * ErrCodeNoSuchOrigin "NoSuchOrigin"
//   No origin exists with the specified Origin Id.
//
//   * ErrCodeTooManyOrigins "TooManyOrigins"
//   You cannot create more origins for the distribution.
//
//   * ErrCodeTooManyOriginGroupsPerDistribution "TooManyOriginGroupsPerDistribution"
//   Processing your request would cause you to exceed the maximum number of origin
//   groups allowed.
//
//   * ErrCodeTooManyCacheBehaviors "TooManyCacheBehaviors"
//   You cannot create more cache behaviors for the distribution.
//
//   * ErrCodeTooManyCookieNamesInWhiteList "TooManyCookieNamesInWhiteList"
//   Your request contains more cookie names in the whitelist than are allowed
//   per cache behavior.
//
//   * ErrCodeInvalidForwardCookies "InvalidForwardCookies"
//   Your request contains forward cookies option which doesn't match with the
//   expectation for the whitelisted list of cookie names. Either list of cookie
//   names has been specified when not allowed or list of cookie names is missing
//   when expected.
//
//   * ErrCodeTooManyHeadersInForwardedValues "TooManyHeadersInForwardedValues"
//   Your request contains too many headers in forwarded values.
//
//   * ErrCodeInvalidHeadersForS3Origin "InvalidHeadersForS3Origin"
//   The headers specified are not valid for an Amazon S3 origin.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
//   * ErrCodeTooManyCertificates "TooManyCertificates"
//   You cannot create anymore custom SSL/TLS certificates.
//
//   * ErrCodeInvalidLocationCode "InvalidLocationCode"
//   The location code specified is not valid.
//
//   * ErrCodeInvalidGeoRestrictionParameter "InvalidGeoRestrictionParameter"
//   The specified geo restriction parameter is not valid.
//
//   * ErrCodeInvalidTTLOrder "InvalidTTLOrder"
//   TTL order specified in the response body is not valid.
//
//   * ErrCodeInvalidWebACLId "InvalidWebACLId"
//   A web ACL id specified in the response body is not valid.
//
//   * ErrCodeTooManyOriginCustomHeaders "TooManyOriginCustomHeaders"
//   Your request contains too many origin custom headers.
//
//   * ErrCodeTooManyQueryStringParameters "TooManyQueryStringParameters"
//   Your request contains too many query string parameters.
//
//   * ErrCodeInvalidQueryStringParameters "InvalidQueryStringParameters"
//   Query string parameters specified in the response body are not valid.
//
//   * ErrCodeTooManyDistributionsWithLambdaAssociations "TooManyDistributionsWithLambdaAssociations"
//   Processing your request would cause the maximum number of distributions with
//   Lambda function associations per owner to be exceeded.
//
//   * ErrCodeTooManyLambdaFunctionAssociations "TooManyLambdaFunctionAssociations"
//   Your request contains more Lambda function associations than are allowed
//   per distribution.
//
//   * ErrCodeInvalidLambdaFunctionAssociation "InvalidLambdaFunctionAssociation"
//   The specified Lambda function association is invalid.
//
//   * ErrCodeInvalidOriginReadTimeout "InvalidOriginReadTimeout"
//   The read timeout specified for the origin is not valid.
//
//   * ErrCodeInvalidOriginKeepaliveTimeout "InvalidOriginKeepaliveTimeout"
//   The keep alive timeout specified for the origin is not valid.
//
//   * ErrCodeNoSuchFieldLevelEncryptionConfig "NoSuchFieldLevelEncryptionConfig"
//   The specified configuration for field-level encryption doesn't exist.
//
//   * ErrCodeIllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior"
//   The specified configuration for field-level encryption can't be associated
//   with the specified cache behavior.
//
//   * ErrCodeTooManyDistributionsAssociatedToFieldLevelEncryptionConfig "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig"
//   The maximum number of distributions have been associated with the specified
//   configuration for field-level encryption.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateDistribution
func (c *CloudFront) UpdateDistribution(input *UpdateDistributionInput) (*UpdateDistributionOutput, error) {
	req, out := c.UpdateDistributionRequest(input)
	return out, req.Send()
}

// UpdateDistributionWithContext is the same as UpdateDistribution with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateDistribution for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) UpdateDistributionWithContext(ctx aws.Context, input *UpdateDistributionInput, opts ...request.Option) (*UpdateDistributionOutput, error) {
	req, out := c.UpdateDistributionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateFieldLevelEncryptionConfig = "UpdateFieldLevelEncryptionConfig2019_03_26"

// UpdateFieldLevelEncryptionConfigRequest generates a "aws/request.Request" representing the
// client's request for the UpdateFieldLevelEncryptionConfig operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateFieldLevelEncryptionConfig for more information on using the UpdateFieldLevelEncryptionConfig
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateFieldLevelEncryptionConfigRequest method.
//    req, resp := client.UpdateFieldLevelEncryptionConfigRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateFieldLevelEncryptionConfig
func (c *CloudFront) UpdateFieldLevelEncryptionConfigRequest(input *UpdateFieldLevelEncryptionConfigInput) (req *request.Request, output *UpdateFieldLevelEncryptionConfigOutput) {
	op := &request.Operation{
		Name:       opUpdateFieldLevelEncryptionConfig,
		HTTPMethod: "PUT",
		HTTPPath:   "/2019-03-26/field-level-encryption/{Id}/config",
	}

	if input == nil {
		input = &UpdateFieldLevelEncryptionConfigInput{}
	}

	output = &UpdateFieldLevelEncryptionConfigOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateFieldLevelEncryptionConfig API operation for Amazon CloudFront.
//
// Update a field-level encryption configuration.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation UpdateFieldLevelEncryptionConfig for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeIllegalUpdate "IllegalUpdate"
//   Origin and CallerReference cannot be updated.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeNoSuchFieldLevelEncryptionProfile "NoSuchFieldLevelEncryptionProfile"
//   The specified profile for field-level encryption doesn't exist.
//
//   * ErrCodeNoSuchFieldLevelEncryptionConfig "NoSuchFieldLevelEncryptionConfig"
//   The specified configuration for field-level encryption doesn't exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
//   * ErrCodeTooManyFieldLevelEncryptionQueryArgProfiles "TooManyFieldLevelEncryptionQueryArgProfiles"
//   The maximum number of query arg profiles for field-level encryption have
//   been created.
//
//   * ErrCodeTooManyFieldLevelEncryptionContentTypeProfiles "TooManyFieldLevelEncryptionContentTypeProfiles"
//   The maximum number of content type profiles for field-level encryption have
//   been created.
//
//   * ErrCodeQueryArgProfileEmpty "QueryArgProfileEmpty"
//   No profile specified for the field-level encryption query argument.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateFieldLevelEncryptionConfig
func (c *CloudFront) UpdateFieldLevelEncryptionConfig(input *UpdateFieldLevelEncryptionConfigInput) (*UpdateFieldLevelEncryptionConfigOutput, error) {
	req, out := c.UpdateFieldLevelEncryptionConfigRequest(input)
	return out, req.Send()
}

// UpdateFieldLevelEncryptionConfigWithContext is the same as UpdateFieldLevelEncryptionConfig with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateFieldLevelEncryptionConfig for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) UpdateFieldLevelEncryptionConfigWithContext(ctx aws.Context, input *UpdateFieldLevelEncryptionConfigInput, opts ...request.Option) (*UpdateFieldLevelEncryptionConfigOutput, error) {
	req, out := c.UpdateFieldLevelEncryptionConfigRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateFieldLevelEncryptionProfile = "UpdateFieldLevelEncryptionProfile2019_03_26"

// UpdateFieldLevelEncryptionProfileRequest generates a "aws/request.Request" representing the
// client's request for the UpdateFieldLevelEncryptionProfile operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateFieldLevelEncryptionProfile for more information on using the UpdateFieldLevelEncryptionProfile
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateFieldLevelEncryptionProfileRequest method.
//    req, resp := client.UpdateFieldLevelEncryptionProfileRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateFieldLevelEncryptionProfile
func (c *CloudFront) UpdateFieldLevelEncryptionProfileRequest(input *UpdateFieldLevelEncryptionProfileInput) (req *request.Request, output *UpdateFieldLevelEncryptionProfileOutput) {
	op := &request.Operation{
		Name:       opUpdateFieldLevelEncryptionProfile,
		HTTPMethod: "PUT",
		HTTPPath:   "/2019-03-26/field-level-encryption-profile/{Id}/config",
	}

	if input == nil {
		input = &UpdateFieldLevelEncryptionProfileInput{}
	}

	output = &UpdateFieldLevelEncryptionProfileOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateFieldLevelEncryptionProfile API operation for Amazon CloudFront.
//
// Update a field-level encryption profile.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation UpdateFieldLevelEncryptionProfile for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeFieldLevelEncryptionProfileAlreadyExists "FieldLevelEncryptionProfileAlreadyExists"
//   The specified profile for field-level encryption already exists.
//
//   * ErrCodeIllegalUpdate "IllegalUpdate"
//   Origin and CallerReference cannot be updated.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeNoSuchPublicKey "NoSuchPublicKey"
//   The specified public key doesn't exist.
//
//   * ErrCodeNoSuchFieldLevelEncryptionProfile "NoSuchFieldLevelEncryptionProfile"
//   The specified profile for field-level encryption doesn't exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
//   * ErrCodeFieldLevelEncryptionProfileSizeExceeded "FieldLevelEncryptionProfileSizeExceeded"
//   The maximum size of a profile for field-level encryption was exceeded.
//
//   * ErrCodeTooManyFieldLevelEncryptionEncryptionEntities "TooManyFieldLevelEncryptionEncryptionEntities"
//   The maximum number of encryption entities for field-level encryption have
//   been created.
//
//   * ErrCodeTooManyFieldLevelEncryptionFieldPatterns "TooManyFieldLevelEncryptionFieldPatterns"
//   The maximum number of field patterns for field-level encryption have been
//   created.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateFieldLevelEncryptionProfile
func (c *CloudFront) UpdateFieldLevelEncryptionProfile(input *UpdateFieldLevelEncryptionProfileInput) (*UpdateFieldLevelEncryptionProfileOutput, error) {
	req, out := c.UpdateFieldLevelEncryptionProfileRequest(input)
	return out, req.Send()
}

// UpdateFieldLevelEncryptionProfileWithContext is the same as UpdateFieldLevelEncryptionProfile with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateFieldLevelEncryptionProfile for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) UpdateFieldLevelEncryptionProfileWithContext(ctx aws.Context, input *UpdateFieldLevelEncryptionProfileInput, opts ...request.Option) (*UpdateFieldLevelEncryptionProfileOutput, error) {
	req, out := c.UpdateFieldLevelEncryptionProfileRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdatePublicKey = "UpdatePublicKey2019_03_26"

// UpdatePublicKeyRequest generates a "aws/request.Request" representing the
// client's request for the UpdatePublicKey operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdatePublicKey for more information on using the UpdatePublicKey
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdatePublicKeyRequest method.
//    req, resp := client.UpdatePublicKeyRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdatePublicKey
func (c *CloudFront) UpdatePublicKeyRequest(input *UpdatePublicKeyInput) (req *request.Request, output *UpdatePublicKeyOutput) {
	op := &request.Operation{
		Name:       opUpdatePublicKey,
		HTTPMethod: "PUT",
		HTTPPath:   "/2019-03-26/public-key/{Id}/config",
	}

	if input == nil {
		input = &UpdatePublicKeyInput{}
	}

	output = &UpdatePublicKeyOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdatePublicKey API operation for Amazon CloudFront.
//
// Update public key information. Note that the only value you can change is
// the comment.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation UpdatePublicKey for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeCannotChangeImmutablePublicKeyFields "CannotChangeImmutablePublicKeyFields"
//   You can't change the value of a public key.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeIllegalUpdate "IllegalUpdate"
//   Origin and CallerReference cannot be updated.
//
//   * ErrCodeNoSuchPublicKey "NoSuchPublicKey"
//   The specified public key doesn't exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdatePublicKey
func (c *CloudFront) UpdatePublicKey(input *UpdatePublicKeyInput) (*UpdatePublicKeyOutput, error) {
	req, out := c.UpdatePublicKeyRequest(input)
	return out, req.Send()
}

// UpdatePublicKeyWithContext is the same as UpdatePublicKey with the addition of
// the ability to pass a context and additional request options.
//
// See UpdatePublicKey for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) UpdatePublicKeyWithContext(ctx aws.Context, input *UpdatePublicKeyInput, opts ...request.Option) (*UpdatePublicKeyOutput, error) {
	req, out := c.UpdatePublicKeyRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateStreamingDistribution = "UpdateStreamingDistribution2019_03_26"

// UpdateStreamingDistributionRequest generates a "aws/request.Request" representing the
// client's request for the UpdateStreamingDistribution operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateStreamingDistribution for more information on using the UpdateStreamingDistribution
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateStreamingDistributionRequest method.
//    req, resp := client.UpdateStreamingDistributionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateStreamingDistribution
func (c *CloudFront) UpdateStreamingDistributionRequest(input *UpdateStreamingDistributionInput) (req *request.Request, output *UpdateStreamingDistributionOutput) {
	op := &request.Operation{
		Name:       opUpdateStreamingDistribution,
		HTTPMethod: "PUT",
		HTTPPath:   "/2019-03-26/streaming-distribution/{Id}/config",
	}

	if input == nil {
		input = &UpdateStreamingDistributionInput{}
	}

	output = &UpdateStreamingDistributionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateStreamingDistribution API operation for Amazon CloudFront.
//
// Update a streaming distribution.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon CloudFront's
// API operation UpdateStreamingDistribution for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeAccessDenied "AccessDenied"
//   Access denied.
//
//   * ErrCodeCNAMEAlreadyExists "CNAMEAlreadyExists"
//   The CNAME specified is already defined for CloudFront.
//
//   * ErrCodeIllegalUpdate "IllegalUpdate"
//   Origin and CallerReference cannot be updated.
//
//   * ErrCodeInvalidIfMatchVersion "InvalidIfMatchVersion"
//   The If-Match version is missing or not valid for the distribution.
//
//   * ErrCodeMissingBody "MissingBody"
//   This operation requires a body. Ensure that the body is present and the Content-Type
//   header is set.
//
//   * ErrCodeNoSuchStreamingDistribution "NoSuchStreamingDistribution"
//   The specified streaming distribution does not exist.
//
//   * ErrCodePreconditionFailed "PreconditionFailed"
//   The precondition given in one or more of the request-header fields evaluated
//   to false.
//
//   * ErrCodeTooManyStreamingDistributionCNAMEs "TooManyStreamingDistributionCNAMEs"
//   Your request contains more CNAMEs than are allowed per distribution.
//
//   * ErrCodeInvalidArgument "InvalidArgument"
//   The argument is invalid.
//
//   * ErrCodeInvalidOriginAccessIdentity "InvalidOriginAccessIdentity"
//   The origin access identity is not valid or doesn't exist.
//
//   * ErrCodeTooManyTrustedSigners "TooManyTrustedSigners"
//   Your request contains more trusted signers than are allowed per distribution.
//
//   * ErrCodeTrustedSignerDoesNotExist "TrustedSignerDoesNotExist"
//   One or more of your trusted signers don't exist.
//
//   * ErrCodeInconsistentQuantities "InconsistentQuantities"
//   The value of Quantity and the size of Items don't match.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/cloudfront-2019-03-26/UpdateStreamingDistribution
func (c *CloudFront) UpdateStreamingDistribution(input *UpdateStreamingDistributionInput) (*UpdateStreamingDistributionOutput, error) {
	req, out := c.UpdateStreamingDistributionRequest(input)
	return out, req.Send()
}

// UpdateStreamingDistributionWithContext is the same as UpdateStreamingDistribution with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateStreamingDistribution for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CloudFront) UpdateStreamingDistributionWithContext(ctx aws.Context, input *UpdateStreamingDistributionInput, opts ...request.Option) (*UpdateStreamingDistributionOutput, error) {
	req, out := c.UpdateStreamingDistributionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// A complex type that lists the AWS accounts, if any, that you included in
// the TrustedSigners complex type for this distribution. These are the accounts
// that you want to allow to create signed URLs for private content.
//
// The Signer complex type lists the AWS account number of the trusted signer
// or self if the signer is the AWS account that created the distribution. The
// Signer element also includes the IDs of any active CloudFront key pairs that
// are associated with the trusted signer's AWS account. If no KeyPairId element
// appears for a Signer, that signer can't create signed URLs.
//
// For more information, see Serving Private Content through CloudFront (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html)
// in the Amazon CloudFront Developer Guide.
type ActiveTrustedSigners struct {
	_ struct{} `type:"structure"`

	// Enabled is true if any of the AWS accounts listed in the TrustedSigners complex
	// type for this distribution have active CloudFront key pairs. If not, Enabled
	// is false.
	//
	// Enabled is a required field
	Enabled *bool `type:"boolean" required:"true"`

	// A complex type that contains one Signer complex type for each trusted signer
	// that is specified in the TrustedSigners complex type.
	Items []*Signer `locationNameList:"Signer" type:"list"`

	// The number of trusted signers specified in the TrustedSigners complex type.
	//
	// Quantity is a required field
	Quantity *int64 `type:"integer" required:"true"`
}

// String returns the string representation
func (s ActiveTrustedSigners) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ActiveTrustedSigners) GoString() string {
	return s.String()
}

// SetEnabled sets the Enabled field's value.
func (s *ActiveTrustedSigners) SetEnabled(v bool) *ActiveTrustedSigners {
	s.Enabled = &v
	return s
}

// SetItems sets the Items field's value.
func (s *ActiveTrustedSigners) SetItems(v []*Signer) *ActiveTrustedSigners {
	s.Items = v
	return s
}

// SetQuantity sets the Quantity field's value.
func (s *ActiveTrustedSigners) SetQuantity(v int64) *ActiveTrustedSigners {
	s.Quantity = &v
	return s
}

// AWS services in China customers must file for an Internet Content Provider
// (ICP) recordal if they want to serve content publicly on an alternate domain
// name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal
// provides the ICP recordal status for CNAMEs associated with distributions.
// The status is returned in the CloudFront response; you can't configure it
// yourself.
//
// For more information about ICP recordals, see Signup, Accounts, and Credentials
// (https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html)
// in Getting Started with AWS services in China.
type AliasICPRecordal struct {
	_ struct{} `type:"structure"`

	// A domain name associated with a distribution.
	CNAME *string `type:"string"`

	// The Internet Content Provider (ICP) recordal status for a CNAME. The ICPRecordalStatus
	// is set to APPROVED for all CNAMEs (aliases) in regions outside of China.
	//
	// The status values returned are the following:
	//
	//    * APPROVED indicates that the associated CNAME has a valid ICP recordal
	//    number. Multiple CNAMEs can be associated with a distribution, and CNAMEs
	//    can correspond to different ICP recordals. To be marked as APPROVED, that
	//    is, valid to use with China region, a CNAME must have one ICP recordal
	//    number associated with it.
	//
	//    * SUSPENDED indicates that the associated CNAME does not have a valid
	//    ICP recordal number.
	//
	//    * PENDING indicates that at least one CNAME associated with the distribution
	//    does not have a valid ICP recordal number.
	ICPRecordalStatus *string `type:"string" enum:"ICPRecordalStatus"`
}

// String returns the string representation
func (s AliasICPRecordal) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AliasICPRecordal) GoString() string {
	return s.String()
}

// SetCNAME sets the CNAME field's value.
func (s *AliasICPRecordal) SetCNAME(v string) *AliasICPRecordal {
	s.CNAME = &v
	return s
}

// SetICPRecordalStatus sets the ICPRecordalStatus field's value.
func (s *AliasICPRecordal) SetICPRecordalStatus(v string) *AliasICPRecordal {
	s.ICPRecordalStatus = &v
	return s
}

// A complex type that contains information about CNAMEs (alternate domain names),
// if any, for this distribution.
type Aliases struct {
	_ struct{} `type:"structure"`

	// A complex type that contains the CNAME aliases, if any, that you want to
	// associate with this distribution.
	Items []*string `locationNameList:"CNAME" type:"list"`

	// The number of CNAME aliases, if any, that you want to associate with this
	// distribution.
	//
	// Quantity is a required field
	Quantity *int64 `type:"integer" required:"true"`
}

// String returns the string representation
func (s Aliases) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Aliases) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Aliases) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "Aliases"}
	if s.Quantity == nil {
		invalidParams.Add(request.NewErrParamRequired("Quantity"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetItems sets the Items field's value.
func (s *Aliases) SetItems(v []*string) *Aliases {
	s.Items = v
	return s
}

// SetQuantity sets the Quantity field's value.
func (s *Aliases) SetQuantity(v int64) *Aliases {
	s.Quantity = &v
	return s
}

// A complex type that controls which HTTP methods CloudFront processes and
// forwards to your Amazon S3 bucket or your custom origin. There are three
// choices:
//
//    * CloudFront forwards only GET and HEAD requests.
//
//    * CloudFront forwards only GET, HEAD, and OPTIONS requests.
//
//    * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE
//    requests.
//
// If you pick the third choice, you may need to restrict access to your Amazon
// S3 bucket or to your custom origin so users can't perform operations that
// you don't want them to. For example, you might not want users to have permissions
// to delete objects from your origin.
type AllowedMethods struct {
	_ struct{} `type:"structure"`

	// A complex type that controls whether CloudFront caches the response to requests
	// using the specified HTTP methods. There are two choices:
	//
	//    * CloudFront caches responses to GET and HEAD requests.
	//
	//    * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
	//
	// If you pick the second choice for your Amazon S3 Origin, you may need to
	// forward Access-Control-Request-Method, Access-Control-Request-Headers, and
	// Origin headers for the responses to be cached correctly.
	CachedMethods *CachedMethods `type:"structure"`

	// A complex type that contains the HTTP methods that you want CloudFront to
	// process and forward to your origin.
	//
	// Items is a required field
	Items []*string `locationNameList:"Method" type:"list" required:"true"`

	// The number of HTTP methods that you want CloudFront to forward to your origin.
	// Valid values are 2 (for GET and HEAD requests), 3 (for GET, HEAD, and OPTIONS
	// requests) and 7 (for GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests).
	//
	// Quantity is a required field
	Quantity *int64 `type:"integer" required:"true"`
}

// String returns the string representation
func (s AllowedMethods) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AllowedMethods) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AllowedMethods) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "AllowedMethods"}
	if s.Items == nil {
		invalidParams.Add(request.NewErrParamRequired("Items"))
	}
	if s.Quantity == nil {
		invalidParams.Add(request.NewErrParamRequired("Quantity"))
	}
	if s.CachedMethods != nil {
		if err := s.CachedMethods.Validate(); err != nil {
			invalidParams.AddNested("CachedMethods", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCachedMethods sets the CachedMethods field's value.
func (s *AllowedMethods) SetCachedMethods(v *CachedMethods) *AllowedMethods {
	s.CachedMethods = v
	return s
}

// SetItems sets the Items field's value.
func (s *AllowedMethods) SetItems(v []*string) *AllowedMethods {
	s.Items = v
	return s
}

// SetQuantity sets the Quantity field's value.
func (s *AllowedMethods) SetQuantity(v int64) *AllowedMethods {
	s.Quantity = &v
	return s
}

// A complex type that describes how CloudFront processes requests.
//
// You must create at least as many cache behaviors (including the default cache
// behavior) as you have origins if you want CloudFront to distribute objects
// from all of the origins. Each cache behavior specifies the one origin from
// which you want CloudFront to get objects. If you have two origins and only
// the default cache behavior, the default cache behavior will cause CloudFront
// to get objects from one of the origins, but the other origin is never used.
//
// For the current limit on the number of cache behaviors that you can add to
// a distribution, see Amazon CloudFront Limits (https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_cloudfront)
// in the AWS General Reference.
//
// If you don't want to specify any cache behaviors, include only an empty CacheBehaviors
// element. Don't include an empty CacheBehavior element, or CloudFront returns
// a MalformedXML error.
//
// To delete all cache behaviors in an existing distribution, update the distribution
// configuration and include only an empty CacheBehaviors element.
//
// To add, change, or remove one or more cache behaviors, update the distribution
// configuration and specify all of the cache behaviors that you want to include
// in the updated distribution.
//
// For more information about cache behaviors, see Cache Behaviors (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior)
// in the Amazon CloudFront Developer Guide.
type CacheBehavior struct {
	_ struct{} `type:"structure"`

	// A complex type that controls which HTTP methods CloudFront processes and
	// forwards to your Amazon S3 bucket or your custom origin. There are three
	// choices:
	//
	//    * CloudFront forwards only GET and HEAD requests.
	//
	//    * CloudFront forwards only GET, HEAD, and OPTIONS requests.
	//
	//    * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE
	//    requests.
	//
	// If you pick the third choice, you may need to restrict access to your Amazon
	// S3 bucket or to your custom origin so users can't perform operations that
	// you don't want them to. For example, you might not want users to have permissions
	// to delete objects from your origin.
	AllowedMethods *AllowedMethods `type:"structure"`

	// Whether you want CloudFront to automatically compress certain files for this
	// cache behavior. If so, specify true; if not, specify false. For more information,
	// see Serving Compressed Files (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html)
	// in the Amazon CloudFront Developer Guide.
	Compress *bool `type:"boolean"`

	// The default amount of time that you want objects to stay in CloudFront caches
	// before CloudFront forwards another request to your origin to determine whether
	// the object has been updated. The value that you specify applies only when
	// your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control
	// s-maxage, and Expires to objects. For more information, see Managing How
	// Long Content Stays in an Edge Cache (Expiration) (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html)
	// in the Amazon CloudFront Developer Guide.
	DefaultTTL *int64 `type:"long"`

	// The value of ID for the field-level encryption configuration that you want
	// CloudFront to use for encrypting specific fields of data for a cache behavior
	// or for the default cache behavior in your distribution.
	FieldLevelEncryptionId *string `type:"string"`

	// A complex type that specifies how CloudFront handles query strings and cookies.
	//
	// ForwardedValues is a required field
	ForwardedValues *ForwardedValues `type:"structure" required:"true"`

	// A complex type that contains zero or more Lambda function associations for
	// a cache behavior.
	LambdaFunctionAssociations *LambdaFunctionAssociations `type:"structure"`

	// The maximum amount of time that you want objects to stay in CloudFront caches
	// before CloudFront forwards another request to your origin to determine whether
	// the object has been updated. The value that you specify applies only when
	// your origin adds HTTP headers such as Cache-Control max-age, Cache-Control
	// s-maxage, and Expires to objects. For more information, see Managing How
	// Long Content Stays in an Edge Cache (Expiration) (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html)
	// in the Amazon CloudFront Developer Guide.
	MaxTTL *int64 `type:"long"`

	// The minimum amount of time that you want objects to stay in CloudFront caches
	// before CloudFront forwards another request to your origin to determine whether
	// the object has been updated. For more information, see Managing How Long
	// Content Stays in an Edge Cache (Expiration) (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html)
	// in the Amazon CloudFront Developer Guide.
	//
	// You must specify 0 for MinTTL if you configure CloudFront to forward all
	// headers to your origin (under Headers, if you specify 1 for Quantity and
	// * for Name).
	//
	// MinTTL is a required field
	MinTTL *int64 `type:"long" required:"true"`

	// The pattern (for example, images/*.jpg) that specifies which requests to
	// apply the behavior to. When CloudFront receives a viewer request, the requested
	// path is compared with path patterns in the order in which cache behaviors
	// are listed in the distribution.
	//
	// You can optionally include a slash (/) at the beginning of the path pattern.
	// For example, /images/*.jpg. CloudFront behavior is the same with or without
	// the leading /.
	//
	// The path pattern for the default cache behavior is * and cannot be changed.
	// If the request for an object does not match the path pattern for any cache
	// behaviors, CloudFront applies the behavior in the default cache behavior.
	//
	// For more information, see Path Pattern (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern)
	// in the Amazon CloudFront Developer Guide.
	//
	// PathPattern is a required field
	PathPattern *string `type:"string" required:"true"`

	// Indicates whether you want to distribute media files in the Microsoft Smooth
	// Streaming format using the origin that is associated with this cache behavior.
	// If so, specify true; if not, specify false. If you specify true for SmoothStreaming,
	// you can still distribute other content using this cache behavior if the content
	// matches the value of PathPattern.
	SmoothStreaming *bool `type:"boolean"`

	// The value of ID for the origin that you want CloudFront to route requests
	// to when a request matches the path pattern either for a cache behavior or
	// for the default cache behavior in your distribution.
	//
	// TargetOriginId is a required field
	TargetOriginId *string `type:"string" required:"true"`

	// A complex type that specifies the AWS accounts, if any, that you want to
	// allow to create signed URLs for private content.
	//
	// If you want to require signed URLs in requests for objects in the target
	// origin that match the PathPattern for this cache behavior, specify true for
	// Enabled, and specify the applicable values for Quantity and Items. For more
	// information, see Serving Private Content through CloudFront (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html)
	// in the Amazon CloudFront Developer Guide.
	//
	// If you don't want to require signed URLs in requests for objects that match
	// PathPattern, specify false for Enabled and 0 for Quantity. Omit Items.
	//
	// To add, change, or remove one or more trusted signers, change Enabled to
	// true (if it's currently false), change Quantity as applicable, and specify
	// all of the trusted signers that you want to include in the updated distribution.
	//
	// TrustedSigners is a required field
	TrustedSigners *TrustedSigners `type:"structure" required:"true"`

	// The protocol that viewers can use to access the files in the origin specified
	// by TargetOriginId when a request matches the path pattern in PathPattern.
	// You can specify the following options:
	//
	//    * allow-all: Viewers can use HTTP or HTTPS.
	//
	//    * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns
	//    an HTTP status code of 301 (Moved Permanently) to the viewer along with
	//    the HTTPS URL. The viewer then resubmits the request using the new URL.
	//
	//    * https-only: If a viewer sends an HTTP request, CloudFront returns an
	//    HTTP status code of 403 (Forbidden).
	//
	// For more information about requiring the HTTPS protocol, see Using an HTTPS
	// Connection to Access Your Objects (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/SecureConnections.html)
	// in the Amazon CloudFront Developer Guide.
	//
	// The only way to guarantee that viewers retrieve an object that was fetched
	// from the origin using HTTPS is never to use any other protocol to fetch the
	// object. If you have recently changed from HTTP to HTTPS, we recommend that
	// you clear your objects' cache because cached objects are protocol agnostic.
	// That means that an edge location will return an object from the cache regardless
	// of whether the current request protocol matches the protocol used previously.
	// For more information, see Managing How Long Content Stays in an Edge Cache
	// (Expiration) (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html)
	// in the Amazon CloudFront Developer Guide.
	//
	// ViewerProtocolPolicy is a required field
	ViewerProtocolPolicy *string `type:"string" required:"true" enum:"ViewerProtocolPolicy"`
}

// String returns the string representation
func (s CacheBehavior) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CacheBehavior) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CacheBehavior) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CacheBehavior"}
	if s.ForwardedValues == nil {
		invalidParams.Add(request.NewErrParamRequired("ForwardedValues"))
	}
	if s.MinTTL == nil {
		invalidParams.Add(request.NewErrParamRequired("MinTTL"))
	}
	if s.PathPattern == nil {
		invalidParams.Add(request.NewErrParamRequired("PathPattern"))
	}
	if s.TargetOriginId == nil {
		invalidParams.Add(request.NewErrParamRequired("TargetOriginId"))
	}
	if s.TrustedSigners == nil {
		invalidParams.Add(request.NewErrParamRequired("TrustedSigners"))
	}
	if s.ViewerProtocolPolicy == nil {
		invalidParams.Add(request.NewErrParamRequired("ViewerProtocolPolicy"))
	}
	if s.AllowedMethods != nil {
		if err := s.AllowedMethods.Validate(); err != nil {
			invalidParams.AddNested("AllowedMethods", err.(request.ErrInvalidParams))
		}
	}
	if s.ForwardedValues != nil {
		if err := s.ForwardedValues.Validate(); err != nil {
			invalidParams.AddNested("ForwardedValues", err.(request.ErrInvalidParams))
		}
	}
	if s.LambdaFunctionAssociations != nil {
		if err := s.LambdaFunctionAssociations.Validate(); err != nil {
			invalidParams.AddNested("LambdaFunctionAssociations", err.(request.ErrInvalidParams))
		}
	}
	if s.TrustedSigners != nil {
		if err := s.TrustedSigners.Validate(); err != nil {
			invalidParams.AddNested("TrustedSigners", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAllowedMethods sets the AllowedMethods field's value.
func (s *CacheBehavior) SetAllowedMethods(v *AllowedMethods) *CacheBehavior {
	s.AllowedMethods = v
	return s
}

// SetCompress sets the Compress field's value.
func (s *CacheBehavior) SetCompress(v bool) *CacheBehavior {
	s.Compress = &v
	return s
}

// SetDefaultTTL sets the DefaultTTL field's value.
func (s *CacheBehavior) SetDefaultTTL(v int64) *CacheBehavior {
	s.DefaultTTL = &v
	return s
}

// SetFieldLevelEncryptionId sets the FieldLevelEncryptionId field's value.
func (s *CacheBehavior) SetFieldLevelEncryptionId(v string) *CacheBehavior {
	s.FieldLevelEncryptionId = &v
	return s
}

// SetForwardedValues sets the ForwardedValues field's value.
func (s *CacheBehavior) SetForwardedValues(v *ForwardedValues) *CacheBehavior {
	s.ForwardedValues = v
	return s
}

// SetLambdaFunctionAssociations sets the LambdaFunctionAssociations field's value.
func (s *CacheBehavior) SetLambdaFunctionAssociations(v *LambdaFunctionAssociations) *CacheBehavior {
	s.LambdaFunctionAssociations = v
	return s
}

// SetMaxTTL sets the MaxTTL field's value.
func (s *CacheBehavior) SetMaxTTL(v int64) *CacheBehavior {
	s.MaxTTL = &v
	return s
}

// SetMinTTL sets the MinTTL field's value.
func (s *CacheBehavior) SetMinTTL(v int64) *CacheBehavior {
	s.MinTTL = &v
	return s
}

// SetPathPattern sets the PathPattern field's value.
func (s *CacheBehavior) SetPathPattern(v string) *CacheBehavior {
	s.PathPattern = &v
	return s
}

// SetSmoothStreaming sets the SmoothStreaming field's value.
func (s *CacheBehavior) SetSmoothStreaming(v bool) *CacheBehavior {
	s.SmoothStreaming = &v
	return s
}

// SetTargetOriginId sets the TargetOriginId field's value.
func (s *CacheBehavior) SetTargetOriginId(v string) *CacheBehavior {
	s.TargetOriginId = &v
	return s
}

// SetTrustedSigners sets the TrustedSigners field's value.
func (s *CacheBehavior) SetTrustedSigners(v *TrustedSigners) *CacheBehavior {
	s.TrustedSigners = v
	return s
}

// SetViewerProtocolPolicy sets the ViewerProtocolPolicy field's value.
func (s *CacheBehavior) SetViewerProtocolPolicy(v string) *CacheBehavior {
	s.ViewerProtocolPolicy = &v
	return s
}

// A complex type that contains zero or more CacheBehavior elements.
type CacheBehaviors struct {
	_ struct{} `type:"structure"`

	// Optional: A complex type that contains cache behaviors for this distribution.
	// If Quantity is 0, you can omit Items.
	Items []*CacheBehavior `locationNameList:"CacheBehavior" type:"list"`

	// The number of cache behaviors for this distribution.
	//
	// Quantity is a required field
	Quantity *int64 `type:"integer" required:"true"`
}

// String returns the string representation
func (s CacheBehaviors) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CacheBehaviors) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CacheBehaviors) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CacheBehaviors"}
	if s.Quantity == nil {
		invalidParams.Add(request.NewErrParamRequired("Quantity"))
	}
	if s.Items != nil {
		for i, v := range s.Items {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Items", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetItems sets the Items field's value.
func (s *CacheBehaviors) SetItems(v []*CacheBehavior) *CacheBehaviors {
	s.Items = v
	return s
}

// SetQuantity sets the Quantity field's value.
func (s *CacheBehaviors) SetQuantity(v int64) *CacheBehaviors {
	s.Quantity = &v
	return s
}

// A complex type that controls whether CloudFront caches the response to requests
// using the specified HTTP methods. There are two choices:
//
//    * CloudFront caches responses to GET and HEAD requests.
//
//    * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
//
// If you pick the second choice for your Amazon S3 Origin, you may need to
// forward Access-Control-Request-Method, Access-Control-Request-Headers, and
// Origin headers for the responses to be cached correctly.
type CachedMethods struct {
	_ struct{} `type:"structure"`

	// A complex type that contains the HTTP methods that you want CloudFront to
	// cache responses to.
	//
	// Items is a required field
	Items []*string `locationNameList:"Method" type:"list" required:"true"`

	// The number of HTTP methods for which you want CloudFront to cache responses.
	// Valid values are 2 (for caching responses to GET and HEAD requests) and 3
	// (for caching responses to GET, HEAD, and OPTIONS requests).
	//
	// Quantity is a required field
	Quantity *int64 `type:"integer" required:"true"`
}

// String returns the string representation
func (s CachedMethods) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CachedMethods) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CachedMethods) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CachedMethods"}
	if s.Items == nil {
		invalidParams.Add(request.NewErrParamRequired("Items"))
	}
	if s.Quantity == nil {
		invalidParams.Add(request.NewErrParamRequired("Quantity"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetItems sets the Items field's value.
func (s *CachedMethods) SetItems(v []*string) *CachedMethods {
	s.Items = v
	return s
}

// SetQuantity sets the Quantity field's value.
func (s *CachedMethods) SetQuantity(v int64) *CachedMethods {
	s.Quantity = &v
	return s
}

// A field-level encryption content type profile.
type ContentTypeProfile struct {
	_ struct{} `type:"structure"`

	// The content type for a field-level encryption content type-profile mapping.
	//
	// ContentType is a required field
	ContentType *string `type:"string" required:"true"`

	// The format for a field-level encryption content type-profile mapping.
	//
	// Format is a required field
	Format *string `type:"string" required:"true" enum:"Format"`

	// The profile ID for a field-level encryption content type-profile mapping.
	ProfileId *string `type:"string"`
}

// String returns the string representation
func (s ContentTypeProfile) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContentTypeProfile) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ContentTypeProfile) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ContentTypeProfile"}
	if s.ContentType == nil {
		invalidParams.Add(request.NewErrParamRequired("ContentType"))
	}
	if s.Format == nil {
		invalidParams.Add(request.NewErrParamRequired("Format"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetContentType sets the ContentType field's value.
func (s *ContentTypeProfile) SetContentType(v string) *ContentTypeProfile {
	s.ContentType = &v
	return s
}

// SetFormat sets the Format field's value.
func (s *ContentTypeProfile) SetFormat(v string) *ContentTypeProfile {
	s.Format = &v
	return s
}

// SetProfileId sets the ProfileId field's value.
func (s *ContentTypeProfile) SetProfileId(v string) *ContentTypeProfile {
	s.ProfileId = &v
	return s
}

// The configuration for a field-level encryption content type-profile mapping.
type ContentTypeProfileConfig struct {
	_ struct{} `type:"structure"`

	// The configuration for a field-level encryption content type-profile.
	ContentTypeProfiles *ContentTypeProfiles `type:"structure"`

	// The setting in a field-level encryption content type-profile mapping that
	// specifies what to do when an unknown content type is provided for the profile.
	// If true, content is forwarded without being encrypted when the content type
	// is unknown. If false (the default), an error is returned when the content
	// type is unknown.
	//
	// ForwardWhenContentTypeIsUnknown is a required field
	ForwardWhenContentTypeIsUnknown *bool `type:"boolean" required:"true"`
}

// String returns the string representation
func (s ContentTypeProfileConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContentTypeProfileConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ContentTypeProfileConfig) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ContentTypeProfileConfig"}
	if s.ForwardWhenContentTypeIsUnknown == nil {
		invalidParams.Add(request.NewErrParamRequired("ForwardWhenContentTypeIsUnknown"))
	}
	if s.ContentTypeProfiles != nil {
		if err := s.ContentTypeProfiles.Validate(); err != nil {
			invalidParams.AddNested("ContentTypeProfiles", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetContentTypeProfiles sets the ContentTypeProfiles field's value.
func (s *ContentTypeProfileConfig) SetContentTypeProfiles(v *ContentTypeProfiles) *ContentTypeProfileConfig {
	s.ContentTypeProfiles = v
	return s
}

// SetForwardWhenContentTypeIsUnknown sets the ForwardWhenContentTypeIsUnknown field's value.
func (s *ContentTypeProfileConfig) SetForwardWhenContentTypeIsUnknown(v bool) *ContentTypeProfileConfig {
	s.ForwardWhenContentTypeIsUnknown = &v
	return s
}

// Field-level encryption content type-profile.
type ContentTypeProfiles struct {
	_ struct{} `type:"structure"`

	// Items in a field-level encryption content type-profile mapping.
	Items []*ContentTypeProfile `locationNameList:"ContentTypeProfile" type:"list"`

	// The number of field-level encryption content type-profile mappings.
	//
	// Quantity is a required field
	Quantity *int64 `type:"integer" required:"true"`
}

// String returns the string representation
func (s ContentTypeProfiles) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContentTypeProfiles) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ContentTypeProfiles) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ContentTypeProfiles"}
	if s.Quantity == nil {
		invalidParams.Add(request.NewErrParamRequired("Quantity"))
	}
	if s.Items != nil {
		for i, v := range s.Items {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Items", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetItems sets the Items field's value.
func (s *ContentTypeProfiles) SetItems(v []*ContentTypeProfile) *ContentTypeProfiles {
	s.Items = v
	return s
}

// SetQuantity sets the Quantity field's value.
func (s *ContentTypeProfiles) SetQuantity(v int64) *ContentTypeProfiles {
	s.Quantity = &v
	return s
}

// A complex type that specifies whether you want CloudFront to forward cookies
// to the origin and, if so, which ones. For more information about forwarding
// cookies to the origin, see Caching Content Based on Request Headers (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html)
// in the Amazon CloudFront Developer Guide.
type CookieNames struct {
	_ struct{} `type:"structure"`

	// A complex type that contains one Name element for each cookie that you want
	// CloudFront to forward to the origin for this cache behavior.
	Items []*string `locationNameList:"Name" type:"list"`

	// The number of different cookies that you want CloudFront to forward to the
	// origin for this cache behavior.
	//
	// Quantity is a required field
	Quantity *int64 `type:"integer" required:"true"`
}

// String returns the string representation
func (s CookieNames) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CookieNames) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CookieNames) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CookieNames"}
	if s.Quantity == nil {
		invalidParams.Add(request.NewErrParamRequired("Quantity"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetItems sets the Items field's value.
func (s *CookieNames) SetItems(v []*string) *CookieNames {
	s.Items = v
	return s
}

// SetQuantity sets the Quantity field's value.
func (s *CookieNames) SetQuantity(v int64) *CookieNames {
	s.Quantity = &v
	return s
}

// A complex type that specifies whether you want CloudFront to forward cookies
// to the origin and, if so, which ones. For more information about forwarding
// cookies to the origin, see Caching Content Based on Cookies (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html)
// in the Amazon CloudFront Developer Guide.
type CookiePreference struct {
	_ struct{} `type:"structure"`

	// Specifies which cookies to forward to the origin for this cache behavior:
	// all, none, or the list of cookies specified in the WhitelistedNames complex
	// type.
	//
	// Amazon S3 doesn't process cookies. When the cache behavior is forwarding
	// requests to an Amazon S3 origin, specify none for the Forward element.
	//
	// Forward is a required field
	Forward *string `type:"string" required:"true" enum:"ItemSelection"`

	// Required if you specify whitelist for the value of Forward:. A complex type
	// that specifies how many different cookies you want CloudFront to forward
	// to the origin for this cache behavior and, if you want to forward selected
	// cookies, the names of those cookies.
	//
	// If you specify all or none for the value of Forward, omit WhitelistedNames.
	// If you change the value of Forward from whitelist to all or none and you
	// don't delete the WhitelistedNames element and its child elements, CloudFront
	// deletes them automatically.
	//
	// For the current limit on the number of cookie names that you can whitelist
	// for each cache behavior, see CloudFront Limits (https://docs.aws.amazon.com/general/latest/gr/xrefaws_service_limits.html#limits_cloudfront)
	// in the AWS General Reference.
	WhitelistedNames *CookieNames `type:"structure"`
}

// String returns the string representation
func (s CookiePreference) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CookiePreference) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CookiePreference) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CookiePreference"}
	if s.Forward == nil {
		invalidParams.Add(request.NewErrParamRequired("Forward"))
	}
	if s.WhitelistedNames != nil {
		if err := s.WhitelistedNames.Validate(); err != nil {
			invalidParams.AddNested("WhitelistedNames", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetForward sets the Forward field's value.
func (s *CookiePreference) SetForward(v string) *CookiePreference {
	s.Forward = &v
	return s
}

// SetWhitelistedNames sets the WhitelistedNames field's value.
func (s *CookiePreference) SetWhitelistedNames(v *CookieNames) *CookiePreference {
	s.WhitelistedNames = v
	return s
}

// The request to create a new origin access identity (OAI). An origin access
// identity is a special CloudFront user that you can associate with Amazon
// S3 origins, so that you can secure all or just some of your Amazon S3 content.
// For more information, see Restricting Access to Amazon S3 Content by Using
// an Origin Access Identity (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html)
// in the Amazon CloudFront Developer Guide.
type CreateCloudFrontOriginAccessIdentityInput struct {
	_ struct{} `type:"structure" payload:"CloudFrontOriginAccessIdentityConfig"`

	// The current configuration information for the identity.
	//
	// CloudFrontOriginAccessIdentityConfig is a required field
	CloudFrontOriginAccessIdentityConfig *OriginAccessIdentityConfig `locationName:"CloudFrontOriginAccessIdentityConfig" type:"structure" required:"true" xmlURI:"http://cloudfront.amazonaws.com/doc/2019-03-26/"`
}

// String returns the string representation
func (s CreateCloudFrontOriginAccessIdentityInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCloudFrontOriginAccessIdentityInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateCloudFrontOriginAccessIdentityInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateCloudFrontOriginAccessIdentityInput"}
	if s.CloudFrontOriginAccessIdentityConfig == nil {
		invalidParams.Add(request.NewErrParamRequired("CloudFrontOriginAccessIdentityConfig"))
	}
	if s.CloudFrontOriginAccessIdentityConfig != nil {
		if err := s.CloudFrontOriginAccessIdentityConfig.Validate(); err != nil {
			invalidParams.AddNested("CloudFrontOriginAccessIdentityConfig", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCloudFrontOriginAccessIdentityConfig sets the CloudFrontOriginAccessIdentityConfig field's value.
func (s *CreateCloudFrontOriginAccessIdentityInput) SetCloudFrontOriginAccessIdentityConfig(v *OriginAccessIdentityConfig) *CreateCloudFrontOriginAccessIdentityInput {
	s.CloudFrontOriginAccessIdentityConfig = v
	return s
}

// The returned result of the corresponding request.
type CreateCloudFrontOriginAccessIdentityOutput struct {
	_ struct{} `type:"structure" payload:"CloudFrontOriginAccessIdentity"`

	// The origin access identity's information.
	CloudFrontOriginAccessIdentity *OriginAccessIdentity `type:"structure"`

	// The current version of the origin access identity created.
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// The fully qualified URI of the new origin access identity just created. For
	// example: https://cloudfront.amazonaws.com/2010-11-01/origin-access-identity/cloudfront/E74FTE3AJFJ256A.
	Location *string `location:"header" locationName:"Location" type:"string"`
}

// String returns the string representation
func (s CreateCloudFrontOriginAccessIdentityOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCloudFrontOriginAccessIdentityOutput) GoString() string {
	return s.String()
}

// SetCloudFrontOriginAccessIdentity sets the CloudFrontOriginAccessIdentity field's value.
func (s *CreateCloudFrontOriginAccessIdentityOutput) SetCloudFrontOriginAccessIdentity(v *OriginAccessIdentity) *CreateCloudFrontOriginAccessIdentityOutput {
	s.CloudFrontOriginAccessIdentity = v
	return s
}

// SetETag sets the ETag field's value.
func (s *CreateCloudFrontOriginAccessIdentityOutput) SetETag(v string) *CreateCloudFrontOriginAccessIdentityOutput {
	s.ETag = &v
	return s
}

// SetLocation sets the Location field's value.
func (s *CreateCloudFrontOriginAccessIdentityOutput) SetLocation(v string) *CreateCloudFrontOriginAccessIdentityOutput {
	s.Location = &v
	return s
}

// The request to create a new distribution.
type CreateDistributionInput struct {
	_ struct{} `type:"structure" payload:"DistributionConfig"`

	// The distribution's configuration information.
	//
	// DistributionConfig is a required field
	DistributionConfig *DistributionConfig `locationName:"DistributionConfig" type:"structure" required:"true" xmlURI:"http://cloudfront.amazonaws.com/doc/2019-03-26/"`
}

// String returns the string representation
func (s CreateDistributionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDistributionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDistributionInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateDistributionInput"}
	if s.DistributionConfig == nil {
		invalidParams.Add(request.NewErrParamRequired("DistributionConfig"))
	}
	if s.DistributionConfig != nil {
		if err := s.DistributionConfig.Validate(); err != nil {
			invalidParams.AddNested("DistributionConfig", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDistributionConfig sets the DistributionConfig field's value.
func (s *CreateDistributionInput) SetDistributionConfig(v *DistributionConfig) *CreateDistributionInput {
	s.DistributionConfig = v
	return s
}

// The returned result of the corresponding request.
type CreateDistributionOutput struct {
	_ struct{} `type:"structure" payload:"Distribution"`

	// The distribution's information.
	Distribution *Distribution `type:"structure"`

	// The current version of the distribution created.
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// The fully qualified URI of the new distribution resource just created. For
	// example: https://cloudfront.amazonaws.com/2010-11-01/distribution/EDFDVBD632BHDS5.
	Location *string `location:"header" locationName:"Location" type:"string"`
}

// String returns the string representation
func (s CreateDistributionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDistributionOutput) GoString() string {
	return s.String()
}

// SetDistribution sets the Distribution field's value.
func (s *CreateDistributionOutput) SetDistribution(v *Distribution) *CreateDistributionOutput {
	s.Distribution = v
	return s
}

// SetETag sets the ETag field's value.
func (s *CreateDistributionOutput) SetETag(v string) *CreateDistributionOutput {
	s.ETag = &v
	return s
}

// SetLocation sets the Location field's value.
func (s *CreateDistributionOutput) SetLocation(v string) *CreateDistributionOutput {
	s.Location = &v
	return s
}

// The request to create a new distribution with tags.
type CreateDistributionWithTagsInput struct {
	_ struct{} `type:"structure" payload:"DistributionConfigWithTags"`

	// The distribution's configuration information.
	//
	// DistributionConfigWithTags is a required field
	DistributionConfigWithTags *DistributionConfigWithTags `locationName:"DistributionConfigWithTags" type:"structure" required:"true" xmlURI:"http://cloudfront.amazonaws.com/doc/2019-03-26/"`
}

// String returns the string representation
func (s CreateDistributionWithTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDistributionWithTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDistributionWithTagsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateDistributionWithTagsInput"}
	if s.DistributionConfigWithTags == nil {
		invalidParams.Add(request.NewErrParamRequired("DistributionConfigWithTags"))
	}
	if s.DistributionConfigWithTags != nil {
		if err := s.DistributionConfigWithTags.Validate(); err != nil {
			invalidParams.AddNested("DistributionConfigWithTags", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDistributionConfigWithTags sets the DistributionConfigWithTags field's value.
func (s *CreateDistributionWithTagsInput) SetDistributionConfigWithTags(v *DistributionConfigWithTags) *CreateDistributionWithTagsInput {
	s.DistributionConfigWithTags = v
	return s
}

// The returned result of the corresponding request.
type CreateDistributionWithTagsOutput struct {
	_ struct{} `type:"structure" payload:"Distribution"`

	// The distribution's information.
	Distribution *Distribution `type:"structure"`

	// The current version of the distribution created.
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// The fully qualified URI of the new distribution resource just created. For
	// example: https://cloudfront.amazonaws.com/2010-11-01/distribution/EDFDVBD632BHDS5.
	Location *string `location:"header" locationName:"Location" type:"string"`
}

// String returns the string representation
func (s CreateDistributionWithTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDistributionWithTagsOutput) GoString() string {
	return s.String()
}

// SetDistribution sets the Distribution field's value.
func (s *CreateDistributionWithTagsOutput) SetDistribution(v *Distribution) *CreateDistributionWithTagsOutput {
	s.Distribution = v
	return s
}

// SetETag sets the ETag field's value.
func (s *CreateDistributionWithTagsOutput) SetETag(v string) *CreateDistributionWithTagsOutput {
	s.ETag = &v
	return s
}

// SetLocation sets the Location field's value.
func (s *CreateDistributionWithTagsOutput) SetLocation(v string) *CreateDistributionWithTagsOutput {
	s.Location = &v
	return s
}

type CreateFieldLevelEncryptionConfigInput struct {
	_ struct{} `type:"structure" payload:"FieldLevelEncryptionConfig"`

	// The request to create a new field-level encryption configuration.
	//
	// FieldLevelEncryptionConfig is a required field
	FieldLevelEncryptionConfig *FieldLevelEncryptionConfig `locationName:"FieldLevelEncryptionConfig" type:"structure" required:"true" xmlURI:"http://cloudfront.amazonaws.com/doc/2019-03-26/"`
}

// String returns the string representation
func (s CreateFieldLevelEncryptionConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateFieldLevelEncryptionConfigInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateFieldLevelEncryptionConfigInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateFieldLevelEncryptionConfigInput"}
	if s.FieldLevelEncryptionConfig == nil {
		invalidParams.Add(request.NewErrParamRequired("FieldLevelEncryptionConfig"))
	}
	if s.FieldLevelEncryptionConfig != nil {
		if err := s.FieldLevelEncryptionConfig.Validate(); err != nil {
			i