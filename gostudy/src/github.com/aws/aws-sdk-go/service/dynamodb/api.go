// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package dynamodb

import (
	"fmt"
	"net/url"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/aws/crr"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/private/protocol"
	"github.com/aws/aws-sdk-go/private/protocol/jsonrpc"
)

const opBatchGetItem = "BatchGetItem"

// BatchGetItemRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetItem operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetItem for more information on using the BatchGetItem
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetItemRequest method.
//    req, resp := client.BatchGetItemRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchGetItem
func (c *DynamoDB) BatchGetItemRequest(input *BatchGetItemInput) (req *request.Request, output *BatchGetItemOutput) {
	op := &request.Operation{
		Name:       opBatchGetItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"RequestItems"},
			OutputTokens:    []string{"UnprocessedKeys"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &BatchGetItemInput{}
	}

	output = &BatchGetItemOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// BatchGetItem API operation for Amazon DynamoDB.
//
// The BatchGetItem operation returns the attributes of one or more items from
// one or more tables. You identify requested items by primary key.
//
// A single operation can retrieve up to 16 MB of data, which can contain as
// many as 100 items. BatchGetItem returns a partial result if the response
// size limit is exceeded, the table's provisioned throughput is exceeded, or
// an internal processing failure occurs. If a partial result is returned, the
// operation returns a value for UnprocessedKeys. You can use this value to
// retry the operation starting with the next item to get.
//
// If you request more than 100 items, BatchGetItem returns a ValidationException
// with the message "Too many items requested for the BatchGetItem call."
//
// For example, if you ask to retrieve 100 items, but each individual item is
// 300 KB in size, the system returns 52 items (so as not to exceed the 16 MB
// limit). It also returns an appropriate UnprocessedKeys value so you can get
// the next page of results. If desired, your application can include its own
// logic to assemble the pages of results into one dataset.
//
// If none of the items can be processed due to insufficient provisioned throughput
// on all of the tables in the request, then BatchGetItem returns a ProvisionedThroughputExceededException.
// If at least one of the items is successfully processed, then BatchGetItem
// completes successfully, while returning the keys of the unread items in UnprocessedKeys.
//
// If DynamoDB returns any unprocessed items, you should retry the batch operation
// on those items. However, we strongly recommend that you use an exponential
// backoff algorithm. If you retry the batch operation immediately, the underlying
// read or write requests can still fail due to throttling on the individual
// tables. If you delay the batch operation using exponential backoff, the individual
// requests in the batch are much more likely to succeed.
//
// For more information, see Batch Operations and Error Handling (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOperations)
// in the Amazon DynamoDB Developer Guide.
//
// By default, BatchGetItem performs eventually consistent reads on every table
// in the request. If you want strongly consistent reads instead, you can set
// ConsistentRead to true for any or all tables.
//
// In order to minimize response latency, BatchGetItem retrieves items in parallel.
//
// When designing your application, keep in mind that DynamoDB does not return
// items in any particular order. To help parse the response by item, include
// the primary key values for the items in your request in the ProjectionExpression
// parameter.
//
// If a requested item does not exist, it is not returned in the result. Requests
// for nonexistent items consume the minimum read capacity units according to
// the type of read. For more information, see Working with Tables (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#CapacityUnitCalculations)
// in the Amazon DynamoDB Developer Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation BatchGetItem for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeRequestLimitExceeded "RequestLimitExceeded"
//   Throughput exceeds the current throughput limit for your account. Please
//   contact AWS Support at AWS Support (https://aws.amazon.com/support) to request
//   a limit increase.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchGetItem
func (c *DynamoDB) BatchGetItem(input *BatchGetItemInput) (*BatchGetItemOutput, error) {
	req, out := c.BatchGetItemRequest(input)
	return out, req.Send()
}

// BatchGetItemWithContext is the same as BatchGetItem with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetItem for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) BatchGetItemWithContext(ctx aws.Context, input *BatchGetItemInput, opts ...request.Option) (*BatchGetItemOutput, error) {
	req, out := c.BatchGetItemRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// BatchGetItemPages iterates over the pages of a BatchGetItem operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See BatchGetItem method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a BatchGetItem operation.
//    pageNum := 0
//    err := client.BatchGetItemPages(params,
//        func(page *dynamodb.BatchGetItemOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *DynamoDB) BatchGetItemPages(input *BatchGetItemInput, fn func(*BatchGetItemOutput, bool) bool) error {
	return c.BatchGetItemPagesWithContext(aws.BackgroundContext(), input, fn)
}

// BatchGetItemPagesWithContext same as BatchGetItemPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) BatchGetItemPagesWithContext(ctx aws.Context, input *BatchGetItemInput, fn func(*BatchGetItemOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *BatchGetItemInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.BatchGetItemRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*BatchGetItemOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opBatchWriteItem = "BatchWriteItem"

// BatchWriteItemRequest generates a "aws/request.Request" representing the
// client's request for the BatchWriteItem operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchWriteItem for more information on using the BatchWriteItem
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchWriteItemRequest method.
//    req, resp := client.BatchWriteItemRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchWriteItem
func (c *DynamoDB) BatchWriteItemRequest(input *BatchWriteItemInput) (req *request.Request, output *BatchWriteItemOutput) {
	op := &request.Operation{
		Name:       opBatchWriteItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchWriteItemInput{}
	}

	output = &BatchWriteItemOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// BatchWriteItem API operation for Amazon DynamoDB.
//
// The BatchWriteItem operation puts or deletes multiple items in one or more
// tables. A single call to BatchWriteItem can write up to 16 MB of data, which
// can comprise as many as 25 put or delete requests. Individual items to be
// written can be as large as 400 KB.
//
// BatchWriteItem cannot update items. To update items, use the UpdateItem action.
//
// The individual PutItem and DeleteItem operations specified in BatchWriteItem
// are atomic; however BatchWriteItem as a whole is not. If any requested operations
// fail because the table's provisioned throughput is exceeded or an internal
// processing failure occurs, the failed operations are returned in the UnprocessedItems
// response parameter. You can investigate and optionally resend the requests.
// Typically, you would call BatchWriteItem in a loop. Each iteration would
// check for unprocessed items and submit a new BatchWriteItem request with
// those unprocessed items until all items have been processed.
//
// If none of the items can be processed due to insufficient provisioned throughput
// on all of the tables in the request, then BatchWriteItem returns a ProvisionedThroughputExceededException.
//
// If DynamoDB returns any unprocessed items, you should retry the batch operation
// on those items. However, we strongly recommend that you use an exponential
// backoff algorithm. If you retry the batch operation immediately, the underlying
// read or write requests can still fail due to throttling on the individual
// tables. If you delay the batch operation using exponential backoff, the individual
// requests in the batch are much more likely to succeed.
//
// For more information, see Batch Operations and Error Handling (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#Programming.Errors.BatchOperations)
// in the Amazon DynamoDB Developer Guide.
//
// With BatchWriteItem, you can efficiently write or delete large amounts of
// data, such as from Amazon EMR, or copy data from another database into DynamoDB.
// In order to improve performance with these large-scale operations, BatchWriteItem
// does not behave in the same way as individual PutItem and DeleteItem calls
// would. For example, you cannot specify conditions on individual put and delete
// requests, and BatchWriteItem does not return deleted items in the response.
//
// If you use a programming language that supports concurrency, you can use
// threads to write items in parallel. Your application must include the necessary
// logic to manage the threads. With languages that don't support threading,
// you must update or delete the specified items one at a time. In both situations,
// BatchWriteItem performs the specified put and delete operations in parallel,
// giving you the power of the thread pool approach without having to introduce
// complexity into your application.
//
// Parallel processing reduces latency, but each specified put and delete request
// consumes the same number of write capacity units whether it is processed
// in parallel or not. Delete operations on nonexistent items consume one write
// capacity unit.
//
// If one or more of the following is true, DynamoDB rejects the entire batch
// write operation:
//
//    * One or more tables specified in the BatchWriteItem request does not
//    exist.
//
//    * Primary key attributes specified on an item in the request do not match
//    those in the corresponding table's primary key schema.
//
//    * You try to perform multiple operations on the same item in the same
//    BatchWriteItem request. For example, you cannot put and delete the same
//    item in the same BatchWriteItem request.
//
//    * Your request contains at least two items with identical hash and range
//    keys (which essentially is two put operations).
//
//    * There are more than 25 requests in the batch.
//
//    * Any individual item in a batch exceeds 400 KB.
//
//    * The total request size exceeds 16 MB.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation BatchWriteItem for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeItemCollectionSizeLimitExceededException "ItemCollectionSizeLimitExceededException"
//   An item collection is too large. This exception is only returned for tables
//   that have one or more local secondary indexes.
//
//   * ErrCodeRequestLimitExceeded "RequestLimitExceeded"
//   Throughput exceeds the current throughput limit for your account. Please
//   contact AWS Support at AWS Support (https://aws.amazon.com/support) to request
//   a limit increase.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchWriteItem
func (c *DynamoDB) BatchWriteItem(input *BatchWriteItemInput) (*BatchWriteItemOutput, error) {
	req, out := c.BatchWriteItemRequest(input)
	return out, req.Send()
}

// BatchWriteItemWithContext is the same as BatchWriteItem with the addition of
// the ability to pass a context and additional request options.
//
// See BatchWriteItem for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) BatchWriteItemWithContext(ctx aws.Context, input *BatchWriteItemInput, opts ...request.Option) (*BatchWriteItemOutput, error) {
	req, out := c.BatchWriteItemRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateBackup = "CreateBackup"

// CreateBackupRequest generates a "aws/request.Request" representing the
// client's request for the CreateBackup operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateBackup for more information on using the CreateBackup
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateBackupRequest method.
//    req, resp := client.CreateBackupRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateBackup
func (c *DynamoDB) CreateBackupRequest(input *CreateBackupInput) (req *request.Request, output *CreateBackupOutput) {
	op := &request.Operation{
		Name:       opCreateBackup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateBackupInput{}
	}

	output = &CreateBackupOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// CreateBackup API operation for Amazon DynamoDB.
//
// Creates a backup for an existing table.
//
// Each time you create an on-demand backup, the entire table data is backed
// up. There is no limit to the number of on-demand backups that can be taken.
//
// When you create an on-demand backup, a time marker of the request is cataloged,
// and the backup is created asynchronously, by applying all changes until the
// time of the request to the last full table snapshot. Backup requests are
// processed instantaneously and become available for restore within minutes.
//
// You can call CreateBackup at a maximum rate of 50 times per second.
//
// All backups in DynamoDB work without consuming any provisioned throughput
// on the table.
//
// If you submit a backup request on 2018-12-14 at 14:25:00, the backup is guaranteed
// to contain all data committed to the table up to 14:24:00, and data committed
// after 14:26:00 will not be. The backup might contain data modifications made
// between 14:24:00 and 14:26:00. On-demand backup does not support causal consistency.
//
// Along with data, the following are also included on the backups:
//
//    * Global secondary indexes (GSIs)
//
//    * Local secondary indexes (LSIs)
//
//    * Streams
//
//    * Provisioned read and write capacity
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation CreateBackup for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeTableNotFoundException "TableNotFoundException"
//   A source table with the name TableName does not currently exist within the
//   subscriber's account.
//
//   * ErrCodeTableInUseException "TableInUseException"
//   A target table with the specified name is either being created or deleted.
//
//   * ErrCodeContinuousBackupsUnavailableException "ContinuousBackupsUnavailableException"
//   Backups have not yet been enabled for this table.
//
//   * ErrCodeBackupInUseException "BackupInUseException"
//   There is another ongoing conflicting backup control plane operation on the
//   table. The backup is either being created, deleted or restored to a table.
//
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateBackup
func (c *DynamoDB) CreateBackup(input *CreateBackupInput) (*CreateBackupOutput, error) {
	req, out := c.CreateBackupRequest(input)
	return out, req.Send()
}

// CreateBackupWithContext is the same as CreateBackup with the addition of
// the ability to pass a context and additional request options.
//
// See CreateBackup for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) CreateBackupWithContext(ctx aws.Context, input *CreateBackupInput, opts ...request.Option) (*CreateBackupOutput, error) {
	req, out := c.CreateBackupRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateGlobalTable = "CreateGlobalTable"

// CreateGlobalTableRequest generates a "aws/request.Request" representing the
// client's request for the CreateGlobalTable operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateGlobalTable for more information on using the CreateGlobalTable
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateGlobalTableRequest method.
//    req, resp := client.CreateGlobalTableRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateGlobalTable
func (c *DynamoDB) CreateGlobalTableRequest(input *CreateGlobalTableInput) (req *request.Request, output *CreateGlobalTableOutput) {
	op := &request.Operation{
		Name:       opCreateGlobalTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateGlobalTableInput{}
	}

	output = &CreateGlobalTableOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// CreateGlobalTable API operation for Amazon DynamoDB.
//
// Creates a global table from an existing table. A global table creates a replication
// relationship between two or more DynamoDB tables with the same table name
// in the provided Regions.
//
// If you want to add a new replica table to a global table, each of the following
// conditions must be true:
//
//    * The table must have the same primary key as all of the other replicas.
//
//    * The table must have the same name as all of the other replicas.
//
//    * The table must have DynamoDB Streams enabled, with the stream containing
//    both the new and the old images of the item.
//
//    * None of the replica tables in the global table can contain any data.
//
// If global secondary indexes are specified, then the following conditions
// must also be met:
//
//    * The global secondary indexes must have the same name.
//
//    * The global secondary indexes must have the same hash key and sort key
//    (if present).
//
// Write capacity settings should be set consistently across your replica tables
// and secondary indexes. DynamoDB strongly recommends enabling auto scaling
// to manage the write capacity settings for all of your global tables replicas
// and indexes.
//
// If you prefer to manage write capacity settings manually, you should provision
// equal replicated write capacity units to your replica tables. You should
// also provision equal replicated write capacity units to matching secondary
// indexes across your global table.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation CreateGlobalTable for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
//   * ErrCodeGlobalTableAlreadyExistsException "GlobalTableAlreadyExistsException"
//   The specified global table already exists.
//
//   * ErrCodeTableNotFoundException "TableNotFoundException"
//   A source table with the name TableName does not currently exist within the
//   subscriber's account.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateGlobalTable
func (c *DynamoDB) CreateGlobalTable(input *CreateGlobalTableInput) (*CreateGlobalTableOutput, error) {
	req, out := c.CreateGlobalTableRequest(input)
	return out, req.Send()
}

// CreateGlobalTableWithContext is the same as CreateGlobalTable with the addition of
// the ability to pass a context and additional request options.
//
// See CreateGlobalTable for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) CreateGlobalTableWithContext(ctx aws.Context, input *CreateGlobalTableInput, opts ...request.Option) (*CreateGlobalTableOutput, error) {
	req, out := c.CreateGlobalTableRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateTable = "CreateTable"

// CreateTableRequest generates a "aws/request.Request" representing the
// client's request for the CreateTable operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateTable for more information on using the CreateTable
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateTableRequest method.
//    req, resp := client.CreateTableRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateTable
func (c *DynamoDB) CreateTableRequest(input *CreateTableInput) (req *request.Request, output *CreateTableOutput) {
	op := &request.Operation{
		Name:       opCreateTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateTableInput{}
	}

	output = &CreateTableOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// CreateTable API operation for Amazon DynamoDB.
//
// The CreateTable operation adds a new table to your account. In an AWS account,
// table names must be unique within each Region. That is, you can have two
// tables with same name if you create the tables in different Regions.
//
// CreateTable is an asynchronous operation. Upon receiving a CreateTable request,
// DynamoDB immediately returns a response with a TableStatus of CREATING. After
// the table is created, DynamoDB sets the TableStatus to ACTIVE. You can perform
// read and write operations only on an ACTIVE table.
//
// You can optionally define secondary indexes on the new table, as part of
// the CreateTable operation. If you want to create multiple tables with secondary
// indexes on them, you must create the tables sequentially. Only one table
// with secondary indexes can be in the CREATING state at any given time.
//
// You can use the DescribeTable action to check the table status.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation CreateTable for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceInUseException "ResourceInUseException"
//   The operation conflicts with the resource's availability. For example, you
//   attempted to recreate an existing table, or tried to delete a table currently
//   in the CREATING state.
//
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateTable
func (c *DynamoDB) CreateTable(input *CreateTableInput) (*CreateTableOutput, error) {
	req, out := c.CreateTableRequest(input)
	return out, req.Send()
}

// CreateTableWithContext is the same as CreateTable with the addition of
// the ability to pass a context and additional request options.
//
// See CreateTable for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) CreateTableWithContext(ctx aws.Context, input *CreateTableInput, opts ...request.Option) (*CreateTableOutput, error) {
	req, out := c.CreateTableRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteBackup = "DeleteBackup"

// DeleteBackupRequest generates a "aws/request.Request" representing the
// client's request for the DeleteBackup operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteBackup for more information on using the DeleteBackup
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteBackupRequest method.
//    req, resp := client.DeleteBackupRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteBackup
func (c *DynamoDB) DeleteBackupRequest(input *DeleteBackupInput) (req *request.Request, output *DeleteBackupOutput) {
	op := &request.Operation{
		Name:       opDeleteBackup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteBackupInput{}
	}

	output = &DeleteBackupOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DeleteBackup API operation for Amazon DynamoDB.
//
// Deletes an existing backup of a table.
//
// You can call DeleteBackup at a maximum rate of 10 times per second.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DeleteBackup for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeBackupNotFoundException "BackupNotFoundException"
//   Backup not found for the given BackupARN.
//
//   * ErrCodeBackupInUseException "BackupInUseException"
//   There is another ongoing conflicting backup control plane operation on the
//   table. The backup is either being created, deleted or restored to a table.
//
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteBackup
func (c *DynamoDB) DeleteBackup(input *DeleteBackupInput) (*DeleteBackupOutput, error) {
	req, out := c.DeleteBackupRequest(input)
	return out, req.Send()
}

// DeleteBackupWithContext is the same as DeleteBackup with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteBackup for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DeleteBackupWithContext(ctx aws.Context, input *DeleteBackupInput, opts ...request.Option) (*DeleteBackupOutput, error) {
	req, out := c.DeleteBackupRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteItem = "DeleteItem"

// DeleteItemRequest generates a "aws/request.Request" representing the
// client's request for the DeleteItem operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteItem for more information on using the DeleteItem
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteItemRequest method.
//    req, resp := client.DeleteItemRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteItem
func (c *DynamoDB) DeleteItemRequest(input *DeleteItemInput) (req *request.Request, output *DeleteItemOutput) {
	op := &request.Operation{
		Name:       opDeleteItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteItemInput{}
	}

	output = &DeleteItemOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DeleteItem API operation for Amazon DynamoDB.
//
// Deletes a single item in a table by primary key. You can perform a conditional
// delete operation that deletes the item if it exists, or if it has an expected
// attribute value.
//
// In addition to deleting an item, you can also return the item's attribute
// values in the same operation, using the ReturnValues parameter.
//
// Unless you specify conditions, the DeleteItem is an idempotent operation;
// running it multiple times on the same item or attribute does not result in
// an error response.
//
// Conditional deletes are useful for deleting items only if specific conditions
// are met. If those conditions are met, DynamoDB performs the delete. Otherwise,
// the item is not deleted.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DeleteItem for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeConditionalCheckFailedException "ConditionalCheckFailedException"
//   A condition specified in the operation could not be evaluated.
//
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeItemCollectionSizeLimitExceededException "ItemCollectionSizeLimitExceededException"
//   An item collection is too large. This exception is only returned for tables
//   that have one or more local secondary indexes.
//
//   * ErrCodeTransactionConflictException "TransactionConflictException"
//   Operation was rejected because there is an ongoing transaction for the item.
//
//   * ErrCodeRequestLimitExceeded "RequestLimitExceeded"
//   Throughput exceeds the current throughput limit for your account. Please
//   contact AWS Support at AWS Support (https://aws.amazon.com/support) to request
//   a limit increase.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteItem
func (c *DynamoDB) DeleteItem(input *DeleteItemInput) (*DeleteItemOutput, error) {
	req, out := c.DeleteItemRequest(input)
	return out, req.Send()
}

// DeleteItemWithContext is the same as DeleteItem with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteItem for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DeleteItemWithContext(ctx aws.Context, input *DeleteItemInput, opts ...request.Option) (*DeleteItemOutput, error) {
	req, out := c.DeleteItemRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteTable = "DeleteTable"

// DeleteTableRequest generates a "aws/request.Request" representing the
// client's request for the DeleteTable operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteTable for more information on using the DeleteTable
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteTableRequest method.
//    req, resp := client.DeleteTableRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteTable
func (c *DynamoDB) DeleteTableRequest(input *DeleteTableInput) (req *request.Request, output *DeleteTableOutput) {
	op := &request.Operation{
		Name:       opDeleteTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteTableInput{}
	}

	output = &DeleteTableOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DeleteTable API operation for Amazon DynamoDB.
//
// The DeleteTable operation deletes a table and all of its items. After a DeleteTable
// request, the specified table is in the DELETING state until DynamoDB completes
// the deletion. If the table is in the ACTIVE state, you can delete it. If
// a table is in CREATING or UPDATING states, then DynamoDB returns a ResourceInUseException.
// If the specified table does not exist, DynamoDB returns a ResourceNotFoundException.
// If table is already in the DELETING state, no error is returned.
//
// DynamoDB might continue to accept data read and write operations, such as
// GetItem and PutItem, on a table in the DELETING state until the table deletion
// is complete.
//
// When you delete a table, any indexes on that table are also deleted.
//
// If you have DynamoDB Streams enabled on the table, then the corresponding
// stream on that table goes into the DISABLED state, and the stream is automatically
// deleted after 24 hours.
//
// Use the DescribeTable action to check the status of the table.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DeleteTable for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceInUseException "ResourceInUseException"
//   The operation conflicts with the resource's availability. For example, you
//   attempted to recreate an existing table, or tried to delete a table currently
//   in the CREATING state.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteTable
func (c *DynamoDB) DeleteTable(input *DeleteTableInput) (*DeleteTableOutput, error) {
	req, out := c.DeleteTableRequest(input)
	return out, req.Send()
}

// DeleteTableWithContext is the same as DeleteTable with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteTable for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DeleteTableWithContext(ctx aws.Context, input *DeleteTableInput, opts ...request.Option) (*DeleteTableOutput, error) {
	req, out := c.DeleteTableRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeBackup = "DescribeBackup"

// DescribeBackupRequest generates a "aws/request.Request" representing the
// client's request for the DescribeBackup operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeBackup for more information on using the DescribeBackup
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeBackupRequest method.
//    req, resp := client.DescribeBackupRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeBackup
func (c *DynamoDB) DescribeBackupRequest(input *DescribeBackupInput) (req *request.Request, output *DescribeBackupOutput) {
	op := &request.Operation{
		Name:       opDescribeBackup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeBackupInput{}
	}

	output = &DescribeBackupOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DescribeBackup API operation for Amazon DynamoDB.
//
// Describes an existing backup of a table.
//
// You can call DescribeBackup at a maximum rate of 10 times per second.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DescribeBackup for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeBackupNotFoundException "BackupNotFoundException"
//   Backup not found for the given BackupARN.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeBackup
func (c *DynamoDB) DescribeBackup(input *DescribeBackupInput) (*DescribeBackupOutput, error) {
	req, out := c.DescribeBackupRequest(input)
	return out, req.Send()
}

// DescribeBackupWithContext is the same as DescribeBackup with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeBackup for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DescribeBackupWithContext(ctx aws.Context, input *DescribeBackupInput, opts ...request.Option) (*DescribeBackupOutput, error) {
	req, out := c.DescribeBackupRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeContinuousBackups = "DescribeContinuousBackups"

// DescribeContinuousBackupsRequest generates a "aws/request.Request" representing the
// client's request for the DescribeContinuousBackups operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeContinuousBackups for more information on using the DescribeContinuousBackups
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeContinuousBackupsRequest method.
//    req, resp := client.DescribeContinuousBackupsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeContinuousBackups
func (c *DynamoDB) DescribeContinuousBackupsRequest(input *DescribeContinuousBackupsInput) (req *request.Request, output *DescribeContinuousBackupsOutput) {
	op := &request.Operation{
		Name:       opDescribeContinuousBackups,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeContinuousBackupsInput{}
	}

	output = &DescribeContinuousBackupsOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DescribeContinuousBackups API operation for Amazon DynamoDB.
//
// Checks the status of continuous backups and point in time recovery on the
// specified table. Continuous backups are ENABLED on all tables at table creation.
// If point in time recovery is enabled, PointInTimeRecoveryStatus will be set
// to ENABLED.
//
// After continuous backups and point in time recovery are enabled, you can
// restore to any point in time within EarliestRestorableDateTime and LatestRestorableDateTime.
//
// LatestRestorableDateTime is typically 5 minutes before the current time.
// You can restore your table to any point in time during the last 35 days.
//
// You can call DescribeContinuousBackups at a maximum rate of 10 times per
// second.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DescribeContinuousBackups for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeTableNotFoundException "TableNotFoundException"
//   A source table with the name TableName does not currently exist within the
//   subscriber's account.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeContinuousBackups
func (c *DynamoDB) DescribeContinuousBackups(input *DescribeContinuousBackupsInput) (*DescribeContinuousBackupsOutput, error) {
	req, out := c.DescribeContinuousBackupsRequest(input)
	return out, req.Send()
}

// DescribeContinuousBackupsWithContext is the same as DescribeContinuousBackups with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeContinuousBackups for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DescribeContinuousBackupsWithContext(ctx aws.Context, input *DescribeContinuousBackupsInput, opts ...request.Option) (*DescribeContinuousBackupsOutput, error) {
	req, out := c.DescribeContinuousBackupsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeEndpoints = "DescribeEndpoints"

// DescribeEndpointsRequest generates a "aws/request.Request" representing the
// client's request for the DescribeEndpoints operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeEndpoints for more information on using the DescribeEndpoints
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeEndpointsRequest method.
//    req, resp := client.DescribeEndpointsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeEndpoints
func (c *DynamoDB) DescribeEndpointsRequest(input *DescribeEndpointsInput) (req *request.Request, output *DescribeEndpointsOutput) {
	op := &request.Operation{
		Name:       opDescribeEndpoints,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeEndpointsInput{}
	}

	output = &DescribeEndpointsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DescribeEndpoints API operation for Amazon DynamoDB.
//
// Returns the regional endpoint information.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DescribeEndpoints for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeEndpoints
func (c *DynamoDB) DescribeEndpoints(input *DescribeEndpointsInput) (*DescribeEndpointsOutput, error) {
	req, out := c.DescribeEndpointsRequest(input)
	return out, req.Send()
}

// DescribeEndpointsWithContext is the same as DescribeEndpoints with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeEndpoints for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DescribeEndpointsWithContext(ctx aws.Context, input *DescribeEndpointsInput, opts ...request.Option) (*DescribeEndpointsOutput, error) {
	req, out := c.DescribeEndpointsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

type discovererDescribeEndpoints struct {
	Client        *DynamoDB
	Required      bool
	EndpointCache *crr.EndpointCache
	Params        map[string]*string
	Key           string
}

func (d *discovererDescribeEndpoints) Discover() (crr.Endpoint, error) {
	input := &DescribeEndpointsInput{}

	resp, err := d.Client.DescribeEndpoints(input)
	if err != nil {
		return crr.Endpoint{}, err
	}

	endpoint := crr.Endpoint{
		Key: d.Key,
	}

	for _, e := range resp.Endpoints {
		if e.Address == nil {
			continue
		}

		cachedInMinutes := aws.Int64Value(e.CachePeriodInMinutes)
		u, err := url.Parse(*e.Address)
		if err != nil {
			continue
		}

		addr := crr.WeightedAddress{
			URL:     u,
			Expired: time.Now().Add(time.Duration(cachedInMinutes) * time.Minute),
		}

		endpoint.Add(addr)
	}

	d.EndpointCache.Add(endpoint)

	return endpoint, nil
}

func (d *discovererDescribeEndpoints) Handler(r *request.Request) {
	endpointKey := crr.BuildEndpointKey(d.Params)
	d.Key = endpointKey

	endpoint, err := d.EndpointCache.Get(d, endpointKey, d.Required)
	if err != nil {
		r.Error = err
		return
	}

	if endpoint.URL != nil && len(endpoint.URL.String()) > 0 {
		r.HTTPRequest.URL = endpoint.URL
	}
}

const opDescribeGlobalTable = "DescribeGlobalTable"

// DescribeGlobalTableRequest generates a "aws/request.Request" representing the
// client's request for the DescribeGlobalTable operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeGlobalTable for more information on using the DescribeGlobalTable
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeGlobalTableRequest method.
//    req, resp := client.DescribeGlobalTableRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTable
func (c *DynamoDB) DescribeGlobalTableRequest(input *DescribeGlobalTableInput) (req *request.Request, output *DescribeGlobalTableOutput) {
	op := &request.Operation{
		Name:       opDescribeGlobalTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeGlobalTableInput{}
	}

	output = &DescribeGlobalTableOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DescribeGlobalTable API operation for Amazon DynamoDB.
//
// Returns information about the specified global table.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DescribeGlobalTable for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
//   * ErrCodeGlobalTableNotFoundException "GlobalTableNotFoundException"
//   The specified global table does not exist.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTable
func (c *DynamoDB) DescribeGlobalTable(input *DescribeGlobalTableInput) (*DescribeGlobalTableOutput, error) {
	req, out := c.DescribeGlobalTableRequest(input)
	return out, req.Send()
}

// DescribeGlobalTableWithContext is the same as DescribeGlobalTable with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeGlobalTable for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DescribeGlobalTableWithContext(ctx aws.Context, input *DescribeGlobalTableInput, opts ...request.Option) (*DescribeGlobalTableOutput, error) {
	req, out := c.DescribeGlobalTableRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeGlobalTableSettings = "DescribeGlobalTableSettings"

// DescribeGlobalTableSettingsRequest generates a "aws/request.Request" representing the
// client's request for the DescribeGlobalTableSettings operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeGlobalTableSettings for more information on using the DescribeGlobalTableSettings
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeGlobalTableSettingsRequest method.
//    req, resp := client.DescribeGlobalTableSettingsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTableSettings
func (c *DynamoDB) DescribeGlobalTableSettingsRequest(input *DescribeGlobalTableSettingsInput) (req *request.Request, output *DescribeGlobalTableSettingsOutput) {
	op := &request.Operation{
		Name:       opDescribeGlobalTableSettings,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeGlobalTableSettingsInput{}
	}

	output = &DescribeGlobalTableSettingsOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DescribeGlobalTableSettings API operation for Amazon DynamoDB.
//
// Describes Region-specific settings for a global table.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DescribeGlobalTableSettings for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeGlobalTableNotFoundException "GlobalTableNotFoundException"
//   The specified global table does not exist.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTableSettings
func (c *DynamoDB) DescribeGlobalTableSettings(input *DescribeGlobalTableSettingsInput) (*DescribeGlobalTableSettingsOutput, error) {
	req, out := c.DescribeGlobalTableSettingsRequest(input)
	return out, req.Send()
}

// DescribeGlobalTableSettingsWithContext is the same as DescribeGlobalTableSettings with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeGlobalTableSettings for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DescribeGlobalTableSettingsWithContext(ctx aws.Context, input *DescribeGlobalTableSettingsInput, opts ...request.Option) (*DescribeGlobalTableSettingsOutput, error) {
	req, out := c.DescribeGlobalTableSettingsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeLimits = "DescribeLimits"

// DescribeLimitsRequest generates a "aws/request.Request" representing the
// client's request for the DescribeLimits operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeLimits for more information on using the DescribeLimits
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeLimitsRequest method.
//    req, resp := client.DescribeLimitsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeLimits
func (c *DynamoDB) DescribeLimitsRequest(input *DescribeLimitsInput) (req *request.Request, output *DescribeLimitsOutput) {
	op := &request.Operation{
		Name:       opDescribeLimits,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeLimitsInput{}
	}

	output = &DescribeLimitsOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DescribeLimits API operation for Amazon DynamoDB.
//
// Returns the current provisioned-capacity limits for your AWS account in a
// Region, both for the Region as a whole and for any one DynamoDB table that
// you create there.
//
// When you establish an AWS account, the account has initial limits on the
// maximum read capacity units and write capacity units that you can provision
// across all of your DynamoDB tables in a given Region. Also, there are per-table
// limits that apply when you create a table there. For more information, see
// Limits (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
// page in the Amazon DynamoDB Developer Guide.
//
// Although you can increase these limits by filing a case at AWS Support Center
// (https://console.aws.amazon.com/support/home#/), obtaining the increase is
// not instantaneous. The DescribeLimits action lets you write code to compare
// the capacity you are currently using to those limits imposed by your account
// so that you have enough time to apply for an increase before you hit a limit.
//
// For example, you could use one of the AWS SDKs to do the following:
//
// Call DescribeLimits for a particular Region to obtain your current account
// limits on provisioned capacity there.
//
// Create a variable to hold the aggregate read capacity units provisioned for
// all your tables in that Region, and one to hold the aggregate write capacity
// units. Zero them both.
//
// Call ListTables to obtain a list of all your DynamoDB tables.
//
// For each table name listed by ListTables, do the following:
//
//    * Call DescribeTable with the table name.
//
//    * Use the data returned by DescribeTable to add the read capacity units
//    and write capacity units provisioned for the table itself to your variables.
//
//    * If the table has one or more global secondary indexes (GSIs), loop over
//    these GSIs and add their provisioned capacity values to your variables
//    as well.
//
// Report the account limits for that Region returned by DescribeLimits, along
// with the total current provisioned capacity levels you have calculated.
//
// This will let you see whether you are getting close to your account-level
// limits.
//
// The per-table limits apply only when you are creating a new table. They restrict
// the sum of the provisioned capacity of the new table itself and all its global
// secondary indexes.
//
// For existing tables and their GSIs, DynamoDB doesn't let you increase provisioned
// capacity extremely rapidly. But the only upper limit that applies is that
// the aggregate provisioned capacity over all your tables and GSIs cannot exceed
// either of the per-account limits.
//
// DescribeLimits should only be called periodically. You can expect throttling
// errors if you call it more than once in a minute.
//
// The DescribeLimits Request element has no content.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DescribeLimits for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeLimits
func (c *DynamoDB) DescribeLimits(input *DescribeLimitsInput) (*DescribeLimitsOutput, error) {
	req, out := c.DescribeLimitsRequest(input)
	return out, req.Send()
}

// DescribeLimitsWithContext is the same as DescribeLimits with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeLimits for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DescribeLimitsWithContext(ctx aws.Context, input *DescribeLimitsInput, opts ...request.Option) (*DescribeLimitsOutput, error) {
	req, out := c.DescribeLimitsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeTable = "DescribeTable"

// DescribeTableRequest generates a "aws/request.Request" representing the
// client's request for the DescribeTable operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeTable for more information on using the DescribeTable
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeTableRequest method.
//    req, resp := client.DescribeTableRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTable
func (c *DynamoDB) DescribeTableRequest(input *DescribeTableInput) (req *request.Request, output *DescribeTableOutput) {
	op := &request.Operation{
		Name:       opDescribeTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeTableInput{}
	}

	output = &DescribeTableOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DescribeTable API operation for Amazon DynamoDB.
//
// Returns information about the table, including the current status of the
// table, when it was created, the primary key schema, and any indexes on the
// table.
//
// If you issue a DescribeTable request immediately after a CreateTable request,
// DynamoDB might return a ResourceNotFoundException. This is because DescribeTable
// uses an eventually consistent query, and the metadata for your table might
// not be available at that moment. Wait for a few seconds, and then try the
// DescribeTable request again.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DescribeTable for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTable
func (c *DynamoDB) DescribeTable(input *DescribeTableInput) (*DescribeTableOutput, error) {
	req, out := c.DescribeTableRequest(input)
	return out, req.Send()
}

// DescribeTableWithContext is the same as DescribeTable with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeTable for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DescribeTableWithContext(ctx aws.Context, input *DescribeTableInput, opts ...request.Option) (*DescribeTableOutput, error) {
	req, out := c.DescribeTableRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeTimeToLive = "DescribeTimeToLive"

// DescribeTimeToLiveRequest generates a "aws/request.Request" representing the
// client's request for the DescribeTimeToLive operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeTimeToLive for more information on using the DescribeTimeToLive
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeTimeToLiveRequest method.
//    req, resp := client.DescribeTimeToLiveRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTimeToLive
func (c *DynamoDB) DescribeTimeToLiveRequest(input *DescribeTimeToLiveInput) (req *request.Request, output *DescribeTimeToLiveOutput) {
	op := &request.Operation{
		Name:       opDescribeTimeToLive,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeTimeToLiveInput{}
	}

	output = &DescribeTimeToLiveOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// DescribeTimeToLive API operation for Amazon DynamoDB.
//
// Gives a description of the Time to Live (TTL) status on the specified table.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation DescribeTimeToLive for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTimeToLive
func (c *DynamoDB) DescribeTimeToLive(input *DescribeTimeToLiveInput) (*DescribeTimeToLiveOutput, error) {
	req, out := c.DescribeTimeToLiveRequest(input)
	return out, req.Send()
}

// DescribeTimeToLiveWithContext is the same as DescribeTimeToLive with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeTimeToLive for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) DescribeTimeToLiveWithContext(ctx aws.Context, input *DescribeTimeToLiveInput, opts ...request.Option) (*DescribeTimeToLiveOutput, error) {
	req, out := c.DescribeTimeToLiveRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetItem = "GetItem"

// GetItemRequest generates a "aws/request.Request" representing the
// client's request for the GetItem operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetItem for more information on using the GetItem
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetItemRequest method.
//    req, resp := client.GetItemRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GetItem
func (c *DynamoDB) GetItemRequest(input *GetItemInput) (req *request.Request, output *GetItemOutput) {
	op := &request.Operation{
		Name:       opGetItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetItemInput{}
	}

	output = &GetItemOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// GetItem API operation for Amazon DynamoDB.
//
// The GetItem operation returns a set of attributes for the item with the given
// primary key. If there is no matching item, GetItem does not return any data
// and there will be no Item element in the response.
//
// GetItem provides an eventually consistent read by default. If your application
// requires a strongly consistent read, set ConsistentRead to true. Although
// a strongly consistent read might take more time than an eventually consistent
// read, it always returns the last updated value.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation GetItem for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeRequestLimitExceeded "RequestLimitExceeded"
//   Throughput exceeds the current throughput limit for your account. Please
//   contact AWS Support at AWS Support (https://aws.amazon.com/support) to request
//   a limit increase.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GetItem
func (c *DynamoDB) GetItem(input *GetItemInput) (*GetItemOutput, error) {
	req, out := c.GetItemRequest(input)
	return out, req.Send()
}

// GetItemWithContext is the same as GetItem with the addition of
// the ability to pass a context and additional request options.
//
// See GetItem for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) GetItemWithContext(ctx aws.Context, input *GetItemInput, opts ...request.Option) (*GetItemOutput, error) {
	req, out := c.GetItemRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListBackups = "ListBackups"

// ListBackupsRequest generates a "aws/request.Request" representing the
// client's request for the ListBackups operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListBackups for more information on using the ListBackups
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListBackupsRequest method.
//    req, resp := client.ListBackupsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListBackups
func (c *DynamoDB) ListBackupsRequest(input *ListBackupsInput) (req *request.Request, output *ListBackupsOutput) {
	op := &request.Operation{
		Name:       opListBackups,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListBackupsInput{}
	}

	output = &ListBackupsOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// ListBackups API operation for Amazon DynamoDB.
//
// List backups associated with an AWS account. To list backups for a given
// table, specify TableName. ListBackups returns a paginated list of results
// with at most 1 MB worth of items in a page. You can also specify a limit
// for the maximum number of entries to be returned in a page.
//
// In the request, start time is inclusive, but end time is exclusive. Note
// that these limits are for the time at which the original backup was requested.
//
// You can call ListBackups a maximum of five times per second.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation ListBackups for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListBackups
func (c *DynamoDB) ListBackups(input *ListBackupsInput) (*ListBackupsOutput, error) {
	req, out := c.ListBackupsRequest(input)
	return out, req.Send()
}

// ListBackupsWithContext is the same as ListBackups with the addition of
// the ability to pass a context and additional request options.
//
// See ListBackups for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) ListBackupsWithContext(ctx aws.Context, input *ListBackupsInput, opts ...request.Option) (*ListBackupsOutput, error) {
	req, out := c.ListBackupsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListGlobalTables = "ListGlobalTables"

// ListGlobalTablesRequest generates a "aws/request.Request" representing the
// client's request for the ListGlobalTables operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListGlobalTables for more information on using the ListGlobalTables
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListGlobalTablesRequest method.
//    req, resp := client.ListGlobalTablesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListGlobalTables
func (c *DynamoDB) ListGlobalTablesRequest(input *ListGlobalTablesInput) (req *request.Request, output *ListGlobalTablesOutput) {
	op := &request.Operation{
		Name:       opListGlobalTables,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListGlobalTablesInput{}
	}

	output = &ListGlobalTablesOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// ListGlobalTables API operation for Amazon DynamoDB.
//
// Lists all global tables that have a replica in the specified Region.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation ListGlobalTables for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListGlobalTables
func (c *DynamoDB) ListGlobalTables(input *ListGlobalTablesInput) (*ListGlobalTablesOutput, error) {
	req, out := c.ListGlobalTablesRequest(input)
	return out, req.Send()
}

// ListGlobalTablesWithContext is the same as ListGlobalTables with the addition of
// the ability to pass a context and additional request options.
//
// See ListGlobalTables for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) ListGlobalTablesWithContext(ctx aws.Context, input *ListGlobalTablesInput, opts ...request.Option) (*ListGlobalTablesOutput, error) {
	req, out := c.ListGlobalTablesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListTables = "ListTables"

// ListTablesRequest generates a "aws/request.Request" representing the
// client's request for the ListTables operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListTables for more information on using the ListTables
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListTablesRequest method.
//    req, resp := client.ListTablesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTables
func (c *DynamoDB) ListTablesRequest(input *ListTablesInput) (req *request.Request, output *ListTablesOutput) {
	op := &request.Operation{
		Name:       opListTables,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"ExclusiveStartTableName"},
			OutputTokens:    []string{"LastEvaluatedTableName"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListTablesInput{}
	}

	output = &ListTablesOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// ListTables API operation for Amazon DynamoDB.
//
// Returns an array of table names associated with the current account and endpoint.
// The output from ListTables is paginated, with each page returning a maximum
// of 100 table names.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation ListTables for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTables
func (c *DynamoDB) ListTables(input *ListTablesInput) (*ListTablesOutput, error) {
	req, out := c.ListTablesRequest(input)
	return out, req.Send()
}

// ListTablesWithContext is the same as ListTables with the addition of
// the ability to pass a context and additional request options.
//
// See ListTables for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) ListTablesWithContext(ctx aws.Context, input *ListTablesInput, opts ...request.Option) (*ListTablesOutput, error) {
	req, out := c.ListTablesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListTablesPages iterates over the pages of a ListTables operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListTables method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListTables operation.
//    pageNum := 0
//    err := client.ListTablesPages(params,
//        func(page *dynamodb.ListTablesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *DynamoDB) ListTablesPages(input *ListTablesInput, fn func(*ListTablesOutput, bool) bool) error {
	return c.ListTablesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListTablesPagesWithContext same as ListTablesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) ListTablesPagesWithContext(ctx aws.Context, input *ListTablesInput, fn func(*ListTablesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListTablesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListTablesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListTablesOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListTagsOfResource = "ListTagsOfResource"

// ListTagsOfResourceRequest generates a "aws/request.Request" representing the
// client's request for the ListTagsOfResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListTagsOfResource for more information on using the ListTagsOfResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListTagsOfResourceRequest method.
//    req, resp := client.ListTagsOfResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTagsOfResource
func (c *DynamoDB) ListTagsOfResourceRequest(input *ListTagsOfResourceInput) (req *request.Request, output *ListTagsOfResourceOutput) {
	op := &request.Operation{
		Name:       opListTagsOfResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListTagsOfResourceInput{}
	}

	output = &ListTagsOfResourceOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// ListTagsOfResource API operation for Amazon DynamoDB.
//
// List all tags on an Amazon DynamoDB resource. You can call ListTagsOfResource
// up to 10 times per second, per account.
//
// For an overview on tagging DynamoDB resources, see Tagging for DynamoDB (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
// in the Amazon DynamoDB Developer Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation ListTagsOfResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTagsOfResource
func (c *DynamoDB) ListTagsOfResource(input *ListTagsOfResourceInput) (*ListTagsOfResourceOutput, error) {
	req, out := c.ListTagsOfResourceRequest(input)
	return out, req.Send()
}

// ListTagsOfResourceWithContext is the same as ListTagsOfResource with the addition of
// the ability to pass a context and additional request options.
//
// See ListTagsOfResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) ListTagsOfResourceWithContext(ctx aws.Context, input *ListTagsOfResourceInput, opts ...request.Option) (*ListTagsOfResourceOutput, error) {
	req, out := c.ListTagsOfResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opPutItem = "PutItem"

// PutItemRequest generates a "aws/request.Request" representing the
// client's request for the PutItem operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See PutItem for more information on using the PutItem
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the PutItemRequest method.
//    req, resp := client.PutItemRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/PutItem
func (c *DynamoDB) PutItemRequest(input *PutItemInput) (req *request.Request, output *PutItemOutput) {
	op := &request.Operation{
		Name:       opPutItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PutItemInput{}
	}

	output = &PutItemOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// PutItem API operation for Amazon DynamoDB.
//
// Creates a new item, or replaces an old item with a new item. If an item that
// has the same primary key as the new item already exists in the specified
// table, the new item completely replaces the existing item. You can perform
// a conditional put operation (add a new item if one with the specified primary
// key doesn't exist), or replace an existing item if it has certain attribute
// values. You can return the item's attribute values in the same operation,
// using the ReturnValues parameter.
//
// This topic provides general information about the PutItem API.
//
// For information on how to call the PutItem API using the AWS SDK in specific
// languages, see the following:
//
//    * PutItem in the AWS Command Line Interface (http://docs.aws.amazon.com/goto/aws-cli/dynamodb-2012-08-10/PutItem)
//
//    * PutItem in the AWS SDK for .NET (http://docs.aws.amazon.com/goto/DotNetSDKV3/dynamodb-2012-08-10/PutItem)
//
//    * PutItem in the AWS SDK for C++ (http://docs.aws.amazon.com/goto/SdkForCpp/dynamodb-2012-08-10/PutItem)
//
//    * PutItem in the AWS SDK for Go (http://docs.aws.amazon.com/goto/SdkForGoV1/dynamodb-2012-08-10/PutItem)
//
//    * PutItem in the AWS SDK for Java (http://docs.aws.amazon.com/goto/SdkForJava/dynamodb-2012-08-10/PutItem)
//
//    * PutItem in the AWS SDK for JavaScript (http://docs.aws.amazon.com/goto/AWSJavaScriptSDK/dynamodb-2012-08-10/PutItem)
//
//    * PutItem in the AWS SDK for PHP V3 (http://docs.aws.amazon.com/goto/SdkForPHPV3/dynamodb-2012-08-10/PutItem)
//
//    * PutItem in the AWS SDK for Python (http://docs.aws.amazon.com/goto/boto3/dynamodb-2012-08-10/PutItem)
//
//    * PutItem in the AWS SDK for Ruby V2 (http://docs.aws.amazon.com/goto/SdkForRubyV2/dynamodb-2012-08-10/PutItem)
//
// When you add an item, the primary key attributes are the only required attributes.
// Attribute values cannot be null. String and Binary type attributes must have
// lengths greater than zero. Set type attributes cannot be empty. Requests
// with empty values will be rejected with a ValidationException exception.
//
// To prevent a new item from replacing an existing item, use a conditional
// expression that contains the attribute_not_exists function with the name
// of the attribute being used as the partition key for the table. Since every
// record must contain that attribute, the attribute_not_exists function will
// only succeed if no matching item exists.
//
// For more information about PutItem, see Working with Items (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html)
// in the Amazon DynamoDB Developer Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation PutItem for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeConditionalCheckFailedException "ConditionalCheckFailedException"
//   A condition specified in the operation could not be evaluated.
//
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeItemCollectionSizeLimitExceededException "ItemCollectionSizeLimitExceededException"
//   An item collection is too large. This exception is only returned for tables
//   that have one or more local secondary indexes.
//
//   * ErrCodeTransactionConflictException "TransactionConflictException"
//   Operation was rejected because there is an ongoing transaction for the item.
//
//   * ErrCodeRequestLimitExceeded "RequestLimitExceeded"
//   Throughput exceeds the current throughput limit for your account. Please
//   contact AWS Support at AWS Support (https://aws.amazon.com/support) to request
//   a limit increase.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/PutItem
func (c *DynamoDB) PutItem(input *PutItemInput) (*PutItemOutput, error) {
	req, out := c.PutItemRequest(input)
	return out, req.Send()
}

// PutItemWithContext is the same as PutItem with the addition of
// the ability to pass a context and additional request options.
//
// See PutItem for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) PutItemWithContext(ctx aws.Context, input *PutItemInput, opts ...request.Option) (*PutItemOutput, error) {
	req, out := c.PutItemRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opQuery = "Query"

// QueryRequest generates a "aws/request.Request" representing the
// client's request for the Query operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See Query for more information on using the Query
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the QueryRequest method.
//    req, resp := client.QueryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Query
func (c *DynamoDB) QueryRequest(input *QueryInput) (req *request.Request, output *QueryOutput) {
	op := &request.Operation{
		Name:       opQuery,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"ExclusiveStartKey"},
			OutputTokens:    []string{"LastEvaluatedKey"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &QueryInput{}
	}

	output = &QueryOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// Query API operation for Amazon DynamoDB.
//
// The Query operation finds items based on primary key values. You can query
// any table or secondary index that has a composite primary key (a partition
// key and a sort key).
//
// Use the KeyConditionExpression parameter to provide a specific value for
// the partition key. The Query operation will return all of the items from
// the table or index with that partition key value. You can optionally narrow
// the scope of the Query operation by specifying a sort key value and a comparison
// operator in KeyConditionExpression. To further refine the Query results,
// you can optionally provide a FilterExpression. A FilterExpression determines
// which items within the results should be returned to you. All of the other
// results are discarded.
//
// A Query operation always returns a result set. If no matching items are found,
// the result set will be empty. Queries that do not return results consume
// the minimum number of read capacity units for that type of read operation.
//
// DynamoDB calculates the number of read capacity units consumed based on item
// size, not on the amount of data that is returned to an application. The number
// of capacity units consumed will be the same whether you request all of the
// attributes (the default behavior) or just some of them (using a projection
// expression). The number will also be the same whether or not you use a FilterExpression.
//
// Query results are always sorted by the sort key value. If the data type of
// the sort key is Number, the results are returned in numeric order; otherwise,
// the results are returned in order of UTF-8 bytes. By default, the sort order
// is ascending. To reverse the order, set the ScanIndexForward parameter to
// false.
//
// A single Query operation will read up to the maximum number of items set
// (if using the Limit parameter) or a maximum of 1 MB of data and then apply
// any filtering to the results using FilterExpression. If LastEvaluatedKey
// is present in the response, you will need to paginate the result set. For
// more information, see Paginating the Results (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.Pagination)
// in the Amazon DynamoDB Developer Guide.
//
// FilterExpression is applied after a Query finishes, but before the results
// are returned. A FilterExpression cannot contain partition key or sort key
// attributes. You need to specify those attributes in the KeyConditionExpression.
//
// A Query operation can return an empty result set and a LastEvaluatedKey if
// all the items read for the page of results are filtered out.
//
// You can query a table, a local secondary index, or a global secondary index.
// For a query on a table or on a local secondary index, you can set the ConsistentRead
// parameter to true and obtain a strongly consistent result. Global secondary
// indexes support eventually consistent reads only, so do not specify ConsistentRead
// when querying a global secondary index.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation Query for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeRequestLimitExceeded "RequestLimitExceeded"
//   Throughput exceeds the current throughput limit for your account. Please
//   contact AWS Support at AWS Support (https://aws.amazon.com/support) to request
//   a limit increase.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Query
func (c *DynamoDB) Query(input *QueryInput) (*QueryOutput, error) {
	req, out := c.QueryRequest(input)
	return out, req.Send()
}

// QueryWithContext is the same as Query with the addition of
// the ability to pass a context and additional request options.
//
// See Query for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) QueryWithContext(ctx aws.Context, input *QueryInput, opts ...request.Option) (*QueryOutput, error) {
	req, out := c.QueryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// QueryPages iterates over the pages of a Query operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See Query method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a Query operation.
//    pageNum := 0
//    err := client.QueryPages(params,
//        func(page *dynamodb.QueryOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *DynamoDB) QueryPages(input *QueryInput, fn func(*QueryOutput, bool) bool) error {
	return c.QueryPagesWithContext(aws.BackgroundContext(), input, fn)
}

// QueryPagesWithContext same as QueryPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) QueryPagesWithContext(ctx aws.Context, input *QueryInput, fn func(*QueryOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *QueryInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.QueryRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*QueryOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opRestoreTableFromBackup = "RestoreTableFromBackup"

// RestoreTableFromBackupRequest generates a "aws/request.Request" representing the
// client's request for the RestoreTableFromBackup operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See RestoreTableFromBackup for more information on using the RestoreTableFromBackup
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the RestoreTableFromBackupRequest method.
//    req, resp := client.RestoreTableFromBackupRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableFromBackup
func (c *DynamoDB) RestoreTableFromBackupRequest(input *RestoreTableFromBackupInput) (req *request.Request, output *RestoreTableFromBackupOutput) {
	op := &request.Operation{
		Name:       opRestoreTableFromBackup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &RestoreTableFromBackupInput{}
	}

	output = &RestoreTableFromBackupOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// RestoreTableFromBackup API operation for Amazon DynamoDB.
//
// Creates a new table from an existing backup. Any number of users can execute
// up to 4 concurrent restores (any type of restore) in a given account.
//
// You can call RestoreTableFromBackup at a maximum rate of 10 times per second.
//
// You must manually set up the following on the restored table:
//
//    * Auto scaling policies
//
//    * IAM policies
//
//    * Amazon CloudWatch metrics and alarms
//
//    * Tags
//
//    * Stream settings
//
//    * Time to Live (TTL) settings
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation RestoreTableFromBackup for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeTableAlreadyExistsException "TableAlreadyExistsException"
//   A target table with the specified name already exists.
//
//   * ErrCodeTableInUseException "TableInUseException"
//   A target table with the specified name is either being created or deleted.
//
//   * ErrCodeBackupNotFoundException "BackupNotFoundException"
//   Backup not found for the given BackupARN.
//
//   * ErrCodeBackupInUseException "BackupInUseException"
//   There is another ongoing conflicting backup control plane operation on the
//   table. The backup is either being created, deleted or restored to a table.
//
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableFromBackup
func (c *DynamoDB) RestoreTableFromBackup(input *RestoreTableFromBackupInput) (*RestoreTableFromBackupOutput, error) {
	req, out := c.RestoreTableFromBackupRequest(input)
	return out, req.Send()
}

// RestoreTableFromBackupWithContext is the same as RestoreTableFromBackup with the addition of
// the ability to pass a context and additional request options.
//
// See RestoreTableFromBackup for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) RestoreTableFromBackupWithContext(ctx aws.Context, input *RestoreTableFromBackupInput, opts ...request.Option) (*RestoreTableFromBackupOutput, error) {
	req, out := c.RestoreTableFromBackupRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opRestoreTableToPointInTime = "RestoreTableToPointInTime"

// RestoreTableToPointInTimeRequest generates a "aws/request.Request" representing the
// client's request for the RestoreTableToPointInTime operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See RestoreTableToPointInTime for more information on using the RestoreTableToPointInTime
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the RestoreTableToPointInTimeRequest method.
//    req, resp := client.RestoreTableToPointInTimeRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableToPointInTime
func (c *DynamoDB) RestoreTableToPointInTimeRequest(input *RestoreTableToPointInTimeInput) (req *request.Request, output *RestoreTableToPointInTimeOutput) {
	op := &request.Operation{
		Name:       opRestoreTableToPointInTime,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &RestoreTableToPointInTimeInput{}
	}

	output = &RestoreTableToPointInTimeOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// RestoreTableToPointInTime API operation for Amazon DynamoDB.
//
// Restores the specified table to the specified point in time within EarliestRestorableDateTime
// and LatestRestorableDateTime. You can restore your table to any point in
// time during the last 35 days. Any number of users can execute up to 4 concurrent
// restores (any type of restore) in a given account.
//
// When you restore using point in time recovery, DynamoDB restores your table
// data to the state based on the selected date and time (day:hour:minute:second)
// to a new table.
//
// Along with data, the following are also included on the new restored table
// using point in time recovery:
//
//    * Global secondary indexes (GSIs)
//
//    * Local secondary indexes (LSIs)
//
//    * Provisioned read and write capacity
//
//    * Encryption settings All these settings come from the current settings
//    of the source table at the time of restore.
//
// You must manually set up the following on the restored table:
//
//    * Auto scaling policies
//
//    * IAM policies
//
//    * Amazon CloudWatch metrics and alarms
//
//    * Tags
//
//    * Stream settings
//
//    * Time to Live (TTL) settings
//
//    * Point in time recovery settings
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation RestoreTableToPointInTime for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeTableAlreadyExistsException "TableAlreadyExistsException"
//   A target table with the specified name already exists.
//
//   * ErrCodeTableNotFoundException "TableNotFoundException"
//   A source table with the name TableName does not currently exist within the
//   subscriber's account.
//
//   * ErrCodeTableInUseException "TableInUseException"
//   A target table with the specified name is either being created or deleted.
//
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeInvalidRestoreTimeException "InvalidRestoreTimeException"
//   An invalid restore time was specified. RestoreDateTime must be between EarliestRestorableDateTime
//   and LatestRestorableDateTime.
//
//   * ErrCodePointInTimeRecoveryUnavailableException "PointInTimeRecoveryUnavailableException"
//   Point in time recovery has not yet been enabled for this source table.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableToPointInTime
func (c *DynamoDB) RestoreTableToPointInTime(input *RestoreTableToPointInTimeInput) (*RestoreTableToPointInTimeOutput, error) {
	req, out := c.RestoreTableToPointInTimeRequest(input)
	return out, req.Send()
}

// RestoreTableToPointInTimeWithContext is the same as RestoreTableToPointInTime with the addition of
// the ability to pass a context and additional request options.
//
// See RestoreTableToPointInTime for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) RestoreTableToPointInTimeWithContext(ctx aws.Context, input *RestoreTableToPointInTimeInput, opts ...request.Option) (*RestoreTableToPointInTimeOutput, error) {
	req, out := c.RestoreTableToPointInTimeRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opScan = "Scan"

// ScanRequest generates a "aws/request.Request" representing the
// client's request for the Scan operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See Scan for more information on using the Scan
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ScanRequest method.
//    req, resp := client.ScanRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Scan
func (c *DynamoDB) ScanRequest(input *ScanInput) (req *request.Request, output *ScanOutput) {
	op := &request.Operation{
		Name:       opScan,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"ExclusiveStartKey"},
			OutputTokens:    []string{"LastEvaluatedKey"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ScanInput{}
	}

	output = &ScanOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// Scan API operation for Amazon DynamoDB.
//
// The Scan operation returns one or more items and item attributes by accessing
// every item in a table or a secondary index. To have DynamoDB return fewer
// items, you can provide a FilterExpression operation.
//
// If the total number of scanned items exceeds the maximum dataset size limit
// of 1 MB, the scan stops and results are returned to the user as a LastEvaluatedKey
// value to continue the scan in a subsequent operation. The results also include
// the number of items exceeding the limit. A scan can result in no table data
// meeting the filter criteria.
//
// A single Scan operation reads up to the maximum number of items set (if using
// the Limit parameter) or a maximum of 1 MB of data and then apply any filtering
// to the results using FilterExpression. If LastEvaluatedKey is present in
// the response, you need to paginate the result set. For more information,
// see Paginating the Results (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.Pagination)
// in the Amazon DynamoDB Developer Guide.
//
// Scan operations proceed sequentially; however, for faster performance on
// a large table or secondary index, applications can request a parallel Scan
// operation by providing the Segment and TotalSegments parameters. For more
// information, see Parallel Scan (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.ParallelScan)
// in the Amazon DynamoDB Developer Guide.
//
// Scan uses eventually consistent reads when accessing the data in a table;
// therefore, the result set might not include the changes to data in the table
// immediately before the operation began. If you need a consistent copy of
// the data, as of the time that the Scan begins, you can set the ConsistentRead
// parameter to true.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation Scan for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeRequestLimitExceeded "RequestLimitExceeded"
//   Throughput exceeds the current throughput limit for your account. Please
//   contact AWS Support at AWS Support (https://aws.amazon.com/support) to request
//   a limit increase.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Scan
func (c *DynamoDB) Scan(input *ScanInput) (*ScanOutput, error) {
	req, out := c.ScanRequest(input)
	return out, req.Send()
}

// ScanWithContext is the same as Scan with the addition of
// the ability to pass a context and additional request options.
//
// See Scan for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) ScanWithContext(ctx aws.Context, input *ScanInput, opts ...request.Option) (*ScanOutput, error) {
	req, out := c.ScanRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ScanPages iterates over the pages of a Scan operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See Scan method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a Scan operation.
//    pageNum := 0
//    err := client.ScanPages(params,
//        func(page *dynamodb.ScanOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *DynamoDB) ScanPages(input *ScanInput, fn func(*ScanOutput, bool) bool) error {
	return c.ScanPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ScanPagesWithContext same as ScanPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) ScanPagesWithContext(ctx aws.Context, input *ScanInput, fn func(*ScanOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ScanInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ScanRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ScanOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opTagResource = "TagResource"

// TagResourceRequest generates a "aws/request.Request" representing the
// client's request for the TagResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See TagResource for more information on using the TagResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the TagResourceRequest method.
//    req, resp := client.TagResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TagResource
func (c *DynamoDB) TagResourceRequest(input *TagResourceInput) (req *request.Request, output *TagResourceOutput) {
	op := &request.Operation{
		Name:       opTagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &TagResourceInput{}
	}

	output = &TagResourceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// TagResource API operation for Amazon DynamoDB.
//
// Associate a set of tags with an Amazon DynamoDB resource. You can then activate
// these user-defined tags so that they appear on the Billing and Cost Management
// console for cost allocation tracking. You can call TagResource up to five
// times per second, per account.
//
// For an overview on tagging DynamoDB resources, see Tagging for DynamoDB (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
// in the Amazon DynamoDB Developer Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation TagResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
//   * ErrCodeResourceInUseException "ResourceInUseException"
//   The operation conflicts with the resource's availability. For example, you
//   attempted to recreate an existing table, or tried to delete a table currently
//   in the CREATING state.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TagResource
func (c *DynamoDB) TagResource(input *TagResourceInput) (*TagResourceOutput, error) {
	req, out := c.TagResourceRequest(input)
	return out, req.Send()
}

// TagResourceWithContext is the same as TagResource with the addition of
// the ability to pass a context and additional request options.
//
// See TagResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) TagResourceWithContext(ctx aws.Context, input *TagResourceInput, opts ...request.Option) (*TagResourceOutput, error) {
	req, out := c.TagResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opTransactGetItems = "TransactGetItems"

// TransactGetItemsRequest generates a "aws/request.Request" representing the
// client's request for the TransactGetItems operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See TransactGetItems for more information on using the TransactGetItems
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the TransactGetItemsRequest method.
//    req, resp := client.TransactGetItemsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactGetItems
func (c *DynamoDB) TransactGetItemsRequest(input *TransactGetItemsInput) (req *request.Request, output *TransactGetItemsOutput) {
	op := &request.Operation{
		Name:       opTransactGetItems,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &TransactGetItemsInput{}
	}

	output = &TransactGetItemsOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// TransactGetItems API operation for Amazon DynamoDB.
//
// TransactGetItems is a synchronous operation that atomically retrieves multiple
// items from one or more tables (but not from indexes) in a single account
// and Region. A TransactGetItems call can contain up to 25 TransactGetItem
// objects, each of which contains a Get structure that specifies an item to
// retrieve from a table in the account and Region. A call to TransactGetItems
// cannot retrieve items from tables in more than one AWS account or Region.
// The aggregate size of the items in the transaction cannot exceed 4 MB.
//
// All AWS Regions and AWS GovCloud (US) support up to 25 items per transaction
// with up to 4 MB of data, except the following AWS Regions:
//
//    * China (Beijing)
//
//    * China (Ningxia)
//
// The China (Beijing) and China (Ningxia) Regions support up to 10 items per
// transaction with up to 4 MB of data.
//
// DynamoDB rejects the entire TransactGetItems request if any of the following
// is true:
//
//    * A conflicting operation is in the process of updating an item to be
//    read.
//
//    * There is insufficient provisioned capacity for the transaction to be
//    completed.
//
//    * There is a user error, such as an invalid data format.
//
//    * The aggregate size of the items in the transaction cannot exceed 4 MB.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation TransactGetItems for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeTransactionCanceledException "TransactionCanceledException"
//   The entire transaction request was canceled.
//
//   DynamoDB cancels a TransactWriteItems request under the following circumstances:
//
//      * A condition in one of the condition expressions is not met.
//
//      * A table in the TransactWriteItems request is in a different account
//      or region.
//
//      * More than one action in the TransactWriteItems operation targets the
//      same item.
//
//      * There is insufficient provisioned capacity for the transaction to be
//      completed.
//
//      * An item size becomes too large (larger than 400 KB), or a local secondary
//      index (LSI) becomes too large, or a similar validation error occurs because
//      of changes made by the transaction.
//
//      * The aggregate size of the items in the transaction exceeds 4 MBs.
//
//      * There is a user error, such as an invalid data format.
//
//   DynamoDB cancels a TransactGetItems request under the following circumstances:
//
//      * There is an ongoing TransactGetItems operation that conflicts with a
//      concurrent PutItem, UpdateItem, DeleteItem or TransactWriteItems request.
//      In this case the TransactGetItems operation fails with a TransactionCanceledException.
//
//      * A table in the TransactGetItems request is in a different account or
//      region.
//
//      * There is insufficient provisioned capacity for the transaction to be
//      completed.
//
//      * The aggregate size of the items in the transaction exceeds 4 MBs.
//
//      * There is a user error, such as an invalid data format.
//
//   If using Java, DynamoDB lists the cancellation reasons on the CancellationReasons
//   property. This property is not set for other languages. Transaction cancellation
//   reasons are ordered in the order of requested items, if an item has no error
//   it will have NONE code and Null message.
//
//   Cancellation reason codes and possible error messages:
//
//      * No Errors: Code: NONE Message: null
//
//      * Conditional Check Failed: Code: ConditionalCheckFailed Message: The
//      conditional request failed.
//
//      * Item Collection Size Limit Exceeded: Code: ItemCollectionSizeLimitExceeded
//      Message: Collection size exceeded.
//
//      * Transaction Conflict: Code: TransactionConflict Message: Transaction
//      is ongoing for the item.
//
//      * Provisioned Throughput Exceeded: Code: ProvisionedThroughputExceeded
//      Messages: The level of configured provisioned throughput for the table
//      was exceeded. Consider increasing your provisioning level with the UpdateTable
//      API. This Message is received when provisioned throughput is exceeded
//      is on a provisioned DynamoDB table. The level of configured provisioned
//      throughput for one or more global secondary indexes of the table was exceeded.
//      Consider increasing your provisioning level for the under-provisioned
//      global secondary indexes with the UpdateTable API. This message is returned
//      when provisioned throughput is exceeded is on a provisioned GSI.
//
//      * Throttling Error: Code: ThrottlingError Messages: Throughput exceeds
//      the current capacity of your table or index. DynamoDB is automatically
//      scaling your table or index so please try again shortly. If exceptions
//      persist, check if you have a hot key: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html.
//      This message is returned when writes get throttled on an On-Demand table
//      as DynamoDB is automatically scaling the table. Throughput exceeds the
//      current capacity for one or more global secondary indexes. DynamoDB is
//      automatically scaling your index so please try again shortly. This message
//      is returned when when writes get throttled on an On-Demand GSI as DynamoDB
//      is automatically scaling the GSI.
//
//      * Validation Error: Code: ValidationError Messages: One or more parameter
//      values were invalid. The update expression attempted to update the secondary
//      index key beyond allowed size limits. The update expression attempted
//      to update the secondary index key to unsupported type. An operand in the
//      update expression has an incorrect data type. Item size to update has
//      exceeded the maximum allowed size. Number overflow. Attempting to store
//      a number with magnitude larger than supported range. Type mismatch for
//      attribute to update. Nesting Levels have exceeded supported limits. The
//      document path provided in the update expression is invalid for update.
//      The provided expression refers to an attribute that does not exist in
//      the item.
//
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactGetItems
func (c *DynamoDB) TransactGetItems(input *TransactGetItemsInput) (*TransactGetItemsOutput, error) {
	req, out := c.TransactGetItemsRequest(input)
	return out, req.Send()
}

// TransactGetItemsWithContext is the same as TransactGetItems with the addition of
// the ability to pass a context and additional request options.
//
// See TransactGetItems for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) TransactGetItemsWithContext(ctx aws.Context, input *TransactGetItemsInput, opts ...request.Option) (*TransactGetItemsOutput, error) {
	req, out := c.TransactGetItemsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opTransactWriteItems = "TransactWriteItems"

// TransactWriteItemsRequest generates a "aws/request.Request" representing the
// client's request for the TransactWriteItems operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See TransactWriteItems for more information on using the TransactWriteItems
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the TransactWriteItemsRequest method.
//    req, resp := client.TransactWriteItemsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactWriteItems
func (c *DynamoDB) TransactWriteItemsRequest(input *TransactWriteItemsInput) (req *request.Request, output *TransactWriteItemsOutput) {
	op := &request.Operation{
		Name:       opTransactWriteItems,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &TransactWriteItemsInput{}
	}

	output = &TransactWriteItemsOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// TransactWriteItems API operation for Amazon DynamoDB.
//
// TransactWriteItems is a synchronous write operation that groups up to 25
// action requests. These actions can target items in different tables, but
// not in different AWS accounts or Regions, and no two actions can target the
// same item. For example, you cannot both ConditionCheck and Update the same
// item. The aggregate size of the items in the transaction cannot exceed 4
// MB.
//
// All AWS Regions and AWS GovCloud (US) support up to 25 items per transaction
// with up to 4 MB of data, except the following AWS Regions:
//
//    * China (Beijing)
//
//    * China (Ningxia)
//
// The China (Beijing) and China (Ningxia) Regions support up to 10 items per
// transaction with up to 4 MB of data.
//
// The actions are completed atomically so that either all of them succeed,
// or all of them fail. They are defined by the following objects:
//
//    * Put  Initiates a PutItem operation to write a new item. This structure
//    specifies the primary key of the item to be written, the name of the table
//    to write it in, an optional condition expression that must be satisfied
//    for the write to succeed, a list of the item's attributes, and a field
//    indicating whether to retrieve the item's attributes if the condition
//    is not met.
//
//    * Update  Initiates an UpdateItem operation to update an existing item.
//    This structure specifies the primary key of the item to be updated, the
//    name of the table where it resides, an optional condition expression that
//    must be satisfied for the update to succeed, an expression that defines
//    one or more attributes to be updated, and a field indicating whether to
//    retrieve the item's attributes if the condition is not met.
//
//    * Delete  Initiates a DeleteItem operation to delete an existing item.
//    This structure specifies the primary key of the item to be deleted, the
//    name of the table where it resides, an optional condition expression that
//    must be satisfied for the deletion to succeed, and a field indicating
//    whether to retrieve the item's attributes if the condition is not met.
//
//    * ConditionCheck  Applies a condition to an item that is not being
//    modified by the transaction. This structure specifies the primary key
//    of the item to be checked, the name of the table where it resides, a condition
//    expression that must be satisfied for the transaction to succeed, and
//    a field indicating whether to retrieve the item's attributes if the condition
//    is not met.
//
// DynamoDB rejects the entire TransactWriteItems request if any of the following
// is true:
//
//    * A condition in one of the condition expressions is not met.
//
//    * An ongoing operation is in the process of updating the same item.
//
//    * There is insufficient provisioned capacity for the transaction to be
//    completed.
//
//    * An item size becomes too large (bigger than 400 KB), a local secondary
//    index (LSI) becomes too large, or a similar validation error occurs because
//    of changes made by the transaction.
//
//    * The aggregate size of the items in the transaction exceeds 4 MB.
//
//    * There is a user error, such as an invalid data format.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation TransactWriteItems for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeTransactionCanceledException "TransactionCanceledException"
//   The entire transaction request was canceled.
//
//   DynamoDB cancels a TransactWriteItems request under the following circumstances:
//
//      * A condition in one of the condition expressions is not met.
//
//      * A table in the TransactWriteItems request is in a different account
//      or region.
//
//      * More than one action in the TransactWriteItems operation targets the
//      same item.
//
//      * There is insufficient provisioned capacity for the transaction to be
//      completed.
//
//      * An item size becomes too large (larger than 400 KB), or a local secondary
//      index (LSI) becomes too large, or a similar validation error occurs because
//      of changes made by the transaction.
//
//      * The aggregate size of the items in the transaction exceeds 4 MBs.
//
//      * There is a user error, such as an invalid data format.
//
//   DynamoDB cancels a TransactGetItems request under the following circumstances:
//
//      * There is an ongoing TransactGetItems operation that conflicts with a
//      concurrent PutItem, UpdateItem, DeleteItem or TransactWriteItems request.
//      In this case the TransactGetItems operation fails with a TransactionCanceledException.
//
//      * A table in the TransactGetItems request is in a different account or
//      region.
//
//      * There is insufficient provisioned capacity for the transaction to be
//      completed.
//
//      * The aggregate size of the items in the transaction exceeds 4 MBs.
//
//      * There is a user error, such as an invalid data format.
//
//   If using Java, DynamoDB lists the cancellation reasons on the CancellationReasons
//   property. This property is not set for other languages. Transaction cancellation
//   reasons are ordered in the order of requested items, if an item has no error
//   it will have NONE code and Null message.
//
//   Cancellation reason codes and possible error messages:
//
//      * No Errors: Code: NONE Message: null
//
//      * Conditional Check Failed: Code: ConditionalCheckFailed Message: The
//      conditional request failed.
//
//      * Item Collection Size Limit Exceeded: Code: ItemCollectionSizeLimitExceeded
//      Message: Collection size exceeded.
//
//      * Transaction Conflict: Code: TransactionConflict Message: Transaction
//      is ongoing for the item.
//
//      * Provisioned Throughput Exceeded: Code: ProvisionedThroughputExceeded
//      Messages: The level of configured provisioned throughput for the table
//      was exceeded. Consider increasing your provisioning level with the UpdateTable
//      API. This Message is received when provisioned throughput is exceeded
//      is on a provisioned DynamoDB table. The level of configured provisioned
//      throughput for one or more global secondary indexes of the table was exceeded.
//      Consider increasing your provisioning level for the under-provisioned
//      global secondary indexes with the UpdateTable API. This message is returned
//      when provisioned throughput is exceeded is on a provisioned GSI.
//
//      * Throttling Error: Code: ThrottlingError Messages: Throughput exceeds
//      the current capacity of your table or index. DynamoDB is automatically
//      scaling your table or index so please try again shortly. If exceptions
//      persist, check if you have a hot key: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html.
//      This message is returned when writes get throttled on an On-Demand table
//      as DynamoDB is automatically scaling the table. Throughput exceeds the
//      current capacity for one or more global secondary indexes. DynamoDB is
//      automatically scaling your index so please try again shortly. This message
//      is returned when when writes get throttled on an On-Demand GSI as DynamoDB
//      is automatically scaling the GSI.
//
//      * Validation Error: Code: ValidationError Messages: One or more parameter
//      values were invalid. The update expression attempted to update the secondary
//      index key beyond allowed size limits. The update expression attempted
//      to update the secondary index key to unsupported type. An operand in the
//      update expression has an incorrect data type. Item size to update has
//      exceeded the maximum allowed size. Number overflow. Attempting to store
//      a number with magnitude larger than supported range. Type mismatch for
//      attribute to update. Nesting Levels have exceeded supported limits. The
//      document path provided in the update expression is invalid for update.
//      The provided expression refers to an attribute that does not exist in
//      the item.
//
//   * ErrCodeTransactionInProgressException "TransactionInProgressException"
//   The transaction with the given request token is already in progress.
//
//   * ErrCodeIdempotentParameterMismatchException "IdempotentParameterMismatchException"
//   DynamoDB rejected the request because you retried a request with a different
//   payload but with an idempotent token that was already used.
//
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactWriteItems
func (c *DynamoDB) TransactWriteItems(input *TransactWriteItemsInput) (*TransactWriteItemsOutput, error) {
	req, out := c.TransactWriteItemsRequest(input)
	return out, req.Send()
}

// TransactWriteItemsWithContext is the same as TransactWriteItems with the addition of
// the ability to pass a context and additional request options.
//
// See TransactWriteItems for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) TransactWriteItemsWithContext(ctx aws.Context, input *TransactWriteItemsInput, opts ...request.Option) (*TransactWriteItemsOutput, error) {
	req, out := c.TransactWriteItemsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUntagResource = "UntagResource"

// UntagResourceRequest generates a "aws/request.Request" representing the
// client's request for the UntagResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UntagResource for more information on using the UntagResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UntagResourceRequest method.
//    req, resp := client.UntagResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UntagResource
func (c *DynamoDB) UntagResourceRequest(input *UntagResourceInput) (req *request.Request, output *UntagResourceOutput) {
	op := &request.Operation{
		Name:       opUntagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UntagResourceInput{}
	}

	output = &UntagResourceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// UntagResource API operation for Amazon DynamoDB.
//
// Removes the association of tags from an Amazon DynamoDB resource. You can
// call UntagResource up to five times per second, per account.
//
// For an overview on tagging DynamoDB resources, see Tagging for DynamoDB (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
// in the Amazon DynamoDB Developer Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation UntagResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
//   * ErrCodeResourceInUseException "ResourceInUseException"
//   The operation conflicts with the resource's availability. For example, you
//   attempted to recreate an existing table, or tried to delete a table currently
//   in the CREATING state.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UntagResource
func (c *DynamoDB) UntagResource(input *UntagResourceInput) (*UntagResourceOutput, error) {
	req, out := c.UntagResourceRequest(input)
	return out, req.Send()
}

// UntagResourceWithContext is the same as UntagResource with the addition of
// the ability to pass a context and additional request options.
//
// See UntagResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) UntagResourceWithContext(ctx aws.Context, input *UntagResourceInput, opts ...request.Option) (*UntagResourceOutput, error) {
	req, out := c.UntagResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateContinuousBackups = "UpdateContinuousBackups"

// UpdateContinuousBackupsRequest generates a "aws/request.Request" representing the
// client's request for the UpdateContinuousBackups operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateContinuousBackups for more information on using the UpdateContinuousBackups
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateContinuousBackupsRequest method.
//    req, resp := client.UpdateContinuousBackupsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateContinuousBackups
func (c *DynamoDB) UpdateContinuousBackupsRequest(input *UpdateContinuousBackupsInput) (req *request.Request, output *UpdateContinuousBackupsOutput) {
	op := &request.Operation{
		Name:       opUpdateContinuousBackups,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateContinuousBackupsInput{}
	}

	output = &UpdateContinuousBackupsOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// UpdateContinuousBackups API operation for Amazon DynamoDB.
//
// UpdateContinuousBackups enables or disables point in time recovery for the
// specified table. A successful UpdateContinuousBackups call returns the current
// ContinuousBackupsDescription. Continuous backups are ENABLED on all tables
// at table creation. If point in time recovery is enabled, PointInTimeRecoveryStatus
// will be set to ENABLED.
//
// Once continuous backups and point in time recovery are enabled, you can restore
// to any point in time within EarliestRestorableDateTime and LatestRestorableDateTime.
//
// LatestRestorableDateTime is typically 5 minutes before the current time.
// You can restore your table to any point in time during the last 35 days.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation UpdateContinuousBackups for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeTableNotFoundException "TableNotFoundException"
//   A source table with the name TableName does not currently exist within the
//   subscriber's account.
//
//   * ErrCodeContinuousBackupsUnavailableException "ContinuousBackupsUnavailableException"
//   Backups have not yet been enabled for this table.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateContinuousBackups
func (c *DynamoDB) UpdateContinuousBackups(input *UpdateContinuousBackupsInput) (*UpdateContinuousBackupsOutput, error) {
	req, out := c.UpdateContinuousBackupsRequest(input)
	return out, req.Send()
}

// UpdateContinuousBackupsWithContext is the same as UpdateContinuousBackups with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateContinuousBackups for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) UpdateContinuousBackupsWithContext(ctx aws.Context, input *UpdateContinuousBackupsInput, opts ...request.Option) (*UpdateContinuousBackupsOutput, error) {
	req, out := c.UpdateContinuousBackupsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateGlobalTable = "UpdateGlobalTable"

// UpdateGlobalTableRequest generates a "aws/request.Request" representing the
// client's request for the UpdateGlobalTable operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateGlobalTable for more information on using the UpdateGlobalTable
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateGlobalTableRequest method.
//    req, resp := client.UpdateGlobalTableRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTable
func (c *DynamoDB) UpdateGlobalTableRequest(input *UpdateGlobalTableInput) (req *request.Request, output *UpdateGlobalTableOutput) {
	op := &request.Operation{
		Name:       opUpdateGlobalTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateGlobalTableInput{}
	}

	output = &UpdateGlobalTableOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// UpdateGlobalTable API operation for Amazon DynamoDB.
//
// Adds or removes replicas in the specified global table. The global table
// must already exist to be able to use this operation. Any replica to be added
// must be empty, have the same name as the global table, have the same key
// schema, have DynamoDB Streams enabled, and have the same provisioned and
// maximum write capacity units.
//
// Although you can use UpdateGlobalTable to add replicas and remove replicas
// in a single request, for simplicity we recommend that you issue separate
// requests for adding or removing replicas.
//
// If global secondary indexes are specified, then the following conditions
// must also be met:
//
//    * The global secondary indexes must have the same name.
//
//    * The global secondary indexes must have the same hash key and sort key
//    (if present).
//
//    * The global secondary indexes must have the same provisioned and maximum
//    write capacity units.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation UpdateGlobalTable for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
//   * ErrCodeGlobalTableNotFoundException "GlobalTableNotFoundException"
//   The specified global table does not exist.
//
//   * ErrCodeReplicaAlreadyExistsException "ReplicaAlreadyExistsException"
//   The specified replica is already part of the global table.
//
//   * ErrCodeReplicaNotFoundException "ReplicaNotFoundException"
//   The specified replica is no longer part of the global table.
//
//   * ErrCodeTableNotFoundException "TableNotFoundException"
//   A source table with the name TableName does not currently exist within the
//   subscriber's account.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTable
func (c *DynamoDB) UpdateGlobalTable(input *UpdateGlobalTableInput) (*UpdateGlobalTableOutput, error) {
	req, out := c.UpdateGlobalTableRequest(input)
	return out, req.Send()
}

// UpdateGlobalTableWithContext is the same as UpdateGlobalTable with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateGlobalTable for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) UpdateGlobalTableWithContext(ctx aws.Context, input *UpdateGlobalTableInput, opts ...request.Option) (*UpdateGlobalTableOutput, error) {
	req, out := c.UpdateGlobalTableRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateGlobalTableSettings = "UpdateGlobalTableSettings"

// UpdateGlobalTableSettingsRequest generates a "aws/request.Request" representing the
// client's request for the UpdateGlobalTableSettings operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateGlobalTableSettings for more information on using the UpdateGlobalTableSettings
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateGlobalTableSettingsRequest method.
//    req, resp := client.UpdateGlobalTableSettingsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTableSettings
func (c *DynamoDB) UpdateGlobalTableSettingsRequest(input *UpdateGlobalTableSettingsInput) (req *request.Request, output *UpdateGlobalTableSettingsOutput) {
	op := &request.Operation{
		Name:       opUpdateGlobalTableSettings,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateGlobalTableSettingsInput{}
	}

	output = &UpdateGlobalTableSettingsOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// UpdateGlobalTableSettings API operation for Amazon DynamoDB.
//
// Updates settings for a global table.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation UpdateGlobalTableSettings for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeGlobalTableNotFoundException "GlobalTableNotFoundException"
//   The specified global table does not exist.
//
//   * ErrCodeReplicaNotFoundException "ReplicaNotFoundException"
//   The specified replica is no longer part of the global table.
//
//   * ErrCodeIndexNotFoundException "IndexNotFoundException"
//   The operation tried to access a nonexistent index.
//
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeResourceInUseException "ResourceInUseException"
//   The operation conflicts with the resource's availability. For example, you
//   attempted to recreate an existing table, or tried to delete a table currently
//   in the CREATING state.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTableSettings
func (c *DynamoDB) UpdateGlobalTableSettings(input *UpdateGlobalTableSettingsInput) (*UpdateGlobalTableSettingsOutput, error) {
	req, out := c.UpdateGlobalTableSettingsRequest(input)
	return out, req.Send()
}

// UpdateGlobalTableSettingsWithContext is the same as UpdateGlobalTableSettings with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateGlobalTableSettings for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) UpdateGlobalTableSettingsWithContext(ctx aws.Context, input *UpdateGlobalTableSettingsInput, opts ...request.Option) (*UpdateGlobalTableSettingsOutput, error) {
	req, out := c.UpdateGlobalTableSettingsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateItem = "UpdateItem"

// UpdateItemRequest generates a "aws/request.Request" representing the
// client's request for the UpdateItem operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateItem for more information on using the UpdateItem
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateItemRequest method.
//    req, resp := client.UpdateItemRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateItem
func (c *DynamoDB) UpdateItemRequest(input *UpdateItemInput) (req *request.Request, output *UpdateItemOutput) {
	op := &request.Operation{
		Name:       opUpdateItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateItemInput{}
	}

	output = &UpdateItemOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// UpdateItem API operation for Amazon DynamoDB.
//
// Edits an existing item's attributes, or adds a new item to the table if it
// does not already exist. You can put, delete, or add attribute values. You
// can also perform a conditional update on an existing item (insert a new attribute
// name-value pair if it doesn't exist, or replace an existing name-value pair
// if it has certain expected attribute values).
//
// You can also return the item's attribute values in the same UpdateItem operation
// using the ReturnValues parameter.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation UpdateItem for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeConditionalCheckFailedException "ConditionalCheckFailedException"
//   A condition specified in the operation could not be evaluated.
//
//   * ErrCodeProvisionedThroughputExceededException "ProvisionedThroughputExceededException"
//   Your request rate is too high. The AWS SDKs for DynamoDB automatically retry
//   requests that receive this exception. Your request is eventually successful,
//   unless your retry queue is too large to finish. Reduce the frequency of requests
//   and use exponential backoff. For more information, go to Error Retries and
//   Exponential Backoff (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff)
//   in the Amazon DynamoDB Developer Guide.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeItemCollectionSizeLimitExceededException "ItemCollectionSizeLimitExceededException"
//   An item collection is too large. This exception is only returned for tables
//   that have one or more local secondary indexes.
//
//   * ErrCodeTransactionConflictException "TransactionConflictException"
//   Operation was rejected because there is an ongoing transaction for the item.
//
//   * ErrCodeRequestLimitExceeded "RequestLimitExceeded"
//   Throughput exceeds the current throughput limit for your account. Please
//   contact AWS Support at AWS Support (https://aws.amazon.com/support) to request
//   a limit increase.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateItem
func (c *DynamoDB) UpdateItem(input *UpdateItemInput) (*UpdateItemOutput, error) {
	req, out := c.UpdateItemRequest(input)
	return out, req.Send()
}

// UpdateItemWithContext is the same as UpdateItem with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateItem for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) UpdateItemWithContext(ctx aws.Context, input *UpdateItemInput, opts ...request.Option) (*UpdateItemOutput, error) {
	req, out := c.UpdateItemRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateTable = "UpdateTable"

// UpdateTableRequest generates a "aws/request.Request" representing the
// client's request for the UpdateTable operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateTable for more information on using the UpdateTable
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateTableRequest method.
//    req, resp := client.UpdateTableRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTable
func (c *DynamoDB) UpdateTableRequest(input *UpdateTableInput) (req *request.Request, output *UpdateTableOutput) {
	op := &request.Operation{
		Name:       opUpdateTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateTableInput{}
	}

	output = &UpdateTableOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// UpdateTable API operation for Amazon DynamoDB.
//
// Modifies the provisioned throughput settings, global secondary indexes, or
// DynamoDB Streams settings for a given table.
//
// You can only perform one of the following operations at once:
//
//    * Modify the provisioned throughput settings of the table.
//
//    * Enable or disable DynamoDB Streams on the table.
//
//    * Remove a global secondary index from the table.
//
//    * Create a new global secondary index on the table. After the index begins
//    backfilling, you can use UpdateTable to perform other operations.
//
// UpdateTable is an asynchronous operation; while it is executing, the table
// status changes from ACTIVE to UPDATING. While it is UPDATING, you cannot
// issue another UpdateTable request. When the table returns to the ACTIVE state,
// the UpdateTable operation is complete.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation UpdateTable for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceInUseException "ResourceInUseException"
//   The operation conflicts with the resource's availability. For example, you
//   attempted to recreate an existing table, or tried to delete a table currently
//   in the CREATING state.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTable
func (c *DynamoDB) UpdateTable(input *UpdateTableInput) (*UpdateTableOutput, error) {
	req, out := c.UpdateTableRequest(input)
	return out, req.Send()
}

// UpdateTableWithContext is the same as UpdateTable with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateTable for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) UpdateTableWithContext(ctx aws.Context, input *UpdateTableInput, opts ...request.Option) (*UpdateTableOutput, error) {
	req, out := c.UpdateTableRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateTimeToLive = "UpdateTimeToLive"

// UpdateTimeToLiveRequest generates a "aws/request.Request" representing the
// client's request for the UpdateTimeToLive operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateTimeToLive for more information on using the UpdateTimeToLive
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateTimeToLiveRequest method.
//    req, resp := client.UpdateTimeToLiveRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTimeToLive
func (c *DynamoDB) UpdateTimeToLiveRequest(input *UpdateTimeToLiveInput) (req *request.Request, output *UpdateTimeToLiveOutput) {
	op := &request.Operation{
		Name:       opUpdateTimeToLive,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateTimeToLiveInput{}
	}

	output = &UpdateTimeToLiveOutput{}
	req = c.newRequest(op, input, output)
	if aws.BoolValue(req.Config.EnableEndpointDiscovery) {
		de := discovererDescribeEndpoints{
			Required:      false,
			EndpointCache: c.endpointCache,
			Params: map[string]*string{
				"op": aws.String(req.Operation.Name),
			},
			Client: c,
		}

		for k, v := range de.Params {
			if v == nil {
				delete(de.Params, k)
			}
		}

		req.Handlers.Build.PushFrontNamed(request.NamedHandler{
			Name: "crr.endpointdiscovery",
			Fn:   de.Handler,
		})
	}
	return
}

// UpdateTimeToLive API operation for Amazon DynamoDB.
//
// The UpdateTimeToLive method enables or disables Time to Live (TTL) for the
// specified table. A successful UpdateTimeToLive call returns the current TimeToLiveSpecification.
// It can take up to one hour for the change to fully process. Any additional
// UpdateTimeToLive calls for the same table during this one hour duration result
// in a ValidationException.
//
// TTL compares the current time in epoch time format to the time stored in
// the TTL attribute of an item. If the epoch time value stored in the attribute
// is less than the current time, the item is marked as expired and subsequently
// deleted.
//
// The epoch time format is the number of seconds elapsed since 12:00:00 AM
// January 1, 1970 UTC.
//
// DynamoDB deletes expired items on a best-effort basis to ensure availability
// of throughput for other data operations.
//
// DynamoDB typically deletes expired items within two days of expiration. The
// exact duration within which an item gets deleted after expiration is specific
// to the nature of the workload. Items that have expired and not been deleted
// will still show up in reads, queries, and scans.
//
// As items are deleted, they are removed from any local secondary index and
// global secondary index immediately in the same eventually consistent way
// as a standard delete operation.
//
// For more information, see Time To Live (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html)
// in the Amazon DynamoDB Developer Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for Amazon DynamoDB's
// API operation UpdateTimeToLive for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeResourceInUseException "ResourceInUseException"
//   The operation conflicts with the resource's availability. For example, you
//   attempted to recreate an existing table, or tried to delete a table currently
//   in the CREATING state.
//
//   * ErrCodeResourceNotFoundException "ResourceNotFoundException"
//   The operation tried to access a nonexistent table or index. The resource
//   might not be specified correctly, or its status might not be ACTIVE.
//
//   * ErrCodeLimitExceededException "LimitExceededException"
//   There is no limit to the number of daily on-demand backups that can be taken.
//
//   Up to 50 simultaneous table operations are allowed per account. These operations
//   include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup,
//   and RestoreTableToPointInTime.
//
//   The only exception is when you are creating a table with one or more secondary
//   indexes. You can have up to 25 such requests running at a time; however,
//   if the table or index specifications are complex, DynamoDB might temporarily
//   reduce the number of concurrent operations.
//
//   There is a soft account limit of 256 tables.
//
//   * ErrCodeInternalServerError "InternalServerError"
//   An error occurred on the server side.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTimeToLive
func (c *DynamoDB) UpdateTimeToLive(input *UpdateTimeToLiveInput) (*UpdateTimeToLiveOutput, error) {
	req, out := c.UpdateTimeToLiveRequest(input)
	return out, req.Send()
}

// UpdateTimeToLiveWithContext is the same as UpdateTimeToLive with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateTimeToLive for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *DynamoDB) UpdateTimeToLiveWithContext(ctx aws.Context, input *UpdateTimeToLiveInput, opts ...request.Option) (*UpdateTimeToLiveOutput, error) {
	req, out := c.UpdateTimeToLiveRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// Represents an attribute for describing the key schema for the table and indexes.
type AttributeDefinition struct {
	_ struct{} `type:"structure"`

	// A name for the attribute.
	//
	// AttributeName is a required field
	AttributeName *string `min:"1" type:"string" required:"true"`

	// The data type for the attribute, where:
	//
	//    * S - the attribute is of type String
	//
	//    * N - the attribute is of type Number
	//
	//    * B - the attribute is of type Binary
	//
	// AttributeType is a required field
	AttributeType *string `type:"string" required:"true" enum:"ScalarAttributeType"`
}

// String returns the string representation
func (s AttributeDefinition) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeDefinition) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttributeDefinition) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "AttributeDefinition"}
	if s.AttributeName == nil {
		invalidParams.Add(request.NewErrParamRequired("AttributeName"))
	}
	if s.AttributeName != nil && len(*s.AttributeName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("AttributeName", 1))
	}
	if s.AttributeType == nil {
		invalidParams.Add(request.NewErrParamRequired("AttributeType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAttributeName sets the AttributeName field's value.
func (s *AttributeDefinition) SetAttributeName(v string) *AttributeDefinition {
	s.AttributeName = &v
	return s
}

// SetAttributeType sets the AttributeType field's value.
func (s *AttributeDefinition) SetAttributeType(v string) *AttributeDefinition {
	s.AttributeType = &v
	return s
}

// Represents the data for an attribute.
//
// Each attribute value is described as a name-value pair. The name is the data
// type, and the value is the data itself.
//
// For more information, see Data Types (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes)
// in the Amazon DynamoDB Developer Guide.
type AttributeValue struct {
	_ struct{} `type:"structure"`

	// An attribute of type Binary. For example:
	//
	// "B": "dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk"
	//
	// B is automatically base64 encoded/decoded by the SDK.
	B []byte `type:"blob"`

	// An attribute of type Boolean. For example:
	//
	// "BOOL": true
	BOOL *bool `type:"boolean"`

	// An attribute of type Binary Set. For example:
	//
	// "BS": ["U3Vubnk=", "UmFpbnk=", "U25vd3k="]
	BS [][]byte `type:"list"`

	// An attribute of type List. For example:
	//
	// "L": [ {"S": "Cookies"} , {"S": "Coffee"}, {"N", "3.14159"}]
	L []*AttributeValue `type:"list"`

	// An attribute of type Map. For example:
	//
	// "M": {"Name": {"S": "Joe"}, "Age": {"N": "35"}}
	M map[string]*AttributeValue `type:"map"`

	// An attribute of type Number. For example:
	//
	// "N": "123.45"
	//
	// Numbers are sent across the network to DynamoDB as strings, to maximize compatibility
	// across languages and libraries. However, DynamoDB treats them as number type
	// attributes for mathematical operations.
	N *string `type:"string"`

	// An attribute of type Number Set. For example:
	//
	// "NS": ["42.2", "-19", "7.5", "3.14"]
	//
	// Numbers are sent across the network to DynamoDB as strings, to maximize compatibility
	// across languages and libraries. However, DynamoDB treats them as number type
	// attributes for mathematical operations.
	NS []*string `type:"list"`

	// An attribute of type Null. For example:
	//
	// "NULL": true
	NULL *bool `type:"boolean"`

	// An attribute of type String. For example:
	//
	// "S": "Hello"
	S *string `type:"string"`

	// An attribute of type String Set. For example:
	//
	// "SS": ["Giraffe", "Hippo" ,"Zebra"]
	SS []*string `type:"list"`
}

// String returns the string representation
func (s AttributeValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeValue) GoString() string {
	return s.String()
}

// SetB sets the B field's value.
func (s *AttributeValue) SetB(v []byte) *AttributeValue {
	s.B = v
	return s
}

// SetBOOL sets the BOOL field's value.
func (s *AttributeValue) SetBOOL(v bool) *AttributeValue {
	s.BOOL = &v
	return s
}

// SetBS sets the BS field's value.
func (s *AttributeValue) SetBS(v [][]byte) *AttributeValue {
	s.BS = v
	return s
}

// SetL sets the L field's value.
func (s *AttributeValue) SetL(v []*AttributeValue) *AttributeValue {
	s.L = v
	return s
}

// SetM sets the M field's value.
func (s *AttributeValue) SetM(v map[string]*AttributeValue) *AttributeValue {
	s.M = v
	return s
}

// SetN sets the N field's value.
func (s *AttributeValue) SetN(v string) *AttributeValue {
	s.N = &v
	return s
}

// SetNS sets the NS field's value.
func (s *AttributeValue) SetNS(v []*string) *AttributeValue {
	s.NS = v
	return s
}

// SetNULL sets the NULL field's value.
func (s *AttributeValue) SetNULL(v bool) *AttributeValue {
	s.NULL = &v
	return s
}

// SetS sets the S field's value.
func (s *AttributeValue) SetS(v string) *AttributeValue {
	s.S = &v
	return s
}

// SetSS sets the SS field's value.
func (s *AttributeValue) SetSS(v []*string) *AttributeValue {
	s.SS = v
	return s
}

// For the UpdateItem operation, represents the attributes to be modified, the
// action to perform on each, and the new value for each.
//
// You cannot use UpdateItem to update any primary key attributes. Instead,
// you will need to delete the item, and then use PutItem to create a new item
// with new attributes.
//
// Attribute values cannot be null; string and binary type attributes must have
// lengths greater than zero; and set type attributes must not be empty. Requests
// with empty values will be rejected with a ValidationException exception.
type AttributeValueUpdate struct {
	_ struct{} `type:"structure"`

	// Specifies how to perform the update. Valid values are PUT (default), DELETE,
	// and ADD. The behavior depends on whether the specified primary key already
	// exists in the table.
	//
	// If an item with the specified Key is found in the table:
	//
	//    * PUT - Adds the specified attribute to the item. If the attribute already
	//    exists, it is replaced by the new value.
	//
	//    * DELETE - If no value is specified, the attribute and its value are removed
	//    from the item. The data type of the specified value must match the existing
	//    value's data type. If a set of values is specified, then those values
	//    are subtracted from the old set. For example, if the attribute value was
	//    the set [a,b,c] and the DELETE action specified [a,c], then the final
	//    attribute value would be [b]. Specifying an empty set is an error.
	//
	//    * ADD - If the attribute does not already exist, then the attribute and
	//    its values are added to the item. If the attribute does exist, then the
	//    behavior of ADD depends on the data type of the attribute: If the existing
	//    attribute is a number, and if Value is also a number, then the Value is
	//    mathematically added to the existing attribute. If Value is a negative
	//    number, then it is subtracted from the existing attribute. If you use
	//    ADD to increment or decrement a number value for an item that doesn't
	//    exist before the update, DynamoDB uses 0 as the initial value. In addition,
	//    if you use ADD to update an existing item, and intend to increment or
	//    decrement an attribute value which does not yet exist, DynamoDB uses 0
	//    as the initial value. For example, suppose that the item you want to update
	//    does not yet have an attribute named itemcount, but you decide to ADD
	//    the number 3 to this attribute anyway, even though it currently does not
	//    exist. DynamoDB will create the itemcount attribute, set its initial value
	//    to 0, and finally add 3 to it. The result will be a new itemcount attribute
	//    in the item, with a value of 3. If the existing data type is a set, and
	//    if the Value is also a set, then the Value is added to the existing set.
	//    (This is a set operation, not mathematical addition.) For example, if
	//    the attribute value was the set [1,2], and the ADD action specified [3],
	//    then the final attribute value would be [1,2,3]. An error occurs if an
	//    Add action is specified for a set attribute and the attribute type specified
	//    does not match the existing set type. Both sets must have the same primitive
	//    data type. For example, if the existing data type is a set of strings,
	//    the Value must also be a set of strings. The same holds true for number
	//    sets and binary sets. This action is only valid for an existing attribute
	//    whose data type is number or is a set. Do not use ADD for any other data
	//    types.
	//
	// If no item with the specified Key is found:
	//
	//    * PUT - DynamoDB creates a new item with the specified primary key, and
	//    then adds the attribute.
	//
	//    * DELETE - Nothing happens; there is no attribute to delete.
	//
	//    * ADD - DynamoDB creates an item with the supplied primary key and number
	//    (or set of numbers) for the attribute value. The only data types allowed
	//    are number and number set; no other data types can be specified.
	Action *string `type:"string" enum:"AttributeAction"`

	// Represents the data for an attribute.
	//
	// Each attribute value is described as a name-value pair. The name is the data
	// type, and the value is the data itself.
	//
	// For more information, see Data Types (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes)
	// in the Amazon DynamoDB Developer Guide.
	Value *AttributeValue `type:"structure"`
}

// String returns the string representation
func (s AttributeValueUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeValueUpdate) GoString() string {
	return s.String()
}

// SetAction sets the Action field's value.
func (s *AttributeValueUpdate) SetAction(v string) *AttributeValueUpdate {
	s.Action = &v
	return s
}

// SetValue sets the Value field's value.
func (s *AttributeValueUpdate) SetValue(v *AttributeValue) *AttributeValueUpdate {
	s.Value = v
	return s
}

// Represents the properties of the scaling policy.
type AutoScalingPolicyDescription struct {
	_ struct{} `type:"structure"`

	// The name of the scaling policy.
	PolicyName *string `min:"1" type:"string"`

	// Represents a target tracking scaling policy configuration.
	TargetTrackingScalingPolicyConfiguration *AutoScalingTargetTrackingScalingPolicyConfigurationDescription `type:"structure"`
}

// String returns the string representation
func (s AutoScalingPolicyDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingPolicyDescription) GoString() string {
	return s.String()
}

// SetPolicyName sets the PolicyName field's value.
func (s *AutoScalingPolicyDescription) SetPolicyName(v string) *AutoScalingPolicyDescription {
	s.PolicyName = &v
	return s
}

// SetTargetTrackingScalingPolicyConfiguration sets the TargetTrackingScalingPolicyConfiguration field's value.
func (s *AutoScalingPolicyDescription) SetTargetTrackingScalingPolicyConfiguration(v *AutoScalingTargetTrackingScalingPolicyConfigurationDescription) *AutoScalingPolicyDescription {
	s.TargetTrackingScalingPolicyConfiguration = v
	return s
}

// Represents the autoscaling policy to be modified.
type AutoScalingPolicyUpdate struct {
	_ struct{} `type:"structure"`

	// The name of the scaling policy.
	PolicyName *string `min:"1" type:"string"`

	// Represents a target tracking scaling policy configuration.
	//
	// TargetTrackingScalingPolicyConfiguration is a required field
	TargetTrackingScalingPolicyConfiguration *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate `type:"structure" required:"true"`
}

// String returns the string representation
func (s AutoScalingPolicyUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingPolicyUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AutoScalingPolicyUpdate) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "AutoScalingPolicyUpdate"}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("PolicyName", 1))
	}
	if s.TargetTrackingScalingPolicyConfiguration == nil {
		invalidParams.Add(request.NewErrParamRequired("TargetTrackingScalingPolicyConfiguration"))
	}
	if s.TargetTrackingScalingPolicyConfiguration != nil {
		if err := s.TargetTrackingScalingPolicyConfiguration.Validate(); err != nil {
			invalidParams.AddNested("TargetTrackingScalingPolicyConfiguration", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetPolicyName sets the PolicyName field's value.
func (s *AutoScalingPolicyUpdate) SetPolicyName(v string) *AutoScalingPolicyUpdate {
	s.PolicyName = &v
	return s
}

// SetTargetTrackingScalingPolicyConfiguration sets the TargetTrackingScalingPolicyConfiguration field's value.
func (s *AutoScalingPolicyUpdate) SetTargetTrackingScalingPolicyConfiguration(v *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) *AutoScalingPolicyUpdate {
	s.TargetTrackingScalingPolicyConfiguration = v
	return s
}

// Represents the autoscaling settings for a global table or global secondary
// index.
type AutoScalingSettingsDescription struct {
	_ struct{} `type:"structure"`

	// Disabled autoscaling for this global table or global secondary index.
	AutoScalingDisabled *bool `type:"boolean"`

	// Role ARN used for configuring autoScaling policy.
	AutoScalingRoleArn *string `type:"string"`

	// The maximum capacity units that a global table or global secondary index
	// should be scaled up to.
	MaximumUnits *int64 `min:"1" type:"long"`

	// The minimum capacity units that a global table or global secondary index
	// should be scaled down to.
	MinimumUnits *int64 `min:"1" type:"long"`

	// Information about the scaling policies.
	ScalingPolicies []*AutoScalingPolicyDescription `type:"list"`
}

// String returns the string representation
func (s AutoScalingSettingsDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingSettingsDescription) GoString() string {
	return s.String()
}

// SetAutoScalingDisabled sets the AutoScalingDisabled field's value.
func (s *AutoScalingSettingsDescription) SetAutoScalingDisabled(v bool) *AutoScalingSettingsDescription {
	s.AutoScalingDisabled = &v
	return s
}

// SetAutoScalingRoleArn sets the AutoScalingRoleArn field's value.
func (s *AutoScalingSettingsDescription) SetAutoScalingRoleArn(v string) *AutoScalingSettingsDescription {
	s.AutoScalingRoleArn = &v
	return s
}

// SetMaximumUnits sets the MaximumUnits field's value.
func (s *AutoScalingSettingsDescription) SetMaximumUnits(v int64) *AutoScalingSettingsDescription {
	s.MaximumUnits = &v
	return s
}

// SetMinimumUnits sets the MinimumUnits field's value.
func (s *AutoScalingSettingsDescription) SetMinimumUnits(v int64) *AutoScalingSettingsDescription {
	s.MinimumUnits = &v
	return s
}

// SetScalingPolicies sets the ScalingPolicies field's value.
func (s *AutoScalingSettingsDescription) SetScalingPolicies(v []*AutoScalingPolicyDescription) *AutoScalingSettingsDescription {
	s.ScalingPolicies = v
	return s
}

// Represents the autoscaling settings to be modified for a global table or
// global secondary index.
type AutoScalingSettingsUpdate struct {
	_ struct{} `type:"structure"`

	// Disabled autoscaling for this global table or global secondary index.
	AutoScalingDisabled *bool `type:"boolean"`

	// Role ARN used for configuring autoscaling policy.
	AutoScalingRoleArn *string `min:"1" type:"string"`

	// The maximum capacity units that a global table or global secondary index
	// should be scaled up to.
	MaximumUnits *int64 `min:"1" type:"long"`

	// The minimum capacity units that a global table or global secondary index
	// should be scaled down to.
	MinimumUnits *int64 `min:"1" type:"long"`

	// The scaling policy to apply for scaling target global table or global secondary
	// index capacity units.
	ScalingPolicyUpdate *AutoScalingPolicyUpdate `type:"structure"`
}

// String returns the string representation
func (s AutoScalingSettingsUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingSettingsUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AutoScalingSettingsUpdate) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "AutoScalingSettingsUpdate"}
	if s.AutoScalingRoleArn != nil && len(*s.AutoScalingRoleArn) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("AutoScalingRoleArn", 1))
	}
	if s.MaximumUnits != nil && *s.MaximumUnits < 1 {
		invalidParams.Add(request.NewErrParamMinValue("MaximumUnits", 1))
	}
	if s.MinimumUnits != nil && *s.MinimumUnits < 1 {
		invalidParams.Add(request.NewErrParamMinValue("MinimumUnits", 1))
	}
	if s.ScalingPolicyUpdate != nil {
		if err := s.ScalingPolicyUpdate.Validate(); err != nil {
			invalidParams.AddNested("ScalingPolicyUpdate", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAutoScalingDisabled sets the AutoScalingDisabled field's value.
func (s *AutoScalingSettingsUpdate) SetAutoScalingDisabled(v bool) *AutoScalingSettingsUpdate {
	s.AutoScalingDisabled = &v
	return s
}

// SetAutoScalingRoleArn sets the AutoScalingRoleArn field's value.
func (s *AutoScalingSettingsUpdate) SetAutoScalingRoleArn(v string) *AutoScalingSettingsUpdate {
	s.AutoScalingRoleArn = &v
	return s
}

// SetMaximumUnits sets the MaximumUnits field's value.
func (s *AutoScalingSettingsUpdate) SetMaximumUnits(v int64) *AutoScalingSettingsUpdate {
	s.MaximumUnits = &v
	return s
}

// SetMinimumUnits sets the MinimumUnits field's value.
func (s *AutoScalingSettingsUpdate) SetMinimumUnits(v int64) *AutoScalingSettingsUpdate {
	s.MinimumUnits = &v
	return s
}

// SetScalingPolicyUpdate sets the ScalingPolicyUpdate field's value.
func (s *AutoScalingSettingsUpdate) SetScalingPolicyUpdate(v *AutoScalingPolicyUpdate) *AutoScalingSettingsUpdate {
	s.ScalingPolicyUpdate = v
	return s
}

// Represents the properties of a target tracking scaling policy.
type AutoScalingTargetTrackingScalingPolicyConfigurationDescription struct {
	_ struct{} `type:"structure"`

	// Indicates whether scale in by the target tracking policy is disabled. If
	// the value is true, scale in is disabled and the target tracking policy won't
	// remove capacity from the scalable resource. Otherwise, scale in is enabled
	// and the target tracking policy can remove capacity from the scalable resource.
	// The default value is false.
	DisableScaleIn *bool `type:"boolean"`

	// The amount of time, in seconds, after a scale in activity completes before
	// another scale in activity can start. The cooldown period is used to block
	// subsequent scale in requests until it has expired. You should scale in conservatively
	// to protect your application's availability. However, if another alarm triggers
	// a scale out policy during the cooldown period after a scale-in, application
	// autoscaling scales out your scalable target immediately.
	ScaleInCooldown *int64 `type:"integer"`

	// The amount of time, in seconds, after a scale out activity completes before
	// another scale out activity can start. While the cooldown period is in effect,
	// the capacity that has been added by the previous scale out event that initiated
	// the cooldown is calculated as part of the desired capacity for the next scale
	// out. You should continuously (but not excessively) scale out.
	ScaleOutCooldown *int64 `type:"integer"`

	// The target value for the metric. The range is 8.515920e-109 to 1.174271e+108
	// (Base 10) or 2e-360 to 2e360 (Base 2).
	//
	// TargetValue is a required field
	TargetValue *float64 `type:"double" required:"true"`
}

// String returns the string representation
func (s AutoScalingTargetTrackingScalingPolicyConfigurationDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingTargetTrackingScalingPolicyConfigurationDescription) GoString() string {
	return s.String()
}

// SetDisableScaleIn sets the DisableScaleIn field's value.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationDescription) SetDisableScaleIn(v bool) *AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
	s.DisableScaleIn = &v
	return s
}

// SetScaleInCooldown sets the ScaleInCooldown field's value.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationDescription) SetScaleInCooldown(v int64) *AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
	s.ScaleInCooldown = &v
	return s
}

// SetScaleOutCooldown sets the ScaleOutCooldown field's value.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationDescription) SetScaleOutCooldown(v int64) *AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
	s.ScaleOutCooldown = &v
	return s
}

// SetTargetValue sets the TargetValue field's value.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationDescription) SetTargetValue(v float64) *AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
	s.TargetValue = &v
	return s
}

// Represents the settings of a target tracking scaling policy that will be
// modified.
type AutoScalingTargetTrackingScalingPolicyConfigurationUpdate struct {
	_ struct{} `type:"structure"`

	// Indicates whether scale in by the target tracking policy is disabled. If
	// the value is true, scale in is disabled and the target tracking policy won't
	// remove capacity from the scalable resource. Otherwise, scale in is enabled
	// and the target tracking policy can remove capacity from the scalable resource.
	// The default value is false.
	DisableScaleIn *bool `type:"boolean"`

	// The amount of time, in seconds, after a scale in activity completes before
	// another scale in activity can start. The cooldown period is used to block
	// subsequent scale in requests until it has expired. You should scale in conservatively
	// to protect your application's availability. However, if another alarm triggers
	// a scale out policy during the cooldown period after a scale-in, application
	// autoscaling scales out your scalable target immediately.
	ScaleInCooldown *int64 `type:"integer"`

	// The amount of time, in seconds, after a scale out activity completes before
	// another scale out activity can start. While the cooldown period is in effect,
	// the capacity that has been added by the previous scale out event that initiated
	// the cooldown is calculated as part of the desired capacity for the next scale
	// out. You should continuously (but not excessively) scale out.
	ScaleOutCooldown *int64 `type:"integer"`

	// The target value for the metric. The range is 8.515920e-109 to 1.174271e+108
	// (Base 10) or 2e-360 to 2e360 (Base 2).
	//
	// TargetValue is a required field
	TargetValue *float64 `type:"double" required:"true"`
}

// String returns the string representation
func (s AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "AutoScalingTargetTrackingScalingPolicyConfigurationUpdate"}
	if s.TargetValue == nil {
		invalidParams.Add(request.NewErrParamRequired("TargetValue"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDisableScaleIn sets the DisableScaleIn field's value.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) SetDisableScaleIn(v bool) *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
	s.DisableScaleIn = &v
	return s
}

// SetScaleInCooldown sets the ScaleInCooldown field's value.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) SetScaleInCooldown(v int64) *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
	s.ScaleInCooldown = &v
	return s
}

// SetScaleOutCooldown sets the ScaleOutCooldown field's value.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) SetScaleOutCooldown(v int64) *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
	s.ScaleOutCooldown = &v
	return s
}

// SetTargetValue sets the TargetValue field's value.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) SetTargetValue(v float64) *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
	s.TargetValue = &v
	return s
}

// Contains the description of the backup created for the table.
type BackupDescription struct {
	_ struct{} `type:"structure"`

	// Contains the details of the backup created for the table.
	BackupDetails *BackupDetails `type:"structure"`

	// Contains the details of the table when the backup was created.
	SourceTableDetails *SourceTableDetails `type:"structure"`

	// Contains the details of the features enabled on the table when the backup
	// was created. For example, LSIs, GSIs, streams, TTL.
	SourceTableFeatureDetails *SourceTableFeatureDetails `type:"structure"`
}

// String returns the string representation
func (s BackupDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BackupDescription) GoString() string {
	return s.String()
}

// SetBackupDetails sets the BackupDetails field's value.
func (s *BackupDescription) SetBackupDetails(v *BackupDetails) *BackupDescription {
	s.BackupDetails = v
	return s
}

// SetSourceTableDetails sets the SourceTableDetails field's value.
func (s *BackupDescription) SetSourceTableDetails(v *SourceTableDetails) *BackupDescription {
	s.SourceTableDetails = v
	return s
}

// SetSourceTableFeatureDetails sets the SourceTableFeatureDetails field's value.
func (s *BackupDescription) SetSourceTableFeatureDetails(v *SourceTableFeatureDetails) *BackupDescription {
	s.SourceTableFeatureDetails = v
	return s
}

// Contains the details of the backup created for the table.
type BackupDetails struct {
	_ struct{} `type:"structure"`

	// ARN associated with the backup.
	//
	// BackupArn is a required field
	BackupArn *string `min:"37" type:"string" required:"true"`

	// Time at which the backup was created. This is the request time of the backup.
	//
	// BackupCreationDateTime is a required field
	BackupCreationDateTime *time.Time `type:"timestamp" required:"true"`

	// Time at which the automatic on-demand backup created by DynamoDB will expire.
	// This SYSTEM on-demand backup expires automatically 35 days after its creation.
	BackupExpiryDateTime *time.Time `type:"timestamp"`

	// Name of the requested backup.
	//
	// BackupName is a required field
	BackupName *string `min:"3" type:"string" required:"true"`

	// Size of the backup in bytes.
	BackupSizeBytes *int64 `type:"long"`

	// Backup can be in one of the following states: CREATING, ACTIVE, DELETED.
	//
	// BackupStatus is a required field
	BackupStatus *string `type:"string" required:"true" enum:"BackupStatus"`

	// BackupType:
	//
	//    * USER - You create and manage these using the on-demand backup feature.
	//
	//    * SYSTEM - If you delete a table with point-in-time recovery enabled,
	//    a SYSTEM backup is automatically created and is retained for 35 days (at
	//    no additional cost). System backups allow you to restore the deleted table
	//    to the state it was in just before the point of deletion.
	//
	//    * AWS_BACKUP - On-demand backup created by you from AWS Backup service.
	//
	// BackupType is a required field
	BackupType *string `type:"string" required:"true" enum:"BackupType"`
}

// String returns the string representation
func (s BackupDetails) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BackupDetails) GoString() string {
	return s.String()
}

// SetBackupArn sets the BackupArn field's value.
func (s *BackupDetails) SetBackupArn(v string) *BackupDetails {
	s.BackupArn = &v
	return s
}

// SetBackupCreationDateTime sets the BackupCreationDateTime field's value.
func (s *BackupDetails) SetBackupCreationDateTime(v time.Time) *BackupDetails {
	s.BackupCreationDateTime = &v
	return s
}

// SetBackupExpiryDateTime sets the BackupExpiryDateTime field's value.
func (s *BackupDetails) SetBackupExpiryDateTime(v time.Time) *BackupDetails {
	s.BackupExpiryDateTime = &v
	return s
}

// SetBackupName sets the BackupName field's value.
func (s *BackupDetails) SetBackupName(v string) *BackupDetails {
	s.BackupName = &v
	return s
}

// SetBackupSizeBytes sets the BackupSizeBytes field's value.
func (s *BackupDetails) SetBackupSizeBytes(v int64) *BackupDetails {
	s.BackupSizeBytes = &v
	return s
}

// SetBackupStatus sets the BackupStatus field's value.
func (s *BackupDetails) SetBackupStatus(v string) *BackupDetails {
	s.BackupStatus = &v
	return s
}

// SetBackupType sets the BackupType field's value.
func (s *BackupDetails) SetBackupType(v string) *BackupDetails {
	s.BackupType = &v
	return s
}

// Contains details for the backup.
type BackupSummary struct {
	_ struct{} `type:"structure"`

	// ARN associated with the backup.
	BackupArn *string `min:"37" type:"string"`

	// Time at which the backup was created.
	BackupCreationDateTime *time.Time `type:"timestamp"`

	// Time at which the automatic on-demand backup created by DynamoDB will expire.
	// This SYSTEM on-demand backup expires automatically 35 days after its creation.
	BackupExpiryDateTime *time.Time `type:"timestamp"`

	// Name of the specified backup.
	BackupName *string `min:"3" type:"string"`

	// Size of the backup in bytes.
	BackupSizeBytes *int64 `type:"long"`

	// Backup can be in one of the following states: CREATING, ACTIVE, DELETED.
	BackupStatus *string `type:"string" enum:"BackupStatus"`

	// BackupType:
	//
	//    * USER - You create and manage these using the on-demand backup feature.
	//
	//    * SYSTEM - If you delete a table with point-in-time recovery enabled,
	//    a SYSTEM backup is automatically created and is retained for 35 days (at
	//    no additional cost). System backups allow you to restore the deleted table
	//    to the state it was in just before the point of deletion.
	//
	//    * AWS_BACKUP - On-demand backup created by you from AWS Backup service.
	BackupType *string `type:"string" enum:"BackupType"`

	// ARN associated with the table.
	TableArn *string `type:"string"`

	// Unique identifier for the table.
	TableId *string `type:"string"`

	// Name of the table.
	TableName *string `min:"3" type:"string"`
}

// String returns the string representation
func (s BackupSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BackupSummary) GoString() string {
	return s.String()
}

// SetBackupArn sets the BackupArn field's value.
func (s *BackupSummary) SetBackupArn(v string) *BackupSummary {
	s.BackupArn = &v
	return s
}

// SetBackupCreationDateTime sets the BackupCreationDateTime field's value.
func (s *BackupSummary) SetBackupCreationDateTime(v time.Time) *BackupSummary {
	s.BackupCreationDateTime = &v
	return s
}

// SetBackupExpiryDateTime sets the BackupExpiryDateTime field's value.
func (s *BackupSummary) SetBackupExpiryDateTime(v time.Time) *BackupSummary {
	s.BackupExpiryDateTime = &v
	return s
}

// SetBackupName sets the BackupName field's value.
func (s *BackupSummary) SetBackupName(v string) *BackupSummary {
	s.BackupName = &v
	return s
}

// SetBackupSizeBytes sets the BackupSizeBytes field's value.
func (s *BackupSummary) SetBackupSizeBytes(v int64) *BackupSummary {
	s.BackupSizeBytes = &v
	return s
}

// SetBackupStatus sets the BackupStatus field's value.
func (s *BackupSummary) SetBackupStatus(v string) *BackupSummary {
	s.BackupStatus = &v
	return s
}

// SetBackupType sets the BackupType field's value.
func (s *BackupSummary) SetBackupType(v string) *BackupSummary {
	s.BackupType = &v
	return s
}

// SetTableArn sets the TableArn field's value.
func (s *BackupSummary) SetTableArn(v string) *BackupSummary {
	s.TableArn = &v
	return s
}

// SetTableId sets the TableId field's value.
func (s *BackupSummary) SetTableId(v string) *BackupSummary {
	s.TableId = &v
	return s
}

// SetTableName sets the TableName field's value.
func (s *BackupSummary) SetTableName(v string) *BackupSummary {
	s.TableName = &v
	return s
}

// Represents the input of a BatchGetItem operation.
type BatchGetItemInput struct {
	_ struct{} `type:"structure"`

	// A map of one or more table names and, for each table, a map that describes
	// one or more items to retrieve from that table. Each table name can be used
	// only once per BatchGetItem request.
	//
	// Each element in the map of items to retrieve consists of the following:
	//
	//    * ConsistentRead - If true, a strongly consistent read is used; if false
	//    (the default), an eventually consistent read is used.
	//
	//    * ExpressionAttributeNames - One or more substitution tokens for attribute
	//    names in the ProjectionExpression parameter. The following are some use
	//    cases for using ExpressionAttributeNames: To access an attribute whose
	//    name conflicts with a DynamoDB reserved word. To create a placeholder
	//    for repeating occurrences of an attribute name in an expression. To prevent
	//    special characters in an attribute name from being misinterpreted in an
	//    expression. Use the # character in an expression to dereference an attribute
	//    name. For example, consider the following attribute name: Percentile The
	//    name of this attribute conflicts with a reserved word, so it cannot be
	//    used directly in an expression. (For the complete list of reserved words,
	//    see Reserved Words (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	//    in the Amazon DynamoDB Developer Guide). To work around this, you could
	//    specify the following for ExpressionAttributeNames: {"#P":"Percentile"}
	//    You could then use this substitution in an expression, as in this example:
	//    #P = :val Tokens that begin with the : character are expression attribute
	//    values, which are placeholders for the actual value at runtime. For more
	//    information about expression attribute names, see Accessing Item Attributes
	//    (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	//    in the Amazon DynamoDB Developer Guide.
	//
	//    * Keys - An array of primary key attribute values that define specific
	//    items in the table. For each primary key, you must provide all of the
	//    key attributes. For example, with a simple primary key, you only need
	//    to provide the partition key value. For a composite key, you must provide
	//    both the partition key value and the sort key value.
	//
	//    * ProjectionExpression - A string that identifies one or more attributes
	//    to retrieve from the table. These attributes can include scalars, sets,
	//    or elements of a JSON document. The attributes in the expression must
	//    be separated by commas. If no attribute names are specified, then all
	//    attributes are returned. If any of the requested attributes are not found,
	//    they do not appear in the result. For more information, see Accessing
	//    Item Attributes (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	//    in the Amazon DynamoDB Developer Guide.
	//
	//    * AttributesToGet - This is a legacy parameter. Use ProjectionExpression
	//    instead. For more information, see AttributesToGet (https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html)
	//    in the Amazon DynamoDB Developer Guide.
	//
	// RequestItems is a required field
	RequestItems map[string]*KeysAndAttributes `min:"1" type:"map" required:"true"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed. Note that some operations, such as GetItem and
	//    BatchGetItem, do not access any indexes at all. In these cases, specifying
	//    INDEXES will only return ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity *string `type:"string" enum:"ReturnConsumedCapacity"`
}

// String returns the string representation
func (s BatchGetItemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetItemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetItemInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchGetItemInput"}
	if s.RequestItems == nil {
		invalidParams.Add(request.NewErrParamRequired("RequestItems"))
	}
	if s.RequestItems != nil && len(s.RequestItems) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RequestItems", 1))
	}
	if s.RequestItems != nil {
		for i, v := range s.RequestItems {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "RequestItems", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRequestItems sets the RequestItems field's value.
func (s *BatchGetItemInput) SetRequestItems(v map[string]*KeysAndAttributes) *BatchGetItemInput {
	s.RequestItems = v
	return s
}

// SetReturnConsumedCapacity sets the ReturnConsumedCapacity field's value.
func (s *BatchGetItemInput) SetReturnConsumedCapacity(v string) *BatchGetItemInput {
	s.ReturnConsumedCapacity = &v
	return s
}

// Represents the output of a BatchGetItem operation.
type BatchGetItemOutput struct {
	_ struct{} `type:"structure"`

	// The read capacity units consumed by the entire BatchGetItem operation.
	//
	// Each element consists of:
	//
	//    * TableName - The table that consumed the provisioned throughput.
	//
	//    * CapacityUnits - The total number of capacity units consumed.
	ConsumedCapacity []*ConsumedCapacity `type:"list"`

	// A map of table name to a list of items. Each object in Responses consists
	// of a table name, along with a map of attribute data consisting of the data
	// type and attribute value.
	Responses map[string][]map[string]*AttributeValue `type:"map"`

	// A map of tables and their respective keys that were not processed with the
	// current response. The UnprocessedKeys value is in the same form as RequestItems,
	// so the value can be provided directly to a subsequent BatchGetItem operation.
	// For more information, see RequestItems in the Request Parameters section.
	//
	// Each element consists of:
	//
	//    * Keys - An array of primary key attribute values that define specific
	//    items in the table.
	//
	//    * ProjectionExpression - One or more attributes to be retrieved from the
	//    table or index. By default, all attributes are returned. If a requested
	//    attribute is not found, it does not appear in the result.
	//
	//    * ConsistentRead - The consistency of a read operation. If set to true,
	//    then a strongly consistent read is used; otherwise, an eventually consistent
	//    read is used.
	//
	// If there are no unprocessed keys remaining, the response contains an empty
	// UnprocessedKeys map.
	UnprocessedKeys map[string]*KeysAndAttributes `min:"1" type:"map"`
}

// String returns the string representation
func (s BatchGetItemOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetItemOutput) GoString() string {
	return s.String()
}

// SetConsumedCapacity sets the ConsumedCapacity field's value.
func (s *BatchGetItemOutput) SetConsumedCapacity(v []*ConsumedCapacity) *BatchGetItemOutput {
	s.ConsumedCapacity = v
	return s
}

// SetResponses sets the Responses field's value.
func (s *BatchGetItemOutput) SetResponses(v map[string][]map[string]*AttributeValue) *BatchGetItemOutput {
	s.Responses = v
	return s
}

// SetUnprocessedKeys sets the UnprocessedKeys field's value.
func (s *BatchGetItemOutput) SetUnprocessedKeys(v map[string]*KeysAndAttributes) *BatchGetItemOutput {
	s.UnprocessedKeys = v
	return s
}

// Represents the input of a BatchWriteItem operation.
type BatchWriteItemInput struct {
	_ struct{} `type:"structure"`

	// A map of one or more table names and, for each table, a list of operations
	// to be performed (DeleteRequest or PutRequest). Each element in the map consists
	// of the following:
	//
	//    * DeleteRequest - Perform a DeleteItem operation on the specified item.
	//    The item to be deleted is identified by a Key subelement: Key - A map
	//    of primary key attribute values that uniquely identify the item. Each
	//    entry in this map consists of an attribute name and an attribute value.
	//    For each primary key, you must provide all of the key attributes. For
	//    example, with a simple primary key, you only need to provide a value for
	//    the partition key. For a composite primary key, you must provide values
	//    for both the partition key and the sort key.
	//
	//    * PutRequest - Perform a PutItem operation on the specified item. The
	//    item to be put is identified by an Item subelement: Item - A map of attributes
	//    and their values. Each entry in this map consists of an attribute name
	//    and an attribute value. Attribute values must not be null; string and
	//    binary type attributes must have lengths greater than zero; and set type
	//    attributes must not be empty. Requests that contain empty values are rejected
	//    with a ValidationException exception. If you specify any attributes that
	//    are part of an index key, then the data types for those attributes must
	//    match those of the schema in the table's attribute definition.
	//
	// RequestItems is a required field
	RequestItems map[string][]*WriteRequest `min:"1" type:"map" required:"true"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed. Note that some operations, such as GetItem and
	//    BatchGetItem, do not access any indexes at all. In these cases, specifying
	//    INDEXES will only return ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity *string `type:"string" enum:"ReturnConsumedCapacity"`

	// Determines whether item collection metrics are returned. If set to SIZE,
	// the response includes statistics about item collections, if any, that were
	// modified during the operation are returned in the response. If set to NONE
	// (the default), no statistics are returned.
	ReturnItemCollectionMetrics *string `type:"string" enum:"ReturnItemCollectionMetrics"`
}

// String returns the string representation
func (s BatchWriteItemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchWriteItemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchWriteItemInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchWriteItemInput"}
	if s.RequestItems == nil {
		invalidParams.Add(request.NewErrParamRequired("RequestItems"))
	}
	if s.RequestItems != nil && len(s.RequestItems) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RequestItems", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRequestItems sets the RequestItems field's value.
func (s *BatchWriteItemInput) SetRequestItems(v map[string][]*WriteRequest) *BatchWriteItemInput {
	s.RequestItems = v
	return s
}

// SetReturnConsumedCapacity sets the ReturnConsumedCapacity field's value.
func (s *BatchWriteItemInput) SetReturnConsumedCapacity(v string) *BatchWriteItemInput {
	s.ReturnConsumedCapacity = &v
	return s
}

// SetReturnItemCollectionMetrics sets the ReturnItemCollectionMetrics field's value.
func (s *BatchWriteItemInput) SetReturnItemCollectionMetrics(v string) *BatchWriteItemInput {
	s.ReturnItemCollectionMetrics = &v
	return s
}

// Represents the output of a BatchWriteItem operation.
type BatchWriteItemOutput struct {
	_ struct{} `type:"structure"`

	// The capacity units consumed by the entire BatchWriteItem operation.
	//
	// Each element consists of:
	//
	//    * TableName - The table that consumed the provisioned throughput.
	//
	//    * CapacityUnits - The total number of capacity units consumed.
	ConsumedCapacity []*ConsumedCapacity `type:"list"`

	// A list of tables that were processed by BatchWriteItem and, for each table,
	// information about any item collections that were affected by individual DeleteItem
	// or PutItem operations.
	//
	// Each entry consists of the following subelements:
	//
	//    * ItemCollectionKey - The partition key value of the item collection.
	//    This is the same as the partition key value of the item.
	//
	//    * SizeEstimateRangeGB - An estimate of item collection size, expressed
	//    in GB. This is a two-element array containing a lower bound and an upper
	//    bound for the estimate. The estimate includes the size of all the items
	//    in the table, plus the size of all attributes projected into all of the
	//    local secondary indexes on the table. Use this estimate to measure whether
	//    a local secondary index is approaching its size limit. The estimate is
	//    subject to change over time; therefore, do not rely on the precision or
	//    accuracy of the estimate.
	ItemCollectionMetrics map[string][]*ItemCollectionMetrics `type:"map"`

	// A map of tables and requests against those tables that were not processed.
	// The UnprocessedItems value is in the same form as RequestItems, so you can
	// provide this value directly to a subsequent BatchGetItem operation. For more
	// information, see Requ