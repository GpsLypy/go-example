// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package codecommit

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/private/protocol"
	"github.com/aws/aws-sdk-go/private/protocol/jsonrpc"
)

const opBatchDescribeMergeConflicts = "BatchDescribeMergeConflicts"

// BatchDescribeMergeConflictsRequest generates a "aws/request.Request" representing the
// client's request for the BatchDescribeMergeConflicts operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchDescribeMergeConflicts for more information on using the BatchDescribeMergeConflicts
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchDescribeMergeConflictsRequest method.
//    req, resp := client.BatchDescribeMergeConflictsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchDescribeMergeConflicts
func (c *CodeCommit) BatchDescribeMergeConflictsRequest(input *BatchDescribeMergeConflictsInput) (req *request.Request, output *BatchDescribeMergeConflictsOutput) {
	op := &request.Operation{
		Name:       opBatchDescribeMergeConflicts,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchDescribeMergeConflictsInput{}
	}

	output = &BatchDescribeMergeConflictsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchDescribeMergeConflicts API operation for AWS CodeCommit.
//
// Returns information about one or more merge conflicts in the attempted merge
// of two commit specifiers using the squash or three-way merge strategy.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation BatchDescribeMergeConflicts for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeMergeOptionRequiredException "MergeOptionRequiredException"
//   A merge option or stategy is required, and none was provided.
//
//   * ErrCodeInvalidMergeOptionException "InvalidMergeOptionException"
//   The specified merge option is not valid for this operation. Not all merge
//   strategies are supported for all operations.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodeInvalidMaxConflictFilesException "InvalidMaxConflictFilesException"
//   The specified value for the number of conflict files to return is not valid.
//
//   * ErrCodeInvalidMaxMergeHunksException "InvalidMaxMergeHunksException"
//   The specified value for the number of merge hunks to return is not valid.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeMaximumFileContentToLoadExceededException "MaximumFileContentToLoadExceededException"
//   The number of files to load exceeds the allowed limit.
//
//   * ErrCodeMaximumItemsToCompareExceededException "MaximumItemsToCompareExceededException"
//   The maximum number of items to compare between the source or destination
//   branches and the merge base has exceeded the maximum allowed.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchDescribeMergeConflicts
func (c *CodeCommit) BatchDescribeMergeConflicts(input *BatchDescribeMergeConflictsInput) (*BatchDescribeMergeConflictsOutput, error) {
	req, out := c.BatchDescribeMergeConflictsRequest(input)
	return out, req.Send()
}

// BatchDescribeMergeConflictsWithContext is the same as BatchDescribeMergeConflicts with the addition of
// the ability to pass a context and additional request options.
//
// See BatchDescribeMergeConflicts for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) BatchDescribeMergeConflictsWithContext(ctx aws.Context, input *BatchDescribeMergeConflictsInput, opts ...request.Option) (*BatchDescribeMergeConflictsOutput, error) {
	req, out := c.BatchDescribeMergeConflictsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetCommits = "BatchGetCommits"

// BatchGetCommitsRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetCommits operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetCommits for more information on using the BatchGetCommits
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetCommitsRequest method.
//    req, resp := client.BatchGetCommitsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchGetCommits
func (c *CodeCommit) BatchGetCommitsRequest(input *BatchGetCommitsInput) (req *request.Request, output *BatchGetCommitsOutput) {
	op := &request.Operation{
		Name:       opBatchGetCommits,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetCommitsInput{}
	}

	output = &BatchGetCommitsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetCommits API operation for AWS CodeCommit.
//
// Returns information about the contents of one or more commits in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation BatchGetCommits for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeCommitIdsListRequiredException "CommitIdsListRequiredException"
//
//   * ErrCodeCommitIdsLimitExceededException "CommitIdsLimitExceededException"
//   The maximum number of allowed commit IDs in a batch request is 100. Verify
//   that your batch requests contains no more than 100 commit IDs, and then try
//   again.
//
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchGetCommits
func (c *CodeCommit) BatchGetCommits(input *BatchGetCommitsInput) (*BatchGetCommitsOutput, error) {
	req, out := c.BatchGetCommitsRequest(input)
	return out, req.Send()
}

// BatchGetCommitsWithContext is the same as BatchGetCommits with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetCommits for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) BatchGetCommitsWithContext(ctx aws.Context, input *BatchGetCommitsInput, opts ...request.Option) (*BatchGetCommitsOutput, error) {
	req, out := c.BatchGetCommitsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetRepositories = "BatchGetRepositories"

// BatchGetRepositoriesRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetRepositories operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetRepositories for more information on using the BatchGetRepositories
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetRepositoriesRequest method.
//    req, resp := client.BatchGetRepositoriesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchGetRepositories
func (c *CodeCommit) BatchGetRepositoriesRequest(input *BatchGetRepositoriesInput) (req *request.Request, output *BatchGetRepositoriesOutput) {
	op := &request.Operation{
		Name:       opBatchGetRepositories,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetRepositoriesInput{}
	}

	output = &BatchGetRepositoriesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetRepositories API operation for AWS CodeCommit.
//
// Returns information about one or more repositories.
//
// The description field for a repository accepts all HTML characters and all
// valid Unicode characters. Applications that do not HTML-encode the description
// and display it in a web page could expose users to potentially malicious
// code. Make sure that you HTML-encode the description field in any application
// that uses this API to display the repository description on a web page.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation BatchGetRepositories for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNamesRequiredException "RepositoryNamesRequiredException"
//   A repository names object is required but was not specified.
//
//   * ErrCodeMaximumRepositoryNamesExceededException "MaximumRepositoryNamesExceededException"
//   The maximum number of allowed repository names was exceeded. Currently, this
//   number is 25.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchGetRepositories
func (c *CodeCommit) BatchGetRepositories(input *BatchGetRepositoriesInput) (*BatchGetRepositoriesOutput, error) {
	req, out := c.BatchGetRepositoriesRequest(input)
	return out, req.Send()
}

// BatchGetRepositoriesWithContext is the same as BatchGetRepositories with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetRepositories for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) BatchGetRepositoriesWithContext(ctx aws.Context, input *BatchGetRepositoriesInput, opts ...request.Option) (*BatchGetRepositoriesOutput, error) {
	req, out := c.BatchGetRepositoriesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateBranch = "CreateBranch"

// CreateBranchRequest generates a "aws/request.Request" representing the
// client's request for the CreateBranch operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateBranch for more information on using the CreateBranch
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateBranchRequest method.
//    req, resp := client.CreateBranchRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateBranch
func (c *CodeCommit) CreateBranchRequest(input *CreateBranchInput) (req *request.Request, output *CreateBranchOutput) {
	op := &request.Operation{
		Name:       opCreateBranch,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateBranchInput{}
	}

	output = &CreateBranchOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// CreateBranch API operation for AWS CodeCommit.
//
// Creates a new branch in a repository and points the branch to a commit.
//
// Calling the create branch operation does not set a repository's default branch.
// To do this, call the update default branch operation.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreateBranch for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeBranchNameRequiredException "BranchNameRequiredException"
//   A branch name is required but was not specified.
//
//   * ErrCodeBranchNameExistsException "BranchNameExistsException"
//   The specified branch name already exists.
//
//   * ErrCodeInvalidBranchNameException "InvalidBranchNameException"
//   The specified reference name is not valid.
//
//   * ErrCodeCommitIdRequiredException "CommitIdRequiredException"
//   A commit ID was not specified.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidCommitIdException "InvalidCommitIdException"
//   The specified commit ID is not valid.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateBranch
func (c *CodeCommit) CreateBranch(input *CreateBranchInput) (*CreateBranchOutput, error) {
	req, out := c.CreateBranchRequest(input)
	return out, req.Send()
}

// CreateBranchWithContext is the same as CreateBranch with the addition of
// the ability to pass a context and additional request options.
//
// See CreateBranch for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreateBranchWithContext(ctx aws.Context, input *CreateBranchInput, opts ...request.Option) (*CreateBranchOutput, error) {
	req, out := c.CreateBranchRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateCommit = "CreateCommit"

// CreateCommitRequest generates a "aws/request.Request" representing the
// client's request for the CreateCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateCommit for more information on using the CreateCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateCommitRequest method.
//    req, resp := client.CreateCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateCommit
func (c *CodeCommit) CreateCommitRequest(input *CreateCommitInput) (req *request.Request, output *CreateCommitOutput) {
	op := &request.Operation{
		Name:       opCreateCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateCommitInput{}
	}

	output = &CreateCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateCommit API operation for AWS CodeCommit.
//
// Creates a commit for a repository on the tip of a specified branch.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreateCommit for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeParentCommitIdRequiredException "ParentCommitIdRequiredException"
//   A parent commit ID is required. To view the full commit ID of a branch in
//   a repository, use GetBranch or a Git command (for example, git pull or git
//   log).
//
//   * ErrCodeInvalidParentCommitIdException "InvalidParentCommitIdException"
//   The parent commit ID is not valid. The commit ID cannot be empty, and must
//   match the head commit ID for the branch of the repository where you want
//   to add or update a file.
//
//   * ErrCodeParentCommitDoesNotExistException "ParentCommitDoesNotExistException"
//   The parent commit ID is not valid because it does not exist. The specified
//   parent commit ID does not exist in the specified branch of the repository.
//
//   * ErrCodeParentCommitIdOutdatedException "ParentCommitIdOutdatedException"
//   The file could not be added because the provided parent commit ID is not
//   the current tip of the specified branch. To view the full commit ID of the
//   current head of the branch, use GetBranch.
//
//   * ErrCodeBranchNameRequiredException "BranchNameRequiredException"
//   A branch name is required but was not specified.
//
//   * ErrCodeInvalidBranchNameException "InvalidBranchNameException"
//   The specified reference name is not valid.
//
//   * ErrCodeBranchDoesNotExistException "BranchDoesNotExistException"
//   The specified branch does not exist.
//
//   * ErrCodeBranchNameIsTagNameException "BranchNameIsTagNameException"
//   The specified branch name is not valid because it is a tag name. Type the
//   name of a current branch in the repository. For a list of valid branch names,
//   use ListBranches.
//
//   * ErrCodeFileEntryRequiredException "FileEntryRequiredException"
//   The commit cannot be created because no files have been specified as added,
//   updated, or changed (PutFile or DeleteFile) for the commit.
//
//   * ErrCodeMaximumFileEntriesExceededException "MaximumFileEntriesExceededException"
//   The number of specified files to change as part of this commit exceeds the
//   maximum number of files that can be changed in a single commit. Consider
//   using a Git client for these changes.
//
//   * ErrCodePutFileEntryConflictException "PutFileEntryConflictException"
//   The commit cannot be created because one or more files specified in the commit
//   reference both a file and a folder.
//
//   * ErrCodeSourceFileOrContentRequiredException "SourceFileOrContentRequiredException"
//   The commit cannot be created because no source files or file content have
//   been specified for the commit.
//
//   * ErrCodeFileContentAndSourceFileSpecifiedException "FileContentAndSourceFileSpecifiedException"
//   The commit cannot be created because both a source file and file content
//   have been specified for the same file. You cannot provide both. Either specify
//   a source file, or provide the file content directly.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeSamePathRequestException "SamePathRequestException"
//   The commit cannot be created because one or more changes in this commit duplicate
//   actions in the same file path. For example, you cannot make the same delete
//   request to the same file in the same file path twice, or make a delete request
//   and a move request to the same file as part of the same commit.
//
//   * ErrCodeFileDoesNotExistException "FileDoesNotExistException"
//   The specified file does not exist. Verify that you have provided the correct
//   name of the file, including its full path and extension.
//
//   * ErrCodeFileContentSizeLimitExceededException "FileContentSizeLimitExceededException"
//   The file cannot be added because it is too large. The maximum file size that
//   can be added is 6 MB, and the combined file content change size is 7 MB.
//   Consider making these changes using a Git client.
//
//   * ErrCodeFolderContentSizeLimitExceededException "FolderContentSizeLimitExceededException"
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * ErrCodeInvalidDeletionParameterException "InvalidDeletionParameterException"
//   The specified deletion parameter is not valid.
//
//   * ErrCodeRestrictedSourceFileException "RestrictedSourceFileException"
//   The commit cannot be created because one of the changes specifies copying
//   or moving a .gitkeep file.
//
//   * ErrCodeFileModeRequiredException "FileModeRequiredException"
//   The commit cannot be created because a file mode is required to update mode
//   permissions for an existing file, but no file mode has been specified.
//
//   * ErrCodeInvalidFileModeException "InvalidFileModeException"
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * ErrCodeNameLengthExceededException "NameLengthExceededException"
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * ErrCodeInvalidEmailException "InvalidEmailException"
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * ErrCodeCommitMessageLengthExceededException "CommitMessageLengthExceededException"
//   The commit message is too long. Provide a shorter string.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
//   * ErrCodeNoChangeException "NoChangeException"
//   The commit cannot be created because no changes will be made to the repository
//   as a result of this commit. A commit must contain at least one change.
//
//   * ErrCodeFileNameConflictsWithDirectoryNameException "FileNameConflictsWithDirectoryNameException"
//   A file cannot be added to the repository because the specified file name
//   has the same name as a directory in this repository. Either provide another
//   name for the file, or add the file in a directory that does not match the
//   file name.
//
//   * ErrCodeDirectoryNameConflictsWithFileNameException "DirectoryNameConflictsWithFileNameException"
//   A file cannot be added to the repository because the specified path name
//   has the same name as a file that already exists in this repository. Either
//   provide a different name for the file, or specify a different path for the
//   file.
//
//   * ErrCodeFilePathConflictsWithSubmodulePathException "FilePathConflictsWithSubmodulePathException"
//   The commit cannot be created because a specified file path points to a submodule.
//   Verify that the destination files have valid file paths that do not point
//   to a submodule.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateCommit
func (c *CodeCommit) CreateCommit(input *CreateCommitInput) (*CreateCommitOutput, error) {
	req, out := c.CreateCommitRequest(input)
	return out, req.Send()
}

// CreateCommitWithContext is the same as CreateCommit with the addition of
// the ability to pass a context and additional request options.
//
// See CreateCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreateCommitWithContext(ctx aws.Context, input *CreateCommitInput, opts ...request.Option) (*CreateCommitOutput, error) {
	req, out := c.CreateCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreatePullRequest = "CreatePullRequest"

// CreatePullRequestRequest generates a "aws/request.Request" representing the
// client's request for the CreatePullRequest operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreatePullRequest for more information on using the CreatePullRequest
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreatePullRequestRequest method.
//    req, resp := client.CreatePullRequestRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreatePullRequest
func (c *CodeCommit) CreatePullRequestRequest(input *CreatePullRequestInput) (req *request.Request, output *CreatePullRequestOutput) {
	op := &request.Operation{
		Name:       opCreatePullRequest,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreatePullRequestInput{}
	}

	output = &CreatePullRequestOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreatePullRequest API operation for AWS CodeCommit.
//
// Creates a pull request in the specified repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreatePullRequest for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
//   * ErrCodeClientRequestTokenRequiredException "ClientRequestTokenRequiredException"
//   A client request token is required. A client request token is an unique,
//   client-generated idempotency token that when provided in a request, ensures
//   the request cannot be repeated with a changed parameter. If a request is
//   received with the same parameters and a token is included, the request will
//   return information about the initial request that used that token.
//
//   * ErrCodeInvalidClientRequestTokenException "InvalidClientRequestTokenException"
//   The client request token is not valid.
//
//   * ErrCodeIdempotencyParameterMismatchException "IdempotencyParameterMismatchException"
//   The client request token is not valid. Either the token is not in a valid
//   format, or the token has been used in a previous request and cannot be re-used.
//
//   * ErrCodeReferenceNameRequiredException "ReferenceNameRequiredException"
//   A reference name is required, but none was provided.
//
//   * ErrCodeInvalidReferenceNameException "InvalidReferenceNameException"
//   The specified reference name format is not valid. Reference names must conform
//   to the Git references format, for example refs/heads/master. For more information,
//   see Git Internals - Git References (https://git-scm.com/book/en/v2/Git-Internals-Git-References)
//   or consult your Git documentation.
//
//   * ErrCodeReferenceDoesNotExistException "ReferenceDoesNotExistException"
//   The specified reference does not exist. You must provide a full commit ID.
//
//   * ErrCodeReferenceTypeNotSupportedException "ReferenceTypeNotSupportedException"
//   The specified reference is not a supported type.
//
//   * ErrCodeTitleRequiredException "TitleRequiredException"
//   A pull request title is required. It cannot be empty or null.
//
//   * ErrCodeInvalidTitleException "InvalidTitleException"
//   The title of the pull request is not valid. Pull request titles cannot exceed
//   100 characters in length.
//
//   * ErrCodeInvalidDescriptionException "InvalidDescriptionException"
//   The pull request description is not valid. Descriptions are limited to 1,000
//   characters in length.
//
//   * ErrCodeTargetsRequiredException "TargetsRequiredException"
//   An array of target objects is required. It cannot be empty or null.
//
//   * ErrCodeInvalidTargetsException "InvalidTargetsException"
//   The targets for the pull request is not valid or not in a valid format. Targets
//   are a list of target objects. Each target object must contain the full values
//   for the repository name, source branch, and destination branch for a pull
//   request.
//
//   * ErrCodeTargetRequiredException "TargetRequiredException"
//   A pull request target is required. It cannot be empty or null. A pull request
//   target must contain the full values for the repository name, source branch,
//   and destination branch for the pull request.
//
//   * ErrCodeInvalidTargetException "InvalidTargetException"
//   The target for the pull request is not valid. A target must contain the full
//   values for the repository name, source branch, and destination branch for
//   the pull request.
//
//   * ErrCodeMultipleRepositoriesInPullRequestException "MultipleRepositoriesInPullRequestException"
//   You cannot include more than one repository in a pull request. Make sure
//   you have specified only one repository name in your request, and then try
//   again.
//
//   * ErrCodeMaximumOpenPullRequestsExceededException "MaximumOpenPullRequestsExceededException"
//   You cannot create the pull request because the repository has too many open
//   pull requests. The maximum number of open pull requests for a repository
//   is 1,000. Close one or more open pull requests, and then try again.
//
//   * ErrCodeSourceAndDestinationAreSameException "SourceAndDestinationAreSameException"
//   The source branch and the destination branch for the pull request are the
//   same. You must specify different branches for the source and destination.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreatePullRequest
func (c *CodeCommit) CreatePullRequest(input *CreatePullRequestInput) (*CreatePullRequestOutput, error) {
	req, out := c.CreatePullRequestRequest(input)
	return out, req.Send()
}

// CreatePullRequestWithContext is the same as CreatePullRequest with the addition of
// the ability to pass a context and additional request options.
//
// See CreatePullRequest for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreatePullRequestWithContext(ctx aws.Context, input *CreatePullRequestInput, opts ...request.Option) (*CreatePullRequestOutput, error) {
	req, out := c.CreatePullRequestRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateRepository = "CreateRepository"

// CreateRepositoryRequest generates a "aws/request.Request" representing the
// client's request for the CreateRepository operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateRepository for more information on using the CreateRepository
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateRepositoryRequest method.
//    req, resp := client.CreateRepositoryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateRepository
func (c *CodeCommit) CreateRepositoryRequest(input *CreateRepositoryInput) (req *request.Request, output *CreateRepositoryOutput) {
	op := &request.Operation{
		Name:       opCreateRepository,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateRepositoryInput{}
	}

	output = &CreateRepositoryOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateRepository API operation for AWS CodeCommit.
//
// Creates a new, empty repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreateRepository for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameExistsException "RepositoryNameExistsException"
//   The specified repository name already exists.
//
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeInvalidRepositoryDescriptionException "InvalidRepositoryDescriptionException"
//   The specified repository description is not valid.
//
//   * ErrCodeRepositoryLimitExceededException "RepositoryLimitExceededException"
//   A repository resource limit was exceeded.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
//   * ErrCodeInvalidTagsMapException "InvalidTagsMapException"
//   The map of tags is not valid.
//
//   * ErrCodeTooManyTagsException "TooManyTagsException"
//   The maximum number of tags for an AWS CodeCommit resource has been exceeded.
//
//   * ErrCodeInvalidSystemTagUsageException "InvalidSystemTagUsageException"
//   The specified tag is not valid. Key names cannot be prefixed with aws:.
//
//   * ErrCodeTagPolicyException "TagPolicyException"
//   The tag policy is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateRepository
func (c *CodeCommit) CreateRepository(input *CreateRepositoryInput) (*CreateRepositoryOutput, error) {
	req, out := c.CreateRepositoryRequest(input)
	return out, req.Send()
}

// CreateRepositoryWithContext is the same as CreateRepository with the addition of
// the ability to pass a context and additional request options.
//
// See CreateRepository for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreateRepositoryWithContext(ctx aws.Context, input *CreateRepositoryInput, opts ...request.Option) (*CreateRepositoryOutput, error) {
	req, out := c.CreateRepositoryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateUnreferencedMergeCommit = "CreateUnreferencedMergeCommit"

// CreateUnreferencedMergeCommitRequest generates a "aws/request.Request" representing the
// client's request for the CreateUnreferencedMergeCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateUnreferencedMergeCommit for more information on using the CreateUnreferencedMergeCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateUnreferencedMergeCommitRequest method.
//    req, resp := client.CreateUnreferencedMergeCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateUnreferencedMergeCommit
func (c *CodeCommit) CreateUnreferencedMergeCommitRequest(input *CreateUnreferencedMergeCommitInput) (req *request.Request, output *CreateUnreferencedMergeCommitOutput) {
	op := &request.Operation{
		Name:       opCreateUnreferencedMergeCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateUnreferencedMergeCommitInput{}
	}

	output = &CreateUnreferencedMergeCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateUnreferencedMergeCommit API operation for AWS CodeCommit.
//
// Creates an unreferenced commit that represents the result of merging two
// branches using a specified merge strategy. This can help you determine the
// outcome of a potential merge. This API cannot be used with the fast-forward
// merge strategy, as that strategy does not create a merge commit.
//
// This unreferenced merge commit can only be accessed using the GetCommit API
// or through git commands such as git fetch. To retrieve this commit, you must
// specify its commit ID or otherwise reference it.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreateUnreferencedMergeCommit for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeMergeOptionRequiredException "MergeOptionRequiredException"
//   A merge option or stategy is required, and none was provided.
//
//   * ErrCodeInvalidMergeOptionException "InvalidMergeOptionException"
//   The specified merge option is not valid for this operation. Not all merge
//   strategies are supported for all operations.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeInvalidConflictResolutionException "InvalidConflictResolutionException"
//   The specified conflict resolution list is not valid.
//
//   * ErrCodeManualMergeRequiredException "ManualMergeRequiredException"
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * ErrCodeMaximumConflictResolutionEntriesExceededException "MaximumConflictResolutionEntriesExceededException"
//   The number of allowed conflict resolution entries was exceeded.
//
//   * ErrCodeMultipleConflictResolutionEntriesException "MultipleConflictResolutionEntriesException"
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ErrCodeReplacementTypeRequiredException "ReplacementTypeRequiredException"
//   A replacement type is required.
//
//   * ErrCodeInvalidReplacementTypeException "InvalidReplacementTypeException"
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * ErrCodeReplacementContentRequiredException "ReplacementContentRequiredException"
//   USE_NEW_CONTENT was specified but no replacement content has been provided.
//
//   * ErrCodeInvalidReplacementContentException "InvalidReplacementContentException"
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeFileContentSizeLimitExceededException "FileContentSizeLimitExceededException"
//   The file cannot be added because it is too large. The maximum file size that
//   can be added is 6 MB, and the combined file content change size is 7 MB.
//   Consider making these changes using a Git client.
//
//   * ErrCodeFolderContentSizeLimitExceededException "FolderContentSizeLimitExceededException"
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * ErrCodeMaximumFileContentToLoadExceededException "MaximumFileContentToLoadExceededException"
//   The number of files to load exceeds the allowed limit.
//
//   * ErrCodeMaximumItemsToCompareExceededException "MaximumItemsToCompareExceededException"
//   The maximum number of items to compare between the source or destination
//   branches and the merge base has exceeded the maximum allowed.
//
//   * ErrCodeConcurrentReferenceUpdateException "ConcurrentReferenceUpdateException"
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * ErrCodeFileModeRequiredException "FileModeRequiredException"
//   The commit cannot be created because a file mode is required to update mode
//   permissions for an existing file, but no file mode has been specified.
//
//   * ErrCodeInvalidFileModeException "InvalidFileModeException"
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * ErrCodeNameLengthExceededException "NameLengthExceededException"
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * ErrCodeInvalidEmailException "InvalidEmailException"
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * ErrCodeCommitMessageLengthExceededException "CommitMessageLengthExceededException"
//   The commit message is too long. Provide a shorter string.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateUnreferencedMergeCommit
func (c *CodeCommit) CreateUnreferencedMergeCommit(input *CreateUnreferencedMergeCommitInput) (*CreateUnreferencedMergeCommitOutput, error) {
	req, out := c.CreateUnreferencedMergeCommitRequest(input)
	return out, req.Send()
}

// CreateUnreferencedMergeCommitWithContext is the same as CreateUnreferencedMergeCommit with the addition of
// the ability to pass a context and additional request options.
//
// See CreateUnreferencedMergeCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreateUnreferencedMergeCommitWithContext(ctx aws.Context, input *CreateUnreferencedMergeCommitInput, opts ...request.Option) (*CreateUnreferencedMergeCommitOutput, error) {
	req, out := c.CreateUnreferencedMergeCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteBranch = "DeleteBranch"

// DeleteBranchRequest generates a "aws/request.Request" representing the
// client's request for the DeleteBranch operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteBranch for more information on using the DeleteBranch
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteBranchRequest method.
//    req, resp := client.DeleteBranchRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteBranch
func (c *CodeCommit) DeleteBranchRequest(input *DeleteBranchInput) (req *request.Request, output *DeleteBranchOutput) {
	op := &request.Operation{
		Name:       opDeleteBranch,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteBranchInput{}
	}

	output = &DeleteBranchOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteBranch API operation for AWS CodeCommit.
//
// Deletes a branch from a repository, unless that branch is the default branch
// for the repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeleteBranch for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeBranchNameRequiredException "BranchNameRequiredException"
//   A branch name is required but was not specified.
//
//   * ErrCodeInvalidBranchNameException "InvalidBranchNameException"
//   The specified reference name is not valid.
//
//   * ErrCodeDefaultBranchCannotBeDeletedException "DefaultBranchCannotBeDeletedException"
//   The specified branch is the default branch for the repository, and cannot
//   be deleted. To delete this branch, you must first set another branch as the
//   default branch.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteBranch
func (c *CodeCommit) DeleteBranch(input *DeleteBranchInput) (*DeleteBranchOutput, error) {
	req, out := c.DeleteBranchRequest(input)
	return out, req.Send()
}

// DeleteBranchWithContext is the same as DeleteBranch with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteBranch for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeleteBranchWithContext(ctx aws.Context, input *DeleteBranchInput, opts ...request.Option) (*DeleteBranchOutput, error) {
	req, out := c.DeleteBranchRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteCommentContent = "DeleteCommentContent"

// DeleteCommentContentRequest generates a "aws/request.Request" representing the
// client's request for the DeleteCommentContent operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteCommentContent for more information on using the DeleteCommentContent
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteCommentContentRequest method.
//    req, resp := client.DeleteCommentContentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteCommentContent
func (c *CodeCommit) DeleteCommentContentRequest(input *DeleteCommentContentInput) (req *request.Request, output *DeleteCommentContentOutput) {
	op := &request.Operation{
		Name:       opDeleteCommentContent,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteCommentContentInput{}
	}

	output = &DeleteCommentContentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteCommentContent API operation for AWS CodeCommit.
//
// Deletes the content of a comment made on a change, file, or commit in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeleteCommentContent for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeCommentDoesNotExistException "CommentDoesNotExistException"
//   No comment exists with the provided ID. Verify that you have provided the
//   correct ID, and then try again.
//
//   * ErrCodeCommentIdRequiredException "CommentIdRequiredException"
//   The comment ID is missing or null. A comment ID is required.
//
//   * ErrCodeInvalidCommentIdException "InvalidCommentIdException"
//   The comment ID is not in a valid format. Make sure that you have provided
//   the full comment ID.
//
//   * ErrCodeCommentDeletedException "CommentDeletedException"
//   This comment has already been deleted. You cannot edit or delete a deleted
//   comment.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteCommentContent
func (c *CodeCommit) DeleteCommentContent(input *DeleteCommentContentInput) (*DeleteCommentContentOutput, error) {
	req, out := c.DeleteCommentContentRequest(input)
	return out, req.Send()
}

// DeleteCommentContentWithContext is the same as DeleteCommentContent with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteCommentContent for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeleteCommentContentWithContext(ctx aws.Context, input *DeleteCommentContentInput, opts ...request.Option) (*DeleteCommentContentOutput, error) {
	req, out := c.DeleteCommentContentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteFile = "DeleteFile"

// DeleteFileRequest generates a "aws/request.Request" representing the
// client's request for the DeleteFile operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteFile for more information on using the DeleteFile
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteFileRequest method.
//    req, resp := client.DeleteFileRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteFile
func (c *CodeCommit) DeleteFileRequest(input *DeleteFileInput) (req *request.Request, output *DeleteFileOutput) {
	op := &request.Operation{
		Name:       opDeleteFile,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteFileInput{}
	}

	output = &DeleteFileOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteFile API operation for AWS CodeCommit.
//
// Deletes a specified file from a specified branch. A commit is created on
// the branch that contains the revision. The file will still exist in the commits
// prior to the commit that contains the deletion.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeleteFile for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeParentCommitIdRequiredException "ParentCommitIdRequiredException"
//   A parent commit ID is required. To view the full commit ID of a branch in
//   a repository, use GetBranch or a Git command (for example, git pull or git
//   log).
//
//   * ErrCodeInvalidParentCommitIdException "InvalidParentCommitIdException"
//   The parent commit ID is not valid. The commit ID cannot be empty, and must
//   match the head commit ID for the branch of the repository where you want
//   to add or update a file.
//
//   * ErrCodeParentCommitDoesNotExistException "ParentCommitDoesNotExistException"
//   The parent commit ID is not valid because it does not exist. The specified
//   parent commit ID does not exist in the specified branch of the repository.
//
//   * ErrCodeParentCommitIdOutdatedException "ParentCommitIdOutdatedException"
//   The file could not be added because the provided parent commit ID is not
//   the current tip of the specified branch. To view the full commit ID of the
//   current head of the branch, use GetBranch.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeFileDoesNotExistException "FileDoesNotExistException"
//   The specified file does not exist. Verify that you have provided the correct
//   name of the file, including its full path and extension.
//
//   * ErrCodeBranchNameRequiredException "BranchNameRequiredException"
//   A branch name is required but was not specified.
//
//   * ErrCodeInvalidBranchNameException "InvalidBranchNameException"
//   The specified reference name is not valid.
//
//   * ErrCodeBranchDoesNotExistException "BranchDoesNotExistException"
//   The specified branch does not exist.
//
//   * ErrCodeBranchNameIsTagNameException "BranchNameIsTagNameException"
//   The specified branch name is not valid because it is a tag name. Type the
//   name of a current branch in the repository. For a list of valid branch names,
//   use ListBranches.
//
//   * ErrCodeNameLengthExceededException "NameLengthExceededException"
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * ErrCodeInvalidEmailException "InvalidEmailException"
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * ErrCodeCommitMessageLengthExceededException "CommitMessageLengthExceededException"
//   The commit message is too long. Provide a shorter string.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteFile
func (c *CodeCommit) DeleteFile(input *DeleteFileInput) (*DeleteFileOutput, error) {
	req, out := c.DeleteFileRequest(input)
	return out, req.Send()
}

// DeleteFileWithContext is the same as DeleteFile with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteFile for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeleteFileWithContext(ctx aws.Context, input *DeleteFileInput, opts ...request.Option) (*DeleteFileOutput, error) {
	req, out := c.DeleteFileRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteRepository = "DeleteRepository"

// DeleteRepositoryRequest generates a "aws/request.Request" representing the
// client's request for the DeleteRepository operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteRepository for more information on using the DeleteRepository
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteRepositoryRequest method.
//    req, resp := client.DeleteRepositoryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteRepository
func (c *CodeCommit) DeleteRepositoryRequest(input *DeleteRepositoryInput) (req *request.Request, output *DeleteRepositoryOutput) {
	op := &request.Operation{
		Name:       opDeleteRepository,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteRepositoryInput{}
	}

	output = &DeleteRepositoryOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteRepository API operation for AWS CodeCommit.
//
// Deletes a repository. If a specified repository was already deleted, a null
// repository ID will be returned.
//
// Deleting a repository also deletes all associated objects and metadata. After
// a repository is deleted, all future push calls to the deleted repository
// will fail.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeleteRepository for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteRepository
func (c *CodeCommit) DeleteRepository(input *DeleteRepositoryInput) (*DeleteRepositoryOutput, error) {
	req, out := c.DeleteRepositoryRequest(input)
	return out, req.Send()
}

// DeleteRepositoryWithContext is the same as DeleteRepository with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteRepository for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeleteRepositoryWithContext(ctx aws.Context, input *DeleteRepositoryInput, opts ...request.Option) (*DeleteRepositoryOutput, error) {
	req, out := c.DeleteRepositoryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeMergeConflicts = "DescribeMergeConflicts"

// DescribeMergeConflictsRequest generates a "aws/request.Request" representing the
// client's request for the DescribeMergeConflicts operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeMergeConflicts for more information on using the DescribeMergeConflicts
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeMergeConflictsRequest method.
//    req, resp := client.DescribeMergeConflictsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DescribeMergeConflicts
func (c *CodeCommit) DescribeMergeConflictsRequest(input *DescribeMergeConflictsInput) (req *request.Request, output *DescribeMergeConflictsOutput) {
	op := &request.Operation{
		Name:       opDescribeMergeConflicts,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxMergeHunks",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeMergeConflictsInput{}
	}

	output = &DescribeMergeConflictsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DescribeMergeConflicts API operation for AWS CodeCommit.
//
// Returns information about one or more merge conflicts in the attempted merge
// of two commit specifiers using the squash or three-way merge strategy. If
// the merge option for the attempted merge is specified as FAST_FORWARD_MERGE,
// an exception will be thrown.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DescribeMergeConflicts for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeMergeOptionRequiredException "MergeOptionRequiredException"
//   A merge option or stategy is required, and none was provided.
//
//   * ErrCodeInvalidMergeOptionException "InvalidMergeOptionException"
//   The specified merge option is not valid for this operation. Not all merge
//   strategies are supported for all operations.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeFileDoesNotExistException "FileDoesNotExistException"
//   The specified file does not exist. Verify that you have provided the correct
//   name of the file, including its full path and extension.
//
//   * ErrCodeInvalidMaxMergeHunksException "InvalidMaxMergeHunksException"
//   The specified value for the number of merge hunks to return is not valid.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeMaximumFileContentToLoadExceededException "MaximumFileContentToLoadExceededException"
//   The number of files to load exceeds the allowed limit.
//
//   * ErrCodeMaximumItemsToCompareExceededException "MaximumItemsToCompareExceededException"
//   The maximum number of items to compare between the source or destination
//   branches and the merge base has exceeded the maximum allowed.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DescribeMergeConflicts
func (c *CodeCommit) DescribeMergeConflicts(input *DescribeMergeConflictsInput) (*DescribeMergeConflictsOutput, error) {
	req, out := c.DescribeMergeConflictsRequest(input)
	return out, req.Send()
}

// DescribeMergeConflictsWithContext is the same as DescribeMergeConflicts with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeMergeConflicts for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DescribeMergeConflictsWithContext(ctx aws.Context, input *DescribeMergeConflictsInput, opts ...request.Option) (*DescribeMergeConflictsOutput, error) {
	req, out := c.DescribeMergeConflictsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// DescribeMergeConflictsPages iterates over the pages of a DescribeMergeConflicts operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See DescribeMergeConflicts method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeMergeConflicts operation.
//    pageNum := 0
//    err := client.DescribeMergeConflictsPages(params,
//        func(page *codecommit.DescribeMergeConflictsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) DescribeMergeConflictsPages(input *DescribeMergeConflictsInput, fn func(*DescribeMergeConflictsOutput, bool) bool) error {
	return c.DescribeMergeConflictsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// DescribeMergeConflictsPagesWithContext same as DescribeMergeConflictsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DescribeMergeConflictsPagesWithContext(ctx aws.Context, input *DescribeMergeConflictsInput, fn func(*DescribeMergeConflictsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *DescribeMergeConflictsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.DescribeMergeConflictsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*DescribeMergeConflictsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opDescribePullRequestEvents = "DescribePullRequestEvents"

// DescribePullRequestEventsRequest generates a "aws/request.Request" representing the
// client's request for the DescribePullRequestEvents operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribePullRequestEvents for more information on using the DescribePullRequestEvents
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribePullRequestEventsRequest method.
//    req, resp := client.DescribePullRequestEventsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DescribePullRequestEvents
func (c *CodeCommit) DescribePullRequestEventsRequest(input *DescribePullRequestEventsInput) (req *request.Request, output *DescribePullRequestEventsOutput) {
	op := &request.Operation{
		Name:       opDescribePullRequestEvents,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribePullRequestEventsInput{}
	}

	output = &DescribePullRequestEventsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DescribePullRequestEvents API operation for AWS CodeCommit.
//
// Returns information about one or more pull request events.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DescribePullRequestEvents for usage and error information.
//
// Returned Error Codes:
//   * ErrCodePullRequestDoesNotExistException "PullRequestDoesNotExistException"
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * ErrCodeInvalidPullRequestIdException "InvalidPullRequestIdException"
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * ErrCodePullRequestIdRequiredException "PullRequestIdRequiredException"
//   A pull request ID is required, but none was provided.
//
//   * ErrCodeInvalidPullRequestEventTypeException "InvalidPullRequestEventTypeException"
//   The pull request event type is not valid.
//
//   * ErrCodeInvalidActorArnException "InvalidActorArnException"
//   The Amazon Resource Name (ARN) is not valid. Make sure that you have provided
//   the full ARN for the user who initiated the change for the pull request,
//   and then try again.
//
//   * ErrCodeActorDoesNotExistException "ActorDoesNotExistException"
//   The specified Amazon Resource Name (ARN) does not exist in the AWS account.
//
//   * ErrCodeInvalidMaxResultsException "InvalidMaxResultsException"
//   The specified number of maximum results is not valid.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DescribePullRequestEvents
func (c *CodeCommit) DescribePullRequestEvents(input *DescribePullRequestEventsInput) (*DescribePullRequestEventsOutput, error) {
	req, out := c.DescribePullRequestEventsRequest(input)
	return out, req.Send()
}

// DescribePullRequestEventsWithContext is the same as DescribePullRequestEvents with the addition of
// the ability to pass a context and additional request options.
//
// See DescribePullRequestEvents for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DescribePullRequestEventsWithContext(ctx aws.Context, input *DescribePullRequestEventsInput, opts ...request.Option) (*DescribePullRequestEventsOutput, error) {
	req, out := c.DescribePullRequestEventsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// DescribePullRequestEventsPages iterates over the pages of a DescribePullRequestEvents operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See DescribePullRequestEvents method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribePullRequestEvents operation.
//    pageNum := 0
//    err := client.DescribePullRequestEventsPages(params,
//        func(page *codecommit.DescribePullRequestEventsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) DescribePullRequestEventsPages(input *DescribePullRequestEventsInput, fn func(*DescribePullRequestEventsOutput, bool) bool) error {
	return c.DescribePullRequestEventsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// DescribePullRequestEventsPagesWithContext same as DescribePullRequestEventsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DescribePullRequestEventsPagesWithContext(ctx aws.Context, input *DescribePullRequestEventsInput, fn func(*DescribePullRequestEventsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *DescribePullRequestEventsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.DescribePullRequestEventsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*DescribePullRequestEventsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opGetBlob = "GetBlob"

// GetBlobRequest generates a "aws/request.Request" representing the
// client's request for the GetBlob operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetBlob for more information on using the GetBlob
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetBlobRequest method.
//    req, resp := client.GetBlobRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetBlob
func (c *CodeCommit) GetBlobRequest(input *GetBlobInput) (req *request.Request, output *GetBlobOutput) {
	op := &request.Operation{
		Name:       opGetBlob,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetBlobInput{}
	}

	output = &GetBlobOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetBlob API operation for AWS CodeCommit.
//
// Returns the base-64 encoded content of an individual blob within a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetBlob for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeBlobIdRequiredException "BlobIdRequiredException"
//   A blob ID is required but was not specified.
//
//   * ErrCodeInvalidBlobIdException "InvalidBlobIdException"
//   The specified blob is not valid.
//
//   * ErrCodeBlobIdDoesNotExistException "BlobIdDoesNotExistException"
//   The specified blob does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
//   * ErrCodeFileTooLargeException "FileTooLargeException"
//   The specified file exceeds the file size limit for AWS CodeCommit. For more
//   information about limits in AWS CodeCommit, see AWS CodeCommit User Guide
//   (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetBlob
func (c *CodeCommit) GetBlob(input *GetBlobInput) (*GetBlobOutput, error) {
	req, out := c.GetBlobRequest(input)
	return out, req.Send()
}

// GetBlobWithContext is the same as GetBlob with the addition of
// the ability to pass a context and additional request options.
//
// See GetBlob for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetBlobWithContext(ctx aws.Context, input *GetBlobInput, opts ...request.Option) (*GetBlobOutput, error) {
	req, out := c.GetBlobRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetBranch = "GetBranch"

// GetBranchRequest generates a "aws/request.Request" representing the
// client's request for the GetBranch operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetBranch for more information on using the GetBranch
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetBranchRequest method.
//    req, resp := client.GetBranchRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetBranch
func (c *CodeCommit) GetBranchRequest(input *GetBranchInput) (req *request.Request, output *GetBranchOutput) {
	op := &request.Operation{
		Name:       opGetBranch,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetBranchInput{}
	}

	output = &GetBranchOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetBranch API operation for AWS CodeCommit.
//
// Returns information about a repository branch, including its name and the
// last commit ID.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetBranch for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeBranchNameRequiredException "BranchNameRequiredException"
//   A branch name is required but was not specified.
//
//   * ErrCodeInvalidBranchNameException "InvalidBranchNameException"
//   The specified reference name is not valid.
//
//   * ErrCodeBranchDoesNotExistException "BranchDoesNotExistException"
//   The specified branch does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetBranch
func (c *CodeCommit) GetBranch(input *GetBranchInput) (*GetBranchOutput, error) {
	req, out := c.GetBranchRequest(input)
	return out, req.Send()
}

// GetBranchWithContext is the same as GetBranch with the addition of
// the ability to pass a context and additional request options.
//
// See GetBranch for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetBranchWithContext(ctx aws.Context, input *GetBranchInput, opts ...request.Option) (*GetBranchOutput, error) {
	req, out := c.GetBranchRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetComment = "GetComment"

// GetCommentRequest generates a "aws/request.Request" representing the
// client's request for the GetComment operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetComment for more information on using the GetComment
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCommentRequest method.
//    req, resp := client.GetCommentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetComment
func (c *CodeCommit) GetCommentRequest(input *GetCommentInput) (req *request.Request, output *GetCommentOutput) {
	op := &request.Operation{
		Name:       opGetComment,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetCommentInput{}
	}

	output = &GetCommentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetComment API operation for AWS CodeCommit.
//
// Returns the content of a comment made on a change, file, or commit in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetComment for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeCommentDoesNotExistException "CommentDoesNotExistException"
//   No comment exists with the provided ID. Verify that you have provided the
//   correct ID, and then try again.
//
//   * ErrCodeCommentIdRequiredException "CommentIdRequiredException"
//   The comment ID is missing or null. A comment ID is required.
//
//   * ErrCodeInvalidCommentIdException "InvalidCommentIdException"
//   The comment ID is not in a valid format. Make sure that you have provided
//   the full comment ID.
//
//   * ErrCodeCommentDeletedException "CommentDeletedException"
//   This comment has already been deleted. You cannot edit or delete a deleted
//   comment.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetComment
func (c *CodeCommit) GetComment(input *GetCommentInput) (*GetCommentOutput, error) {
	req, out := c.GetCommentRequest(input)
	return out, req.Send()
}

// GetCommentWithContext is the same as GetComment with the addition of
// the ability to pass a context and additional request options.
//
// See GetComment for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentWithContext(ctx aws.Context, input *GetCommentInput, opts ...request.Option) (*GetCommentOutput, error) {
	req, out := c.GetCommentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetCommentsForComparedCommit = "GetCommentsForComparedCommit"

// GetCommentsForComparedCommitRequest generates a "aws/request.Request" representing the
// client's request for the GetCommentsForComparedCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetCommentsForComparedCommit for more information on using the GetCommentsForComparedCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCommentsForComparedCommitRequest method.
//    req, resp := client.GetCommentsForComparedCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentsForComparedCommit
func (c *CodeCommit) GetCommentsForComparedCommitRequest(input *GetCommentsForComparedCommitInput) (req *request.Request, output *GetCommentsForComparedCommitOutput) {
	op := &request.Operation{
		Name:       opGetCommentsForComparedCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetCommentsForComparedCommitInput{}
	}

	output = &GetCommentsForComparedCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetCommentsForComparedCommit API operation for AWS CodeCommit.
//
// Returns information about comments made on the comparison between two commits.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetCommentsForComparedCommit for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeCommitIdRequiredException "CommitIdRequiredException"
//   A commit ID was not specified.
//
//   * ErrCodeInvalidCommitIdException "InvalidCommitIdException"
//   The specified commit ID is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidMaxResultsException "InvalidMaxResultsException"
//   The specified number of maximum results is not valid.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentsForComparedCommit
func (c *CodeCommit) GetCommentsForComparedCommit(input *GetCommentsForComparedCommitInput) (*GetCommentsForComparedCommitOutput, error) {
	req, out := c.GetCommentsForComparedCommitRequest(input)
	return out, req.Send()
}

// GetCommentsForComparedCommitWithContext is the same as GetCommentsForComparedCommit with the addition of
// the ability to pass a context and additional request options.
//
// See GetCommentsForComparedCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentsForComparedCommitWithContext(ctx aws.Context, input *GetCommentsForComparedCommitInput, opts ...request.Option) (*GetCommentsForComparedCommitOutput, error) {
	req, out := c.GetCommentsForComparedCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// GetCommentsForComparedCommitPages iterates over the pages of a GetCommentsForComparedCommit operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See GetCommentsForComparedCommit method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetCommentsForComparedCommit operation.
//    pageNum := 0
//    err := client.GetCommentsForComparedCommitPages(params,
//        func(page *codecommit.GetCommentsForComparedCommitOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) GetCommentsForComparedCommitPages(input *GetCommentsForComparedCommitInput, fn func(*GetCommentsForComparedCommitOutput, bool) bool) error {
	return c.GetCommentsForComparedCommitPagesWithContext(aws.BackgroundContext(), input, fn)
}

// GetCommentsForComparedCommitPagesWithContext same as GetCommentsForComparedCommitPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentsForComparedCommitPagesWithContext(ctx aws.Context, input *GetCommentsForComparedCommitInput, fn func(*GetCommentsForComparedCommitOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *GetCommentsForComparedCommitInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.GetCommentsForComparedCommitRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*GetCommentsForComparedCommitOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opGetCommentsForPullRequest = "GetCommentsForPullRequest"

// GetCommentsForPullRequestRequest generates a "aws/request.Request" representing the
// client's request for the GetCommentsForPullRequest operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetCommentsForPullRequest for more information on using the GetCommentsForPullRequest
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCommentsForPullRequestRequest method.
//    req, resp := client.GetCommentsForPullRequestRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentsForPullRequest
func (c *CodeCommit) GetCommentsForPullRequestRequest(input *GetCommentsForPullRequestInput) (req *request.Request, output *GetCommentsForPullRequestOutput) {
	op := &request.Operation{
		Name:       opGetCommentsForPullRequest,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetCommentsForPullRequestInput{}
	}

	output = &GetCommentsForPullRequestOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetCommentsForPullRequest API operation for AWS CodeCommit.
//
// Returns comments made on a pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetCommentsForPullRequest for usage and error information.
//
// Returned Error Codes:
//   * ErrCodePullRequestIdRequiredException "PullRequestIdRequiredException"
//   A pull request ID is required, but none was provided.
//
//   * ErrCodePullRequestDoesNotExistException "PullRequestDoesNotExistException"
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * ErrCodeInvalidPullRequestIdException "InvalidPullRequestIdException"
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeCommitIdRequiredException "CommitIdRequiredException"
//   A commit ID was not specified.
//
//   * ErrCodeInvalidCommitIdException "InvalidCommitIdException"
//   The specified commit ID is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidMaxResultsException "InvalidMaxResultsException"
//   The specified number of maximum results is not valid.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
//   * ErrCodeRepositoryNotAssociatedWithPullRequestException "RepositoryNotAssociatedWithPullRequestException"
//   The repository does not contain any pull requests with that pull request
//   ID. Use GetPullRequest to verify the correct repository name for the pull
//   request ID.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentsForPullRequest
func (c *CodeCommit) GetCommentsForPullRequest(input *GetCommentsForPullRequestInput) (*GetCommentsForPullRequestOutput, error) {
	req, out := c.GetCommentsForPullRequestRequest(input)
	return out, req.Send()
}

// GetCommentsForPullRequestWithContext is the same as GetCommentsForPullRequest with the addition of
// the ability to pass a context and additional request options.
//
// See GetCommentsForPullRequest for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentsForPullRequestWithContext(ctx aws.Context, input *GetCommentsForPullRequestInput, opts ...request.Option) (*GetCommentsForPullRequestOutput, error) {
	req, out := c.GetCommentsForPullRequestRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// GetCommentsForPullRequestPages iterates over the pages of a GetCommentsForPullRequest operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See GetCommentsForPullRequest method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetCommentsForPullRequest operation.
//    pageNum := 0
//    err := client.GetCommentsForPullRequestPages(params,
//        func(page *codecommit.GetCommentsForPullRequestOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) GetCommentsForPullRequestPages(input *GetCommentsForPullRequestInput, fn func(*GetCommentsForPullRequestOutput, bool) bool) error {
	return c.GetCommentsForPullRequestPagesWithContext(aws.BackgroundContext(), input, fn)
}

// GetCommentsForPullRequestPagesWithContext same as GetCommentsForPullRequestPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentsForPullRequestPagesWithContext(ctx aws.Context, input *GetCommentsForPullRequestInput, fn func(*GetCommentsForPullRequestOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *GetCommentsForPullRequestInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.GetCommentsForPullRequestRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*GetCommentsForPullRequestOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opGetCommit = "GetCommit"

// GetCommitRequest generates a "aws/request.Request" representing the
// client's request for the GetCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetCommit for more information on using the GetCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCommitRequest method.
//    req, resp := client.GetCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommit
func (c *CodeCommit) GetCommitRequest(input *GetCommitInput) (req *request.Request, output *GetCommitOutput) {
	op := &request.Operation{
		Name:       opGetCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetCommitInput{}
	}

	output = &GetCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetCommit API operation for AWS CodeCommit.
//
// Returns information about a commit, including commit message and committer
// information.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetCommit for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeCommitIdRequiredException "CommitIdRequiredException"
//   A commit ID was not specified.
//
//   * ErrCodeInvalidCommitIdException "InvalidCommitIdException"
//   The specified commit ID is not valid.
//
//   * ErrCodeCommitIdDoesNotExistException "CommitIdDoesNotExistException"
//   The specified commit ID does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommit
func (c *CodeCommit) GetCommit(input *GetCommitInput) (*GetCommitOutput, error) {
	req, out := c.GetCommitRequest(input)
	return out, req.Send()
}

// GetCommitWithContext is the same as GetCommit with the addition of
// the ability to pass a context and additional request options.
//
// See GetCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommitWithContext(ctx aws.Context, input *GetCommitInput, opts ...request.Option) (*GetCommitOutput, error) {
	req, out := c.GetCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetDifferences = "GetDifferences"

// GetDifferencesRequest generates a "aws/request.Request" representing the
// client's request for the GetDifferences operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetDifferences for more information on using the GetDifferences
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetDifferencesRequest method.
//    req, resp := client.GetDifferencesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetDifferences
func (c *CodeCommit) GetDifferencesRequest(input *GetDifferencesInput) (req *request.Request, output *GetDifferencesOutput) {
	op := &request.Operation{
		Name:       opGetDifferences,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetDifferencesInput{}
	}

	output = &GetDifferencesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetDifferences API operation for AWS CodeCommit.
//
// Returns information about the differences in a valid commit specifier (such
// as a branch, tag, HEAD, commit ID or other fully qualified reference). Results
// can be limited to a specified path.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetDifferences for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
//   * ErrCodeInvalidMaxResultsException "InvalidMaxResultsException"
//   The specified number of maximum results is not valid.
//
//   * ErrCodeInvalidCommitIdException "InvalidCommitIdException"
//   The specified commit ID is not valid.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodePathDoesNotExistException "PathDoesNotExistException"
//   The specified path does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetDifferences
func (c *CodeCommit) GetDifferences(input *GetDifferencesInput) (*GetDifferencesOutput, error) {
	req, out := c.GetDifferencesRequest(input)
	return out, req.Send()
}

// GetDifferencesWithContext is the same as GetDifferences with the addition of
// the ability to pass a context and additional request options.
//
// See GetDifferences for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetDifferencesWithContext(ctx aws.Context, input *GetDifferencesInput, opts ...request.Option) (*GetDifferencesOutput, error) {
	req, out := c.GetDifferencesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// GetDifferencesPages iterates over the pages of a GetDifferences operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See GetDifferences method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetDifferences operation.
//    pageNum := 0
//    err := client.GetDifferencesPages(params,
//        func(page *codecommit.GetDifferencesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) GetDifferencesPages(input *GetDifferencesInput, fn func(*GetDifferencesOutput, bool) bool) error {
	return c.GetDifferencesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// GetDifferencesPagesWithContext same as GetDifferencesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetDifferencesPagesWithContext(ctx aws.Context, input *GetDifferencesInput, fn func(*GetDifferencesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *GetDifferencesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.GetDifferencesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*GetDifferencesOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opGetFile = "GetFile"

// GetFileRequest generates a "aws/request.Request" representing the
// client's request for the GetFile operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetFile for more information on using the GetFile
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetFileRequest method.
//    req, resp := client.GetFileRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetFile
func (c *CodeCommit) GetFileRequest(input *GetFileInput) (req *request.Request, output *GetFileOutput) {
	op := &request.Operation{
		Name:       opGetFile,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetFileInput{}
	}

	output = &GetFileOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetFile API operation for AWS CodeCommit.
//
// Returns the base-64 encoded contents of a specified file and its metadata.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetFile for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeFileDoesNotExistException "FileDoesNotExistException"
//   The specified file does not exist. Verify that you have provided the correct
//   name of the file, including its full path and extension.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
//   * ErrCodeFileTooLargeException "FileTooLargeException"
//   The specified file exceeds the file size limit for AWS CodeCommit. For more
//   information about limits in AWS CodeCommit, see AWS CodeCommit User Guide
//   (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetFile
func (c *CodeCommit) GetFile(input *GetFileInput) (*GetFileOutput, error) {
	req, out := c.GetFileRequest(input)
	return out, req.Send()
}

// GetFileWithContext is the same as GetFile with the addition of
// the ability to pass a context and additional request options.
//
// See GetFile for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetFileWithContext(ctx aws.Context, input *GetFileInput, opts ...request.Option) (*GetFileOutput, error) {
	req, out := c.GetFileRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetFolder = "GetFolder"

// GetFolderRequest generates a "aws/request.Request" representing the
// client's request for the GetFolder operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetFolder for more information on using the GetFolder
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetFolderRequest method.
//    req, resp := client.GetFolderRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetFolder
func (c *CodeCommit) GetFolderRequest(input *GetFolderInput) (req *request.Request, output *GetFolderOutput) {
	op := &request.Operation{
		Name:       opGetFolder,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetFolderInput{}
	}

	output = &GetFolderOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetFolder API operation for AWS CodeCommit.
//
// Returns the contents of a specified folder in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetFolder for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeFolderDoesNotExistException "FolderDoesNotExistException"
//   The specified folder does not exist. Either the folder name is not correct,
//   or you did not provide the full path to the folder.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetFolder
func (c *CodeCommit) GetFolder(input *GetFolderInput) (*GetFolderOutput, error) {
	req, out := c.GetFolderRequest(input)
	return out, req.Send()
}

// GetFolderWithContext is the same as GetFolder with the addition of
// the ability to pass a context and additional request options.
//
// See GetFolder for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetFolderWithContext(ctx aws.Context, input *GetFolderInput, opts ...request.Option) (*GetFolderOutput, error) {
	req, out := c.GetFolderRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetMergeCommit = "GetMergeCommit"

// GetMergeCommitRequest generates a "aws/request.Request" representing the
// client's request for the GetMergeCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetMergeCommit for more information on using the GetMergeCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetMergeCommitRequest method.
//    req, resp := client.GetMergeCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeCommit
func (c *CodeCommit) GetMergeCommitRequest(input *GetMergeCommitInput) (req *request.Request, output *GetMergeCommitOutput) {
	op := &request.Operation{
		Name:       opGetMergeCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetMergeCommitInput{}
	}

	output = &GetMergeCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetMergeCommit API operation for AWS CodeCommit.
//
// Returns information about a specified merge commit.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetMergeCommit for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeCommit
func (c *CodeCommit) GetMergeCommit(input *GetMergeCommitInput) (*GetMergeCommitOutput, error) {
	req, out := c.GetMergeCommitRequest(input)
	return out, req.Send()
}

// GetMergeCommitWithContext is the same as GetMergeCommit with the addition of
// the ability to pass a context and additional request options.
//
// See GetMergeCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetMergeCommitWithContext(ctx aws.Context, input *GetMergeCommitInput, opts ...request.Option) (*GetMergeCommitOutput, error) {
	req, out := c.GetMergeCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetMergeConflicts = "GetMergeConflicts"

// GetMergeConflictsRequest generates a "aws/request.Request" representing the
// client's request for the GetMergeConflicts operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetMergeConflicts for more information on using the GetMergeConflicts
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetMergeConflictsRequest method.
//    req, resp := client.GetMergeConflictsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeConflicts
func (c *CodeCommit) GetMergeConflictsRequest(input *GetMergeConflictsInput) (req *request.Request, output *GetMergeConflictsOutput) {
	op := &request.Operation{
		Name:       opGetMergeConflicts,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxConflictFiles",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetMergeConflictsInput{}
	}

	output = &GetMergeConflictsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetMergeConflicts API operation for AWS CodeCommit.
//
// Returns information about merge conflicts between the before and after commit
// IDs for a pull request in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetMergeConflicts for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeMergeOptionRequiredException "MergeOptionRequiredException"
//   A merge option or stategy is required, and none was provided.
//
//   * ErrCodeInvalidMergeOptionException "InvalidMergeOptionException"
//   The specified merge option is not valid for this operation. Not all merge
//   strategies are supported for all operations.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodeInvalidMaxConflictFilesException "InvalidMaxConflictFilesException"
//   The specified value for the number of conflict files to return is not valid.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidDestinationCommitSpecifierException "InvalidDestinationCommitSpecifierException"
//   The destination commit specifier is not valid. You must provide a valid branch
//   name, tag, or full commit ID.
//
//   * ErrCodeInvalidSourceCommitSpecifierException "InvalidSourceCommitSpecifierException"
//   The source commit specifier is not valid. You must provide a valid branch
//   name, tag, or full commit ID.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeMaximumFileContentToLoadExceededException "MaximumFileContentToLoadExceededException"
//   The number of files to load exceeds the allowed limit.
//
//   * ErrCodeMaximumItemsToCompareExceededException "MaximumItemsToCompareExceededException"
//   The maximum number of items to compare between the source or destination
//   branches and the merge base has exceeded the maximum allowed.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeConflicts
func (c *CodeCommit) GetMergeConflicts(input *GetMergeConflictsInput) (*GetMergeConflictsOutput, error) {
	req, out := c.GetMergeConflictsRequest(input)
	return out, req.Send()
}

// GetMergeConflictsWithContext is the same as GetMergeConflicts with the addition of
// the ability to pass a context and additional request options.
//
// See GetMergeConflicts for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetMergeConflictsWithContext(ctx aws.Context, input *GetMergeConflictsInput, opts ...request.Option) (*GetMergeConflictsOutput, error) {
	req, out := c.GetMergeConflictsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// GetMergeConflictsPages iterates over the pages of a GetMergeConflicts operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See GetMergeConflicts method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetMergeConflicts operation.
//    pageNum := 0
//    err := client.GetMergeConflictsPages(params,
//        func(page *codecommit.GetMergeConflictsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) GetMergeConflictsPages(input *GetMergeConflictsInput, fn func(*GetMergeConflictsOutput, bool) bool) error {
	return c.GetMergeConflictsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// GetMergeConflictsPagesWithContext same as GetMergeConflictsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetMergeConflictsPagesWithContext(ctx aws.Context, input *GetMergeConflictsInput, fn func(*GetMergeConflictsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *GetMergeConflictsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.GetMergeConflictsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*GetMergeConflictsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opGetMergeOptions = "GetMergeOptions"

// GetMergeOptionsRequest generates a "aws/request.Request" representing the
// client's request for the GetMergeOptions operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetMergeOptions for more information on using the GetMergeOptions
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetMergeOptionsRequest method.
//    req, resp := client.GetMergeOptionsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeOptions
func (c *CodeCommit) GetMergeOptionsRequest(input *GetMergeOptionsInput) (req *request.Request, output *GetMergeOptionsOutput) {
	op := &request.Operation{
		Name:       opGetMergeOptions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetMergeOptionsInput{}
	}

	output = &GetMergeOptionsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetMergeOptions API operation for AWS CodeCommit.
//
// Returns information about the merge options available for merging two specified
// branches. For details about why a particular merge option is not available,
// use GetMergeConflicts or DescribeMergeConflicts.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetMergeOptions for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeMaximumFileContentToLoadExceededException "MaximumFileContentToLoadExceededException"
//   The number of files to load exceeds the allowed limit.
//
//   * ErrCodeMaximumItemsToCompareExceededException "MaximumItemsToCompareExceededException"
//   The maximum number of items to compare between the source or destination
//   branches and the merge base has exceeded the maximum allowed.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeOptions
func (c *CodeCommit) GetMergeOptions(input *GetMergeOptionsInput) (*GetMergeOptionsOutput, error) {
	req, out := c.GetMergeOptionsRequest(input)
	return out, req.Send()
}

// GetMergeOptionsWithContext is the same as GetMergeOptions with the addition of
// the ability to pass a context and additional request options.
//
// See GetMergeOptions for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetMergeOptionsWithContext(ctx aws.Context, input *GetMergeOptionsInput, opts ...request.Option) (*GetMergeOptionsOutput, error) {
	req, out := c.GetMergeOptionsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetPullRequest = "GetPullRequest"

// GetPullRequestRequest generates a "aws/request.Request" representing the
// client's request for the GetPullRequest operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetPullRequest for more information on using the GetPullRequest
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetPullRequestRequest method.
//    req, resp := client.GetPullRequestRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetPullRequest
func (c *CodeCommit) GetPullRequestRequest(input *GetPullRequestInput) (req *request.Request, output *GetPullRequestOutput) {
	op := &request.Operation{
		Name:       opGetPullRequest,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetPullRequestInput{}
	}

	output = &GetPullRequestOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetPullRequest API operation for AWS CodeCommit.
//
// Gets information about a pull request in a specified repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetPullRequest for usage and error information.
//
// Returned Error Codes:
//   * ErrCodePullRequestDoesNotExistException "PullRequestDoesNotExistException"
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * ErrCodeInvalidPullRequestIdException "InvalidPullRequestIdException"
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * ErrCodePullRequestIdRequiredException "PullRequestIdRequiredException"
//   A pull request ID is required, but none was provided.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetPullRequest
func (c *CodeCommit) GetPullRequest(input *GetPullRequestInput) (*GetPullRequestOutput, error) {
	req, out := c.GetPullRequestRequest(input)
	return out, req.Send()
}

// GetPullRequestWithContext is the same as GetPullRequest with the addition of
// the ability to pass a context and additional request options.
//
// See GetPullRequest for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetPullRequestWithContext(ctx aws.Context, input *GetPullRequestInput, opts ...request.Option) (*GetPullRequestOutput, error) {
	req, out := c.GetPullRequestRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetRepository = "GetRepository"

// GetRepositoryRequest generates a "aws/request.Request" representing the
// client's request for the GetRepository operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetRepository for more information on using the GetRepository
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetRepositoryRequest method.
//    req, resp := client.GetRepositoryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetRepository
func (c *CodeCommit) GetRepositoryRequest(input *GetRepositoryInput) (req *request.Request, output *GetRepositoryOutput) {
	op := &request.Operation{
		Name:       opGetRepository,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetRepositoryInput{}
	}

	output = &GetRepositoryOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetRepository API operation for AWS CodeCommit.
//
// Returns information about a repository.
//
// The description field for a repository accepts all HTML characters and all
// valid Unicode characters. Applications that do not HTML-encode the description
// and display it in a web page could expose users to potentially malicious
// code. Make sure that you HTML-encode the description field in any application
// that uses this API to display the repository description on a web page.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetRepository for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetRepository
func (c *CodeCommit) GetRepository(input *GetRepositoryInput) (*GetRepositoryOutput, error) {
	req, out := c.GetRepositoryRequest(input)
	return out, req.Send()
}

// GetRepositoryWithContext is the same as GetRepository with the addition of
// the ability to pass a context and additional request options.
//
// See GetRepository for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetRepositoryWithContext(ctx aws.Context, input *GetRepositoryInput, opts ...request.Option) (*GetRepositoryOutput, error) {
	req, out := c.GetRepositoryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetRepositoryTriggers = "GetRepositoryTriggers"

// GetRepositoryTriggersRequest generates a "aws/request.Request" representing the
// client's request for the GetRepositoryTriggers operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetRepositoryTriggers for more information on using the GetRepositoryTriggers
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetRepositoryTriggersRequest method.
//    req, resp := client.GetRepositoryTriggersRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetRepositoryTriggers
func (c *CodeCommit) GetRepositoryTriggersRequest(input *GetRepositoryTriggersInput) (req *request.Request, output *GetRepositoryTriggersOutput) {
	op := &request.Operation{
		Name:       opGetRepositoryTriggers,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetRepositoryTriggersInput{}
	}

	output = &GetRepositoryTriggersOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetRepositoryTriggers API operation for AWS CodeCommit.
//
// Gets information about triggers configured for a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetRepositoryTriggers for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetRepositoryTriggers
func (c *CodeCommit) GetRepositoryTriggers(input *GetRepositoryTriggersInput) (*GetRepositoryTriggersOutput, error) {
	req, out := c.GetRepositoryTriggersRequest(input)
	return out, req.Send()
}

// GetRepositoryTriggersWithContext is the same as GetRepositoryTriggers with the addition of
// the ability to pass a context and additional request options.
//
// See GetRepositoryTriggers for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetRepositoryTriggersWithContext(ctx aws.Context, input *GetRepositoryTriggersInput, opts ...request.Option) (*GetRepositoryTriggersOutput, error) {
	req, out := c.GetRepositoryTriggersRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListBranches = "ListBranches"

// ListBranchesRequest generates a "aws/request.Request" representing the
// client's request for the ListBranches operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListBranches for more information on using the ListBranches
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListBranchesRequest method.
//    req, resp := client.ListBranchesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListBranches
func (c *CodeCommit) ListBranchesRequest(input *ListBranchesInput) (req *request.Request, output *ListBranchesOutput) {
	op := &request.Operation{
		Name:       opListBranches,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListBranchesInput{}
	}

	output = &ListBranchesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListBranches API operation for AWS CodeCommit.
//
// Gets information about one or more branches in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListBranches for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListBranches
func (c *CodeCommit) ListBranches(input *ListBranchesInput) (*ListBranchesOutput, error) {
	req, out := c.ListBranchesRequest(input)
	return out, req.Send()
}

// ListBranchesWithContext is the same as ListBranches with the addition of
// the ability to pass a context and additional request options.
//
// See ListBranches for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListBranchesWithContext(ctx aws.Context, input *ListBranchesInput, opts ...request.Option) (*ListBranchesOutput, error) {
	req, out := c.ListBranchesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListBranchesPages iterates over the pages of a ListBranches operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListBranches method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListBranches operation.
//    pageNum := 0
//    err := client.ListBranchesPages(params,
//        func(page *codecommit.ListBranchesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) ListBranchesPages(input *ListBranchesInput, fn func(*ListBranchesOutput, bool) bool) error {
	return c.ListBranchesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListBranchesPagesWithContext same as ListBranchesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListBranchesPagesWithContext(ctx aws.Context, input *ListBranchesInput, fn func(*ListBranchesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListBranchesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListBranchesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListBranchesOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListPullRequests = "ListPullRequests"

// ListPullRequestsRequest generates a "aws/request.Request" representing the
// client's request for the ListPullRequests operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListPullRequests for more information on using the ListPullRequests
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListPullRequestsRequest method.
//    req, resp := client.ListPullRequestsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListPullRequests
func (c *CodeCommit) ListPullRequestsRequest(input *ListPullRequestsInput) (req *request.Request, output *ListPullRequestsOutput) {
	op := &request.Operation{
		Name:       opListPullRequests,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListPullRequestsInput{}
	}

	output = &ListPullRequestsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListPullRequests API operation for AWS CodeCommit.
//
// Returns a list of pull requests for a specified repository. The return list
// can be refined by pull request status or pull request author ARN.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListPullRequests for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidPullRequestStatusException "InvalidPullRequestStatusException"
//   The pull request status is not valid. The only valid values are OPEN and
//   CLOSED.
//
//   * ErrCodeInvalidAuthorArnException "InvalidAuthorArnException"
//   The Amazon Resource Name (ARN) is not valid. Make sure that you have provided
//   the full ARN for the author of the pull request, and then try again.
//
//   * ErrCodeAuthorDoesNotExistException "AuthorDoesNotExistException"
//   The specified Amazon Resource Name (ARN) does not exist in the AWS account.
//
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidMaxResultsException "InvalidMaxResultsException"
//   The specified number of maximum results is not valid.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListPullRequests
func (c *CodeCommit) ListPullRequests(input *ListPullRequestsInput) (*ListPullRequestsOutput, error) {
	req, out := c.ListPullRequestsRequest(input)
	return out, req.Send()
}

// ListPullRequestsWithContext is the same as ListPullRequests with the addition of
// the ability to pass a context and additional request options.
//
// See ListPullRequests for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListPullRequestsWithContext(ctx aws.Context, input *ListPullRequestsInput, opts ...request.Option) (*ListPullRequestsOutput, error) {
	req, out := c.ListPullRequestsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListPullRequestsPages iterates over the pages of a ListPullRequests operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListPullRequests method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListPullRequests operation.
//    pageNum := 0
//    err := client.ListPullRequestsPages(params,
//        func(page *codecommit.ListPullRequestsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) ListPullRequestsPages(input *ListPullRequestsInput, fn func(*ListPullRequestsOutput, bool) bool) error {
	return c.ListPullRequestsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListPullRequestsPagesWithContext same as ListPullRequestsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListPullRequestsPagesWithContext(ctx aws.Context, input *ListPullRequestsInput, fn func(*ListPullRequestsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListPullRequestsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListPullRequestsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListPullRequestsOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListRepositories = "ListRepositories"

// ListRepositoriesRequest generates a "aws/request.Request" representing the
// client's request for the ListRepositories operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListRepositories for more information on using the ListRepositories
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListRepositoriesRequest method.
//    req, resp := client.ListRepositoriesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListRepositories
func (c *CodeCommit) ListRepositoriesRequest(input *ListRepositoriesInput) (req *request.Request, output *ListRepositoriesOutput) {
	op := &request.Operation{
		Name:       opListRepositories,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListRepositoriesInput{}
	}

	output = &ListRepositoriesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListRepositories API operation for AWS CodeCommit.
//
// Gets information about one or more repositories.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListRepositories for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidSortByException "InvalidSortByException"
//   The specified sort by value is not valid.
//
//   * ErrCodeInvalidOrderException "InvalidOrderException"
//   The specified sort order is not valid.
//
//   * ErrCodeInvalidContinuationTokenException "InvalidContinuationTokenException"
//   The specified continuation token is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListRepositories
func (c *CodeCommit) ListRepositories(input *ListRepositoriesInput) (*ListRepositoriesOutput, error) {
	req, out := c.ListRepositoriesRequest(input)
	return out, req.Send()
}

// ListRepositoriesWithContext is the same as ListRepositories with the addition of
// the ability to pass a context and additional request options.
//
// See ListRepositories for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListRepositoriesWithContext(ctx aws.Context, input *ListRepositoriesInput, opts ...request.Option) (*ListRepositoriesOutput, error) {
	req, out := c.ListRepositoriesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListRepositoriesPages iterates over the pages of a ListRepositories operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListRepositories method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListRepositories operation.
//    pageNum := 0
//    err := client.ListRepositoriesPages(params,
//        func(page *codecommit.ListRepositoriesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) ListRepositoriesPages(input *ListRepositoriesInput, fn func(*ListRepositoriesOutput, bool) bool) error {
	return c.ListRepositoriesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListRepositoriesPagesWithContext same as ListRepositoriesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListRepositoriesPagesWithContext(ctx aws.Context, input *ListRepositoriesInput, fn func(*ListRepositoriesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListRepositoriesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListRepositoriesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	cont := true
	for p.Next() && cont {
		cont = fn(p.Page().(*ListRepositoriesOutput), !p.HasNextPage())
	}
	return p.Err()
}

const opListTagsForResource = "ListTagsForResource"

// ListTagsForResourceRequest generates a "aws/request.Request" representing the
// client's request for the ListTagsForResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListTagsForResource for more information on using the ListTagsForResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListTagsForResourceRequest method.
//    req, resp := client.ListTagsForResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListTagsForResource
func (c *CodeCommit) ListTagsForResourceRequest(input *ListTagsForResourceInput) (req *request.Request, output *ListTagsForResourceOutput) {
	op := &request.Operation{
		Name:       opListTagsForResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListTagsForResourceInput{}
	}

	output = &ListTagsForResourceOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListTagsForResource API operation for AWS CodeCommit.
//
// Gets information about AWS tags for a specified Amazon Resource Name (ARN)
// in AWS CodeCommit. For a list of valid resources in AWS CodeCommit, see CodeCommit
// Resources and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
// in the AWS CodeCommit User Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListTagsForResource for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeResourceArnRequiredException "ResourceArnRequiredException"
//   A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required.
//   For a list of valid resources in AWS CodeCommit, see CodeCommit Resources
//   and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
//   in the AWS CodeCommit User Guide.
//
//   * ErrCodeInvalidResourceArnException "InvalidResourceArnException"
//   The value for the resource ARN is not valid. For more information about resources
//   in AWS CodeCommit, see CodeCommit Resources and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
//   in the AWS CodeCommit User Guide.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListTagsForResource
func (c *CodeCommit) ListTagsForResource(input *ListTagsForResourceInput) (*ListTagsForResourceOutput, error) {
	req, out := c.ListTagsForResourceRequest(input)
	return out, req.Send()
}

// ListTagsForResourceWithContext is the same as ListTagsForResource with the addition of
// the ability to pass a context and additional request options.
//
// See ListTagsForResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListTagsForResourceWithContext(ctx aws.Context, input *ListTagsForResourceInput, opts ...request.Option) (*ListTagsForResourceOutput, error) {
	req, out := c.ListTagsForResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergeBranchesByFastForward = "MergeBranchesByFastForward"

// MergeBranchesByFastForwardRequest generates a "aws/request.Request" representing the
// client's request for the MergeBranchesByFastForward operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergeBranchesByFastForward for more information on using the MergeBranchesByFastForward
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergeBranchesByFastForwardRequest method.
//    req, resp := client.MergeBranchesByFastForwardRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesByFastForward
func (c *CodeCommit) MergeBranchesByFastForwardRequest(input *MergeBranchesByFastForwardInput) (req *request.Request, output *MergeBranchesByFastForwardOutput) {
	op := &request.Operation{
		Name:       opMergeBranchesByFastForward,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergeBranchesByFastForwardInput{}
	}

	output = &MergeBranchesByFastForwardOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergeBranchesByFastForward API operation for AWS CodeCommit.
//
// Merges two branches using the fast-forward merge strategy.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergeBranchesByFastForward for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidTargetBranchException "InvalidTargetBranchException"
//   The specified target branch is not valid.
//
//   * ErrCodeInvalidBranchNameException "InvalidBranchNameException"
//   The specified reference name is not valid.
//
//   * ErrCodeBranchNameRequiredException "BranchNameRequiredException"
//   A branch name is required but was not specified.
//
//   * ErrCodeBranchNameIsTagNameException "BranchNameIsTagNameException"
//   The specified branch name is not valid because it is a tag name. Type the
//   name of a current branch in the repository. For a list of valid branch names,
//   use ListBranches.
//
//   * ErrCodeBranchDoesNotExistException "BranchDoesNotExistException"
//   The specified branch does not exist.
//
//   * ErrCodeManualMergeRequiredException "ManualMergeRequiredException"
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * ErrCodeConcurrentReferenceUpdateException "ConcurrentReferenceUpdateException"
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesByFastForward
func (c *CodeCommit) MergeBranchesByFastForward(input *MergeBranchesByFastForwardInput) (*MergeBranchesByFastForwardOutput, error) {
	req, out := c.MergeBranchesByFastForwardRequest(input)
	return out, req.Send()
}

// MergeBranchesByFastForwardWithContext is the same as MergeBranchesByFastForward with the addition of
// the ability to pass a context and additional request options.
//
// See MergeBranchesByFastForward for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergeBranchesByFastForwardWithContext(ctx aws.Context, input *MergeBranchesByFastForwardInput, opts ...request.Option) (*MergeBranchesByFastForwardOutput, error) {
	req, out := c.MergeBranchesByFastForwardRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergeBranchesBySquash = "MergeBranchesBySquash"

// MergeBranchesBySquashRequest generates a "aws/request.Request" representing the
// client's request for the MergeBranchesBySquash operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergeBranchesBySquash for more information on using the MergeBranchesBySquash
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergeBranchesBySquashRequest method.
//    req, resp := client.MergeBranchesBySquashRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesBySquash
func (c *CodeCommit) MergeBranchesBySquashRequest(input *MergeBranchesBySquashInput) (req *request.Request, output *MergeBranchesBySquashOutput) {
	op := &request.Operation{
		Name:       opMergeBranchesBySquash,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergeBranchesBySquashInput{}
	}

	output = &MergeBranchesBySquashOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergeBranchesBySquash API operation for AWS CodeCommit.
//
// Merges two branches using the squash merge strategy.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergeBranchesBySquash for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidTargetBranchException "InvalidTargetBranchException"
//   The specified target branch is not valid.
//
//   * ErrCodeInvalidBranchNameException "InvalidBranchNameException"
//   The specified reference name is not valid.
//
//   * ErrCodeBranchNameRequiredException "BranchNameRequiredException"
//   A branch name is required but was not specified.
//
//   * ErrCodeBranchNameIsTagNameException "BranchNameIsTagNameException"
//   The specified branch name is not valid because it is a tag name. Type the
//   name of a current branch in the repository. For a list of valid branch names,
//   use ListBranches.
//
//   * ErrCodeBranchDoesNotExistException "BranchDoesNotExistException"
//   The specified branch does not exist.
//
//   * ErrCodeManualMergeRequiredException "ManualMergeRequiredException"
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeInvalidConflictResolutionException "InvalidConflictResolutionException"
//   The specified conflict resolution list is not valid.
//
//   * ErrCodeMaximumConflictResolutionEntriesExceededException "MaximumConflictResolutionEntriesExceededException"
//   The number of allowed conflict resolution entries was exceeded.
//
//   * ErrCodeMultipleConflictResolutionEntriesException "MultipleConflictResolutionEntriesException"
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ErrCodeReplacementTypeRequiredException "ReplacementTypeRequiredException"
//   A replacement type is required.
//
//   * ErrCodeInvalidReplacementTypeException "InvalidReplacementTypeException"
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * ErrCodeReplacementContentRequiredException "ReplacementContentRequiredException"
//   USE_NEW_CONTENT was specified but no replacement content has been provided.
//
//   * ErrCodeInvalidReplacementContentException "InvalidReplacementContentException"
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeFileContentSizeLimitExceededException "FileContentSizeLimitExceededException"
//   The file cannot be added because it is too large. The maximum file size that
//   can be added is 6 MB, and the combined file content change size is 7 MB.
//   Consider making these changes using a Git client.
//
//   * ErrCodeFolderContentSizeLimitExceededException "FolderContentSizeLimitExceededException"
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * ErrCodeMaximumFileContentToLoadExceededException "MaximumFileContentToLoadExceededException"
//   The number of files to load exceeds the allowed limit.
//
//   * ErrCodeMaximumItemsToCompareExceededException "MaximumItemsToCompareExceededException"
//   The maximum number of items to compare between the source or destination
//   branches and the merge base has exceeded the maximum allowed.
//
//   * ErrCodeFileModeRequiredException "FileModeRequiredException"
//   The commit cannot be created because a file mode is required to update mode
//   permissions for an existing file, but no file mode has been specified.
//
//   * ErrCodeInvalidFileModeException "InvalidFileModeException"
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * ErrCodeNameLengthExceededException "NameLengthExceededException"
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * ErrCodeInvalidEmailException "InvalidEmailException"
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * ErrCodeCommitMessageLengthExceededException "CommitMessageLengthExceededException"
//   The commit message is too long. Provide a shorter string.
//
//   * ErrCodeConcurrentReferenceUpdateException "ConcurrentReferenceUpdateException"
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesBySquash
func (c *CodeCommit) MergeBranchesBySquash(input *MergeBranchesBySquashInput) (*MergeBranchesBySquashOutput, error) {
	req, out := c.MergeBranchesBySquashRequest(input)
	return out, req.Send()
}

// MergeBranchesBySquashWithContext is the same as MergeBranchesBySquash with the addition of
// the ability to pass a context and additional request options.
//
// See MergeBranchesBySquash for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergeBranchesBySquashWithContext(ctx aws.Context, input *MergeBranchesBySquashInput, opts ...request.Option) (*MergeBranchesBySquashOutput, error) {
	req, out := c.MergeBranchesBySquashRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergeBranchesByThreeWay = "MergeBranchesByThreeWay"

// MergeBranchesByThreeWayRequest generates a "aws/request.Request" representing the
// client's request for the MergeBranchesByThreeWay operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergeBranchesByThreeWay for more information on using the MergeBranchesByThreeWay
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergeBranchesByThreeWayRequest method.
//    req, resp := client.MergeBranchesByThreeWayRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesByThreeWay
func (c *CodeCommit) MergeBranchesByThreeWayRequest(input *MergeBranchesByThreeWayInput) (req *request.Request, output *MergeBranchesByThreeWayOutput) {
	op := &request.Operation{
		Name:       opMergeBranchesByThreeWay,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergeBranchesByThreeWayInput{}
	}

	output = &MergeBranchesByThreeWayOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergeBranchesByThreeWay API operation for AWS CodeCommit.
//
// Merges two specified branches using the three-way merge strategy.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergeBranchesByThreeWay for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodeCommitRequiredException "CommitRequiredException"
//   A commit was not specified.
//
//   * ErrCodeInvalidCommitException "InvalidCommitException"
//   The specified commit is not valid.
//
//   * ErrCodeCommitDoesNotExistException "CommitDoesNotExistException"
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * ErrCodeInvalidTargetBranchException "InvalidTargetBranchException"
//   The specified target branch is not valid.
//
//   * ErrCodeInvalidBranchNameException "InvalidBranchNameException"
//   The specified reference name is not valid.
//
//   * ErrCodeBranchNameRequiredException "BranchNameRequiredException"
//   A branch name is required but was not specified.
//
//   * ErrCodeBranchNameIsTagNameException "BranchNameIsTagNameException"
//   The specified branch name is not valid because it is a tag name. Type the
//   name of a current branch in the repository. For a list of valid branch names,
//   use ListBranches.
//
//   * ErrCodeBranchDoesNotExistException "BranchDoesNotExistException"
//   The specified branch does not exist.
//
//   * ErrCodeManualMergeRequiredException "ManualMergeRequiredException"
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * ErrCodeConcurrentReferenceUpdateException "ConcurrentReferenceUpdateException"
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeInvalidConflictResolutionException "InvalidConflictResolutionException"
//   The specified conflict resolution list is not valid.
//
//   * ErrCodeMaximumConflictResolutionEntriesExceededException "MaximumConflictResolutionEntriesExceededException"
//   The number of allowed conflict resolution entries was exceeded.
//
//   * ErrCodeMultipleConflictResolutionEntriesException "MultipleConflictResolutionEntriesException"
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ErrCodeReplacementTypeRequiredException "ReplacementTypeRequiredException"
//   A replacement type is required.
//
//   * ErrCodeInvalidReplacementTypeException "InvalidReplacementTypeException"
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * ErrCodeReplacementContentRequiredException "ReplacementContentRequiredException"
//   USE_NEW_CONTENT was specified but no replacement content has been provided.
//
//   * ErrCodeInvalidReplacementContentException "InvalidReplacementContentException"
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeFileContentSizeLimitExceededException "FileContentSizeLimitExceededException"
//   The file cannot be added because it is too large. The maximum file size that
//   can be added is 6 MB, and the combined file content change size is 7 MB.
//   Consider making these changes using a Git client.
//
//   * ErrCodeFolderContentSizeLimitExceededException "FolderContentSizeLimitExceededException"
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * ErrCodeMaximumFileContentToLoadExceededException "MaximumFileContentToLoadExceededException"
//   The number of files to load exceeds the allowed limit.
//
//   * ErrCodeMaximumItemsToCompareExceededException "MaximumItemsToCompareExceededException"
//   The maximum number of items to compare between the source or destination
//   branches and the merge base has exceeded the maximum allowed.
//
//   * ErrCodeFileModeRequiredException "FileModeRequiredException"
//   The commit cannot be created because a file mode is required to update mode
//   permissions for an existing file, but no file mode has been specified.
//
//   * ErrCodeInvalidFileModeException "InvalidFileModeException"
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * ErrCodeNameLengthExceededException "NameLengthExceededException"
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * ErrCodeInvalidEmailException "InvalidEmailException"
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * ErrCodeCommitMessageLengthExceededException "CommitMessageLengthExceededException"
//   The commit message is too long. Provide a shorter string.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesByThreeWay
func (c *CodeCommit) MergeBranchesByThreeWay(input *MergeBranchesByThreeWayInput) (*MergeBranchesByThreeWayOutput, error) {
	req, out := c.MergeBranchesByThreeWayRequest(input)
	return out, req.Send()
}

// MergeBranchesByThreeWayWithContext is the same as MergeBranchesByThreeWay with the addition of
// the ability to pass a context and additional request options.
//
// See MergeBranchesByThreeWay for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergeBranchesByThreeWayWithContext(ctx aws.Context, input *MergeBranchesByThreeWayInput, opts ...request.Option) (*MergeBranchesByThreeWayOutput, error) {
	req, out := c.MergeBranchesByThreeWayRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergePullRequestByFastForward = "MergePullRequestByFastForward"

// MergePullRequestByFastForwardRequest generates a "aws/request.Request" representing the
// client's request for the MergePullRequestByFastForward operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergePullRequestByFastForward for more information on using the MergePullRequestByFastForward
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergePullRequestByFastForwardRequest method.
//    req, resp := client.MergePullRequestByFastForwardRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestByFastForward
func (c *CodeCommit) MergePullRequestByFastForwardRequest(input *MergePullRequestByFastForwardInput) (req *request.Request, output *MergePullRequestByFastForwardOutput) {
	op := &request.Operation{
		Name:       opMergePullRequestByFastForward,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergePullRequestByFastForwardInput{}
	}

	output = &MergePullRequestByFastForwardOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergePullRequestByFastForward API operation for AWS CodeCommit.
//
// Attempts to merge the source commit of a pull request into the specified
// destination branch for that pull request at the specified commit using the
// fast-forward merge strategy. If the merge is successful, it closes the pull
// request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergePullRequestByFastForward for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeManualMergeRequiredException "ManualMergeRequiredException"
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * ErrCodePullRequestAlreadyClosedException "PullRequestAlreadyClosedException"
//   The pull request status cannot be updated because it is already closed.
//
//   * ErrCodePullRequestDoesNotExistException "PullRequestDoesNotExistException"
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * ErrCodeInvalidPullRequestIdException "InvalidPullRequestIdException"
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * ErrCodePullRequestIdRequiredException "PullRequestIdRequiredException"
//   A pull request ID is required, but none was provided.
//
//   * ErrCodeTipOfSourceReferenceIsDifferentException "TipOfSourceReferenceIsDifferentException"
//   The tip of the source branch in the destination repository does not match
//   the tip of the source branch specified in your request. The pull request
//   might have been updated. Make sure that you have the latest changes.
//
//   * ErrCodeReferenceDoesNotExistException "ReferenceDoesNotExistException"
//   The specified reference does not exist. You must provide a full commit ID.
//
//   * ErrCodeInvalidCommitIdException "InvalidCommitIdException"
//   The specified commit ID is not valid.
//
//   * ErrCodeRepositoryNotAssociatedWithPullRequestException "RepositoryNotAssociatedWithPullRequestException"
//   The repository does not contain any pull requests with that pull request
//   ID. Use GetPullRequest to verify the correct repository name for the pull
//   request ID.
//
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeConcurrentReferenceUpdateException "ConcurrentReferenceUpdateException"
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestByFastForward
func (c *CodeCommit) MergePullRequestByFastForward(input *MergePullRequestByFastForwardInput) (*MergePullRequestByFastForwardOutput, error) {
	req, out := c.MergePullRequestByFastForwardRequest(input)
	return out, req.Send()
}

// MergePullRequestByFastForwardWithContext is the same as MergePullRequestByFastForward with the addition of
// the ability to pass a context and additional request options.
//
// See MergePullRequestByFastForward for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergePullRequestByFastForwardWithContext(ctx aws.Context, input *MergePullRequestByFastForwardInput, opts ...request.Option) (*MergePullRequestByFastForwardOutput, error) {
	req, out := c.MergePullRequestByFastForwardRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergePullRequestBySquash = "MergePullRequestBySquash"

// MergePullRequestBySquashRequest generates a "aws/request.Request" representing the
// client's request for the MergePullRequestBySquash operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergePullRequestBySquash for more information on using the MergePullRequestBySquash
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergePullRequestBySquashRequest method.
//    req, resp := client.MergePullRequestBySquashRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestBySquash
func (c *CodeCommit) MergePullRequestBySquashRequest(input *MergePullRequestBySquashInput) (req *request.Request, output *MergePullRequestBySquashOutput) {
	op := &request.Operation{
		Name:       opMergePullRequestBySquash,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergePullRequestBySquashInput{}
	}

	output = &MergePullRequestBySquashOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergePullRequestBySquash API operation for AWS CodeCommit.
//
// Attempts to merge the source commit of a pull request into the specified
// destination branch for that pull request at the specified commit using the
// squash merge strategy. If the merge is successful, it closes the pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergePullRequestBySquash for usage and error information.
//
// Returned Error Codes:
//   * ErrCodePullRequestAlreadyClosedException "PullRequestAlreadyClosedException"
//   The pull request status cannot be updated because it is already closed.
//
//   * ErrCodePullRequestDoesNotExistException "PullRequestDoesNotExistException"
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * ErrCodePullRequestIdRequiredException "PullRequestIdRequiredException"
//   A pull request ID is required, but none was provided.
//
//   * ErrCodeInvalidPullRequestIdException "InvalidPullRequestIdException"
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * ErrCodeInvalidCommitIdException "InvalidCommitIdException"
//   The specified commit ID is not valid.
//
//   * ErrCodeManualMergeRequiredException "ManualMergeRequiredException"
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * ErrCodeTipOfSourceReferenceIsDifferentException "TipOfSourceReferenceIsDifferentException"
//   The tip of the source branch in the destination repository does not match
//   the tip of the source branch specified in your request. The pull request
//   might have been updated. Make sure that you have the latest changes.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodeNameLengthExceededException "NameLengthExceededException"
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * ErrCodeInvalidEmailException "InvalidEmailException"
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * ErrCodeCommitMessageLengthExceededException "CommitMessageLengthExceededException"
//   The commit message is too long. Provide a shorter string.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeInvalidConflictResolutionException "InvalidConflictResolutionException"
//   The specified conflict resolution list is not valid.
//
//   * ErrCodeReplacementTypeRequiredException "ReplacementTypeRequiredException"
//   A replacement type is required.
//
//   * ErrCodeInvalidReplacementTypeException "InvalidReplacementTypeException"
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * ErrCodeMultipleConflictResolutionEntriesException "MultipleConflictResolutionEntriesException"
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ErrCodeReplacementContentRequiredException "ReplacementContentRequiredException"
//   USE_NEW_CONTENT was specified but no replacement content has been provided.
//
//   * ErrCodeMaximumConflictResolutionEntriesExceededException "MaximumConflictResolutionEntriesExceededException"
//   The number of allowed conflict resolution entries was exceeded.
//
//   * ErrCodeConcurrentReferenceUpdateException "ConcurrentReferenceUpdateException"
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeInvalidFileModeException "InvalidFileModeException"
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * ErrCodeInvalidReplacementContentException "InvalidReplacementContentException"
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * ErrCodeFileContentSizeLimitExceededException "FileContentSizeLimitExceededException"
//   The file cannot be added because it is too large. The maximum file size that
//   can be added is 6 MB, and the combined file content change size is 7 MB.
//   Consider making these changes using a Git client.
//
//   * ErrCodeFolderContentSizeLimitExceededException "FolderContentSizeLimitExceededException"
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * ErrCodeMaximumFileContentToLoadExceededException "MaximumFileContentToLoadExceededException"
//   The number of files to load exceeds the allowed limit.
//
//   * ErrCodeMaximumItemsToCompareExceededException "MaximumItemsToCompareExceededException"
//   The maximum number of items to compare between the source or destination
//   branches and the merge base has exceeded the maximum allowed.
//
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeRepositoryNotAssociatedWithPullRequestException "RepositoryNotAssociatedWithPullRequestException"
//   The repository does not contain any pull requests with that pull request
//   ID. Use GetPullRequest to verify the correct repository name for the pull
//   request ID.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestBySquash
func (c *CodeCommit) MergePullRequestBySquash(input *MergePullRequestBySquashInput) (*MergePullRequestBySquashOutput, error) {
	req, out := c.MergePullRequestBySquashRequest(input)
	return out, req.Send()
}

// MergePullRequestBySquashWithContext is the same as MergePullRequestBySquash with the addition of
// the ability to pass a context and additional request options.
//
// See MergePullRequestBySquash for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergePullRequestBySquashWithContext(ctx aws.Context, input *MergePullRequestBySquashInput, opts ...request.Option) (*MergePullRequestBySquashOutput, error) {
	req, out := c.MergePullRequestBySquashRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergePullRequestByThreeWay = "MergePullRequestByThreeWay"

// MergePullRequestByThreeWayRequest generates a "aws/request.Request" representing the
// client's request for the MergePullRequestByThreeWay operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergePullRequestByThreeWay for more information on using the MergePullRequestByThreeWay
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergePullRequestByThreeWayRequest method.
//    req, resp := client.MergePullRequestByThreeWayRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestByThreeWay
func (c *CodeCommit) MergePullRequestByThreeWayRequest(input *MergePullRequestByThreeWayInput) (req *request.Request, output *MergePullRequestByThreeWayOutput) {
	op := &request.Operation{
		Name:       opMergePullRequestByThreeWay,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergePullRequestByThreeWayInput{}
	}

	output = &MergePullRequestByThreeWayOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergePullRequestByThreeWay API operation for AWS CodeCommit.
//
// Attempts to merge the source commit of a pull request into the specified
// destination branch for that pull request at the specified commit using the
// three-way merge strategy. If the merge is successful, it closes the pull
// request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergePullRequestByThreeWay for usage and error information.
//
// Returned Error Codes:
//   * ErrCodePullRequestAlreadyClosedException "PullRequestAlreadyClosedException"
//   The pull request status cannot be updated because it is already closed.
//
//   * ErrCodePullRequestDoesNotExistException "PullRequestDoesNotExistException"
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * ErrCodePullRequestIdRequiredException "PullRequestIdRequiredException"
//   A pull request ID is required, but none was provided.
//
//   * ErrCodeInvalidPullRequestIdException "InvalidPullRequestIdException"
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * ErrCodeInvalidCommitIdException "InvalidCommitIdException"
//   The specified commit ID is not valid.
//
//   * ErrCodeManualMergeRequiredException "ManualMergeRequiredException"
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * ErrCodeTipOfSourceReferenceIsDifferentException "TipOfSourceReferenceIsDifferentException"
//   The tip of the source branch in the destination repository does not match
//   the tip of the source branch specified in your request. The pull request
//   might have been updated. Make sure that you have the latest changes.
//
//   * ErrCodeTipsDivergenceExceededException "TipsDivergenceExceededException"
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * ErrCodeNameLengthExceededException "NameLengthExceededException"
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * ErrCodeInvalidEmailException "InvalidEmailException"
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * ErrCodeCommitMessageLengthExceededException "CommitMessageLengthExceededException"
//   The commit message is too long. Provide a shorter string.
//
//   * ErrCodeInvalidConflictDetailLevelException "InvalidConflictDetailLevelException"
//   The specified conflict detail level is not valid.
//
//   * ErrCodeInvalidConflictResolutionStrategyException "InvalidConflictResolutionStrategyException"
//   The specified conflict resolution strategy is not valid.
//
//   * ErrCodeInvalidConflictResolutionException "InvalidConflictResolutionException"
//   The specified conflict resolution list is not valid.
//
//   * ErrCodeReplacementTypeRequiredException "ReplacementTypeRequiredException"
//   A replacement type is required.
//
//   * ErrCodeInvalidReplacementTypeException "InvalidReplacementTypeException"
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * ErrCodeMultipleConflictResolutionEntriesException "MultipleConflictResolutionEntriesException"
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ErrCodeReplacementContentRequiredException "ReplacementContentRequiredException"
//   USE_NEW_CONTENT was specified but no replacement content has been provided.
//
//   * ErrCodeMaximumConflictResolutionEntriesExceededException "MaximumConflictResolutionEntriesExceededException"
//   The number of allowed conflict resolution entries was exceeded.
//
//   * ErrCodePathRequiredException "PathRequiredException"
//   The folderPath for a location cannot be null.
//
//   * ErrCodeInvalidPathException "InvalidPathException"
//   The specified path is not valid.
//
//   * ErrCodeInvalidFileModeException "InvalidFileModeException"
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * ErrCodeInvalidReplacementContentException "InvalidReplacementContentException"
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * ErrCodeFileContentSizeLimitExceededException "FileContentSizeLimitExceededException"
//   The file cannot be added because it is too large. The maximum file size that
//   can be added is 6 MB, and the combined file content change size is 7 MB.
//   Consider making these changes using a Git client.
//
//   * ErrCodeFolderContentSizeLimitExceededException "FolderContentSizeLimitExceededException"
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * ErrCodeMaximumFileContentToLoadExceededException "MaximumFileContentToLoadExceededException"
//   The number of files to load exceeds the allowed limit.
//
//   * ErrCodeMaximumItemsToCompareExceededException "MaximumItemsToCompareExceededException"
//   The maximum number of items to compare between the source or destination
//   branches and the merge base has exceeded the maximum allowed.
//
//   * ErrCodeRepositoryNameRequiredException "RepositoryNameRequiredException"
//   A repository name is required but was not specified.
//
//   * ErrCodeInvalidRepositoryNameException "InvalidRepositoryNameException"
//   At least one specified repository name is not valid.
//
//   This exception only occurs when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ErrCodeRepositoryDoesNotExistException "RepositoryDoesNotExistException"
//   The specified repository does not exist.
//
//   * ErrCodeRepositoryNotAssociatedWithPullRequestException "RepositoryNotAssociatedWithPullRequestException"
//   The repository does not contain any pull requests with that pull request
//   ID. Use GetPullRequest to verify the correct repository name for the pull
//   request ID.
//
//   * ErrCodeConcurrentReferenceUpdateException "ConcurrentReferenceUpdateException"
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * ErrCodeEncryptionIntegrityChecksFailedException "EncryptionIntegrityChecksFailedException"
//   An encryption integrity check failed.
//
//   * ErrCodeEncryptionKeyAccessDeniedException "EncryptionKeyAccessDeniedException"
//   An encryption key could not be accessed.
//
//   * ErrCodeEncryptionKeyDisabledException "EncryptionKeyDisabledException"
//   The encryption key is disabled.
//
//   * ErrCodeEncryptionKeyNotFoundException "EncryptionKeyNotFoundException"
//   No encryption key was found.
//
//   * ErrCodeEncryptionKeyUnavailableException "EncryptionKeyUnavailableException"
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestByThreeWay
func (c *CodeCommit) MergePullRequestByThreeWay(input *MergePullRequestByThreeWayInput) (*MergePullRequestByThreeWayOutput, error) {
	req, out := c.MergePullRequestByThreeWayRequest(input)
	return out, req.Send()
}

// MergePullRequestByThreeWayWithContext is the same as MergePullRequestByThreeWay with the addition of
// the ability to pass a context and additional request options.
//
// See MergePullRequestByThreeWay for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergePullRequestByThreeWayWithContext(ctx aws.Context, input *MergePullRequestByThreeWayInput, opts ...request.Option) (*MergePullRequestByThreeWayOutput, error) {
	req, out := c.MergePullRequestByThreeWayRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opPostCommentForComparedCommit = "PostCommentForComparedCommit"

// PostCommentForComparedCommitRequest generates a "aws/request.Request" representing the
// client's request for the PostCommentForComparedCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See PostCommentForComparedCommit for more information on using the PostCommentForComparedCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the PostCommentForComparedCommitRequest method.
//    req, resp := client.PostCommentForComparedCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PostCommentForComparedCommit
func (c *CodeCommit) PostCommentForComparedCommitRequest(input *PostCommentForComparedCommitInput) (req *request.Request, output *PostCommentForComparedCommitOutput) {
	op := &request.Operation{
		Name:       opPostCommentForComparedCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PostCommentForComparedCommitInput{}
	}

	output = &PostCommentForComparedCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// PostCommentForComparedCommit API operation for AWS CodeCommit.
//
// Posts a comment on the comparison between two commits.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get de